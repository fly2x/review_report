<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/sdf4j#15</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/sdf4j - PR #15</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">9</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">1</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">3</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">3</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">2</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title critical">Critical</div>
<div class="issue">
                <div class="issue-title">RSA 4096-bit support incomplete - native struct size mismatch</div>
                <div class="issue-location">sdf4j/src/main/native/include/sdf_types.h:89-92</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>#define RSAref_MAX_BITS     2048
#define RSAref_MAX_LEN      ((RSAref_MAX_BITS + 7) / 8)</pre>
                <div class="problem"><strong>Issue:</strong> The Java classes RSAPublicKey and RSAPrivateKey were updated to support 4096-bit RSA keys (changing RSA_MAX_BITS from 2048 to 4096), but the native C structures RSArefPublicKey and RSArefPrivateKey still define RSAref_MAX_BITS as 2048. This causes silent data truncation when using 4096-bit keys and ABI incompatibility between Java and native layers.</div>
                <div class="fix-label">Fix:</div><pre>#define RSAref_MAX_BITS     4096
#define RSAref_MAX_LEN      ((RSAref_MAX_BITS + 7) / 8)
#define RSAref_MAX_PBITS    ((RSAref_MAX_BITS + 1) / 2)
#define RSAref_MAX_PLEN     ((RSAref_MAX_PBITS + 7) / 8)</pre>
            </div>
</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">RSA envelope output buffer overflow potential</div>
                <div class="issue-location">sdf4j/src/main/native/src/sdf_jni_asymmetric.c:379</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>ULONG output_len = (native_key.bits + 7) / 8;
BYTE *output_buf = (BYTE*)malloc(output_len);</pre>
                <div class="problem"><strong>Issue:</strong> The output buffer is allocated based on native_key.bits, which is user-controlled. If a malicious RSAPublicKey object has bits set to a large value while the actual m/e arrays are smaller, this could cause buffer overflow or excessive memory allocation.</div>
                <div class="fix-label">Fix:</div><pre>ULONG output_len = (native_key.bits + 7) / 8;
/* Cap output buffer size to RSAref_MAX_LEN (256 bytes) */
if (output_len &gt; RSAref_MAX_LEN) {
    THROW_SDF_EXCEPTION(env, SDR_INARGERR, "Key bits too large");
    return NULL;
}
BYTE *output_buf = (BYTE*)malloc(output_len);</pre>
            </div>
<div class="issue">
                <div class="issue-title">Documentation claims 4096-bit RSA support not implemented in native code</div>
                <div class="issue-location">docs/API_GUIDE.md:1095-1101</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>| `SDF_ExportSignPublicKey_RSA(sessionHandle, keyIndex)` | 导出RSA签名公钥  (最大规格4096 bits) |
| `SDF_ExportEncPublicKey_RSA(sessionHandle, keyIndex)` | 导出RSA加密公钥  (最大规格4096 bits) |</pre>
                <div class="problem"><strong>Issue:</strong> The API documentation claims RSA functions support 4096-bit keys, but the native C code still limits RSA keys to 2048 bits (RSAref_MAX_BITS = 2048 in sdf_types.h). This is misleading and could lead to silent data truncation.</div>
                <div class="fix-label">Fix:</div><pre>| `SDF_ExportSignPublicKey_RSA(sessionHandle, keyIndex)` | 导出RSA签名公钥 (当前实现最大规格2048 bits) |
| `SDF_ExportEncPublicKey_RSA(sessionHandle, keyIndex)` | 导出RSA加密公钥 (当前实现最大规格2048 bits) |
| `SDF_GenerateKeyWithIPK_RSA(sessionHandle, keyIndex, keyBits)` | 用内部RSA公钥生成会话密钥 (当前实现最大规格2048 bits) |
| `SDF_GenerateKeyWithEPK_RSA(sessionHandle, keyBits, publicKey)` | 用外部RSA公钥生成会话密钥 (当前实现最大规格2048 bits) |
| `SDF_ImportKeyWithISK_RSA(sessionHandle, keyIndex, encryptedKey)` | 用内部RSA私钥导入会话密钥 (当前实现最大规格2048 bits) |
| `SDF_ExternalPublicKeyOperation_RSA(sessionHandle, publicKey, data)` | 外部公钥RSA运算 (当前实现最大规格2048 bits) |
| `SDF_InternalPublicKeyOperation_RSA(sessionHandle, keyIndex, data)` | 内部公钥RSA运算 (当前实现最大规格2048 bits) |
| `SDF_InternalPrivateKeyOperation_RSA(sessionHandle, keyIndex, data)` | 内部私钥RSA运算 (当前实现最大规格2048 bits) |
| `SDF_ExchangeDigitEnvelopeBaseOnRSA(sessionHandle, uiKeyIndex, pucPublicKey, pucDEInput)` | RSA 数字信封转换 (当前实现最大规格2048 bits) |</pre>
            </div>
<div class="issue">
                <div class="issue-title">AuthDecFinal buffer size reduced to unsafe value</div>
                <div class="issue-location">sdf4j/src/main/native/src/sdf_jni_symmetric.c:1274-1276</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>/* max len is the last block size */
ULONG output_len = 16;
BYTE output_buf[16];</pre>
                <div class="problem"><strong>Issue:</strong> The output buffer for SDF_AuthDecFinal was reduced from 4096 bytes to just 16 bytes. For authenticated decryption (GCM mode), the final block may need more than 16 bytes, especially considering the last plaintext block. This could cause buffer overflow or truncated output.</div>
                <div class="fix-label">Fix:</div><pre>ULONG output_len = 256;
BYTE output_buf[256];</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Test uses uninitialized input array</div>
                <div class="issue-location">examples/src/test/java/org/openhitls/sdf4j/examples/AsymmetricOperationTest.java:968</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>byte[] deInput = new byte[256];
byte[] deOutput = sdf.SDF_ExchangeDigitEnvelopeBaseOnRSA(sessionHandle, keyIndex, publicKey, deInput);</pre>
                <div class="problem"><strong>Issue:</strong> The test creates a 256-byte input array filled with zeros but doesn't verify this is valid input for the RSA envelope operation. The test may pass due to SDR_NOTSUPPORT exception rather than actually testing the function.</div>
                <div class="fix-label">Fix:</div><pre>// First create a valid digital envelope, then test exchanging it
Object[] keyPair = sdf.SDF_GenerateKeyPair_RSA(sessionHandle, 2048);
assertNotNull(keyPair);
RSAPublicKey publicKey = (RSAPublicKey) keyPair[0];

KeyEncryptionResult wrapped = sdf.SDF_GenerateKeyWithIPK_RSA(sessionHandle, keyIndex, 128);
try {
    byte[] deOutput = sdf.SDF_ExchangeDigitEnvelopeBaseOnRSA(
            sessionHandle, keyIndex, publicKey, wrapped.getEncryptedKey());
    assertNotNull(deOutput);
    assertTrue("输出长度应大于0", deOutput.length &gt; 0);
} finally {
    sdf.SDF_DestroyKey(sessionHandle, wrapped.getKeyHandle());
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Zero-length buffer allocation for ECC decrypt</div>
                <div class="issue-location">sdf4j/src/main/native/src/sdf_jni_util.c:250-251</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ULONG plaintext_len = ecc_cipher-&gt;L;
BYTE *plaintext_buf = (BYTE*)malloc(plaintext_len);</pre>
                <div class="problem"><strong>Issue:</strong> If ecc_cipher->L is 0, malloc(0) behavior is implementation-defined and may return NULL or a non-dereferenceable pointer.</div>
                <div class="fix-label">Fix:</div><pre>ULONG plaintext_len = ecc_cipher-&gt;L;
if (plaintext_len == 0) {
    free(ecc_cipher);
    THROW_SDF_EXCEPTION(env, SDR_INARGERR, "Invalid cipher length");
    return NULL;
}
BYTE *plaintext_buf = (BYTE*)malloc(plaintext_len);</pre>
            </div>
<div class="issue">
                <div class="issue-title">RSA private operation buffer sizing trusts mutable key metadata</div>
                <div class="issue-location">sdf4j/src/main/native/src/sdf_jni_util.c:135-137</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ULONG output_len = (priv_key.bits + 7) / 8;
BYTE *output_buf = (BYTE*)malloc(output_len);</pre>
                <div class="problem"><strong>Issue:</strong> Buffer length depends on priv_key.bits from Java object state. If bits is inconsistent or zero, output buffer can be under-sized/invalid before calling SDF_ExternalPrivateKeyOperation_RSA.</div>
                <div class="fix-label">Fix:</div><pre>if (priv_key.bits == 0 || priv_key.bits &gt; RSAref_MAX_BITS) {
    free(input_buf);
    THROW_SDF_EXCEPTION(env, SDR_INARGERR, "Invalid RSA key bits");
    return NULL;
}
ULONG output_len = (priv_key.bits + 7) / 8;
BYTE *output_buf = (BYTE*)malloc(output_len);</pre>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Newly added algorithm IDs are not handled by getAlgorithmName</div>
                <div class="issue-location">sdf4j/src/main/java/org/openhitls/sdf4j/constants/AlgorithmID.java:167-271</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>public static final int SGD_SM2 = 0x00020100;
public static final int SGD_SM2_DECRYPT = 0x00020801;
public static final int SGD_SM3_HMAC = 0x00100001;</pre>
                <div class="problem"><strong>Issue:</strong> SGD_SM2, SGD_SM2_DECRYPT, and SGD_SM3_HMAC were added, but getAlgorithmName() has no matching cases, so these constants resolve to "Unknown(...)".</div>
                <div class="fix-label">Fix:</div><pre>// Add to getAlgorithmName():
case SGD_SM2:
    return "SM2";
case SGD_SM2_1:
    return "SM2-Sign";
case SGD_SM2_2:
    return "SM2-KeyExchange";
case SGD_SM2_3:
    return "SM2-Encrypt";
case SGD_SM2_DECRYPT:
    return "SM2-Decrypt";
case SGD_SM3:
    return "SM3";
case SGD_SM3_HMAC:
    return "SM3-HMAC";</pre>
            </div>
<div class="issue">
                <div class="issue-title">API signature typo in RSA digital envelope entry</div>
                <div class="issue-location">docs/API_GUIDE.md:1126</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>| `SDF_ExchangeDigitEnvelopeBaseOnRSA(sessionHandle, uiKeyIndex, pucPublicKey, pucDEInput))` | RSA 数字信封转换 (最大规格4096 bits) |</pre>
                <div class="problem"><strong>Issue:</strong> The documented method has an extra closing parenthesis, which makes the signature incorrect for copy/paste usage.</div>
                <div class="fix-label">Fix:</div><pre>| `SDF_ExchangeDigitEnvelopeBaseOnRSA(sessionHandle, uiKeyIndex, pucPublicKey, pucDEInput)` | RSA 数字信封转换 (最大规格4096 bits) |</pre>
            </div>
</div>
</div></body></html>