[
  {
    "source": "gemini",
    "file": "sdf4j/src/main/native/src/sdf_jni_device.c",
    "line": "220",
    "severity": "critical",
    "title": "Plaintext Password Logging",
    "problem": "The function `JNI_SDF_GetPrivateKeyAccessRight` logs the user's password in plaintext. This is a severe security vulnerability that leaks sensitive credentials to the application logs.",
    "code": "SDF_JNI_LOG(\"SDF_GetPrivateKeyAccessRight: pwd='%s', pwd_len=%lu\",\n                pwd ? pwd : \"(null)\", (unsigned long)pwd_len);",
    "fix": "SDF_JNI_LOG(\"SDF_GetPrivateKeyAccessRight: pwd='***', pwd_len=%lu\",\n                (unsigned long)pwd_len);"
  },
  {
    "source": "gemini",
    "file": "sdf4j/src/main/native/src/sdf_jni_device.c",
    "line": "282",
    "severity": "critical",
    "title": "Plaintext Password Logging",
    "problem": "The function `JNI_SDF_GetKEKAccessRight` logs the user's password in plaintext.",
    "code": "SDF_JNI_LOG(\"SDF_GetKEKAccessRight: pwd='%s', pwd_len=%lu\",\n                pwd ? pwd : \"(null)\", (unsigned long)pwd_len);",
    "fix": "SDF_JNI_LOG(\"SDF_GetKEKAccessRight: pwd='***', pwd_len=%lu\",\n                (unsigned long)pwd_len);"
  },
  {
    "source": "gemini",
    "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
    "line": "531-558",
    "severity": "critical",
    "title": "Heap Buffer Overflow in JNI_SDF_AuthEncFinal",
    "problem": "The function allocates `output_buf` based on the size of the input Java array `pucEncData`. The `SDF_AuthEncFinal` C function writes final ciphertext (padding) and authentication tag. If the user passes a small or empty array (e.g., `new byte[0]`), `malloc` allocates a small buffer, but `SDF_AuthEncFinal` writes padding bytes, causing a heap buffer overflow. Additionally, copying data from `pucEncData` (`GetByteArrayRegion`) is unnecessary as `SDF_AuthEncFinal` is an output-only function for the ciphertext buffer.",
    "code": "/* Convert pucEncData to native buffer */\n    BYTE *output_buf = NULL;\n    ULONG output_len = 0;\n    if (pucEncData != NULL) {\n        output_len = (*env)->GetArrayLength(env, pucEncData);\n        output_buf = (BYTE*)malloc(output_len);\n        if (output_buf == NULL) {\n            throw_sdf_exception(env, 0x0100001C);\n            return NULL;\n        }\n        (*env)->GetByteArrayRegion(env, pucEncData, 0, output_len, (jbyte*)output_buf);\n    }",
    "fix": "/* Allocate output buffer with sufficient size for padding (e.g. 256 bytes) */\n    /* pucEncData input is ignored as this is a finalization step producing new data */\n    ULONG output_len = 256; \n    BYTE *output_buf = (BYTE*)malloc(output_len);\n    if (output_buf == NULL) {\n        throw_sdf_exception(env, 0x0100001C);\n        return NULL;\n    }\n    /* Do not copy from pucEncData */"
  },
  {
    "source": "gemini",
    "file": "sdf4j/src/main/native/src/type_conversion.c",
    "line": "350-353",
    "severity": "high",
    "title": "Heap Buffer Over-read in java_to_native_ECCCipher_alloc",
    "problem": "The function allows the `L` field of `ECCCipher` to be set to a value larger than the actual allocated size of the `C` array. `native_cipher->L` is set to `l_value` (from Java object), while the memory allocated depends on the Java byte array length. If a malicious user sets a large `L` and a small `C` array, subsequent native calls (like `SDF_ExternalDecrypt_ECC`) will read past the allocated buffer boundary.",
    "code": "/* L - cipher data length */\n    native_cipher->L = (ULONG)l_value;\n    if (native_cipher->L == 0 && c_len > 0) {\n        native_cipher->L = c_len;\n    }",
    "fix": "/* L - cipher data length */\n    /* Ensure L does not exceed actual buffer size to prevent over-read */\n    if (l_value > c_len) {\n        SDF_LOG_ERROR(\"java_to_native_ECCCipher_alloc\", \"Invalid L value: exceeds array length\");\n        free(native_cipher);\n        return NULL;\n    }\n    native_cipher->L = (ULONG)l_value;\n    if (native_cipher->L == 0 && c_len > 0) {\n        native_cipher->L = c_len;\n    }"
  },
  {
    "source": "gemini",
    "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
    "line": "433",
    "severity": "medium",
    "title": "Potential Pointer Corruption in JNI_SDF_AuthDec",
    "problem": "The function casts `jsize*` (int*) to `ULONG*` (unsigned int*). While `ULONG` is typedef'd to `unsigned int` in this project (making it 32-bit and likely safe), this cast is dangerous. If `ULONG` were ever changed to `unsigned long` (64-bit on Linux), `SDF_AuthDec` would overwrite stack memory adjacent to `tag_len`.",
    "code": "LONG ret = g_sdf_functions.SDF_AuthDec(\n        (HANDLE)sessionHandle,\n        (HANDLE)keyHandle,\n        (ULONG)algID,\n        (BYTE*)iv_buf,\n        (ULONG)iv_len,\n        (BYTE*)aad_buf,\n        (ULONG)aad_len,\n        (BYTE*)tag_buf,\n        (ULONG *)&tag_len,\n        (BYTE*)enc_buf,",
    "fix": "ULONG ul_tag_len = (ULONG)tag_len;\n    LONG ret = g_sdf_functions.SDF_AuthDec(\n        (HANDLE)sessionHandle,\n        (HANDLE)keyHandle,\n        (ULONG)algID,\n        (BYTE*)iv_buf,\n        (ULONG)iv_len,\n        (BYTE*)aad_buf,\n        (ULONG)aad_len,\n        (BYTE*)tag_buf,\n        &ul_tag_len,\n        (BYTE*)enc_buf,"
  }
]