===ISSUE===
FILE: sdf4j/src/main/native/src/sdf_jni_device.c
LINE: 227-290
SEVERITY: critical
TITLE: Plaintext password logging in access-right calls
REVIEWERS: GEMINI
CONFIDENCE: likely
PROBLEM: Both access-right JNI functions log the full password string in plaintext, leaking sensitive credentials to logs.
CODE:
```
ULONG pwd_len = pwd ? strlen(pwd) : 0;
SDF_JNI_LOG("SDF_GetPrivateKeyAccessRight: pwd='%s', pwd_len=%lu",
            pwd ? pwd : "(null)", (unsigned long)pwd_len);
...
ULONG pwd_len = pwd ? strlen(pwd) : 0;
SDF_JNI_LOG("SDF_GetKEKAccessRight: pwd='%s', pwd_len=%lu",
            pwd ? pwd : "(null)", (unsigned long)pwd_len);
```
FIX:
```
ULONG pwd_len = pwd ? strlen(pwd) : 0;
SDF_JNI_LOG("SDF_GetPrivateKeyAccessRight: pwd='***', pwd_len=%lu",
            (unsigned long)pwd_len);
...
ULONG pwd_len = pwd ? strlen(pwd) : 0;
SDF_JNI_LOG("SDF_GetKEKAccessRight: pwd='***', pwd_len=%lu",
            (unsigned long)pwd_len);
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/sdf_jni_symmetric.c
LINE: 1114-1142
SEVERITY: critical
TITLE: AuthEncFinal uses user-sized buffer, risking heap overflow
REVIEWERS: GEMINI
CONFIDENCE: likely
PROBLEM: Output buffer size is derived from Java input array length and the code copies input bytes even though the buffer is output-only. If the caller passes a small array, the native SDF_AuthEncFinal can write beyond the allocated buffer.
CODE:
```
/* Convert pucEncData to native buffer */
BYTE *output_buf = NULL;
ULONG output_len = 0;
if (pucEncData != NULL) {
    output_len = (*env)->GetArrayLength(env, pucEncData);
    output_buf = (BYTE*)malloc(output_len);
    ...
    (*env)->GetByteArrayRegion(env, pucEncData, 0, output_len, (jbyte*)output_buf);
}
...
LONG ret = g_sdf_functions.SDF_AuthEncFinal(
    (HANDLE)sessionHandle,
    output_buf,
    &output_len,
    tag_buf,
    &tag_len
);
```
FIX:
```
/* Allocate a safe output buffer for final block + padding */
ULONG output_len = 128; /* or block_size + max padding */
BYTE *output_buf = (BYTE*)malloc(output_len);
if (output_buf == NULL) {
    throw_sdf_exception(env, 0x0100001C);
    return NULL;
}
/* Do not copy from pucEncData; this is output-only */
LONG ret = g_sdf_functions.SDF_AuthEncFinal(
    (HANDLE)sessionHandle,
    output_buf,
    &output_len,
    tag_buf,
    &tag_len
);
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/type_conversion.c
LINE: 319-399
SEVERITY: critical
TITLE: Unbounded ECC byte array copies overflow fixed-size buffers
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: Java-provided ECC arrays are copied into fixed-size native buffers without clamping to `ECCref_MAX_LEN` (and ECCSignature is not zeroed). Oversized inputs can corrupt memory.
CODE:
```
jsize len = (*env)->GetArrayLength(env, x_array);
(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_cipher->x);
...
jsize len = (*env)->GetArrayLength(env, x_array);
(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_key->x);
...
jsize len = (*env)->GetArrayLength(env, r_array);
(*env)->GetByteArrayRegion(env, r_array, 0, len, (jbyte*)native_sig->r);
```
FIX:
```
/* ECCCipher x/y */
jsize len = (*env)->GetArrayLength(env, x_array);
if (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;
(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_cipher->x);

/* ECCPublicKey x/y */
jsize len = (*env)->GetArrayLength(env, x_array);
if (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;
(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_key->x);

/* ECCSignature */
memset(native_sig, 0, sizeof(ECCSignature));
jsize len = (*env)->GetArrayLength(env, r_array);
if (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;
(*env)->GetByteArrayRegion(env, r_array, 0, len, (jbyte*)native_sig->r);
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/type_conversion.c
LINE: 617-628
SEVERITY: critical
TITLE: ECC private key copy can overflow native buffer
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: `java_to_native_ECCPrivateKey` copies the full Java array into `native_key->K` without clamping or zeroing, risking buffer overflow and leaving uninitialized bytes.
CODE:
```
/* k */
jbyteArray k_array = (jbyteArray)(*env)->GetObjectField(env, java_key,
                                                         g_jni_cache.eccPrivateKey.k);
if (k_array != NULL) {
    jsize len = (*env)->GetArrayLength(env, k_array);
    (*env)->GetByteArrayRegion(env, k_array, 0, len, (jbyte*)native_key->K);
}
```
FIX:
```
memset(native_key, 0, sizeof(ECCrefPrivateKey));
native_key->bits = (*env)->GetIntField(env, java_key, g_jni_cache.eccPrivateKey.bits);

jbyteArray k_array = (jbyteArray)(*env)->GetObjectField(env, java_key,
                                                         g_jni_cache.eccPrivateKey.k);
if (k_array != NULL) {
    jsize len = (*env)->GetArrayLength(env, k_array);
    if (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;
    (*env)->GetByteArrayRegion(env, k_array, 0, len, (jbyte*)native_key->K);
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/type_conversion.c
LINE: 344-348
SEVERITY: high
TITLE: ECCCipher L field can exceed allocated C buffer length
REVIEWERS: GEMINI
CONFIDENCE: likely
PROBLEM: `native_cipher->L` is set from Java without validating against the allocated `C` length. A larger `L` can cause over-reads in downstream native operations.
CODE:
```
/* L - cipher data length */
native_cipher->L = (ULONG)l_value;
if (native_cipher->L == 0 && c_len > 0) {
    native_cipher->L = c_len;
}
```
FIX:
```
if (l_value > c_len) {
    SDF_LOG_ERROR("java_to_native_ECCCipher_alloc", "Invalid L: exceeds C length");
    free(native_cipher);
    return NULL;
}
native_cipher->L = (ULONG)l_value;
if (native_cipher->L == 0 && c_len > 0) {
    native_cipher->L = c_len;
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java
LINE: 173-176
SEVERITY: medium
TITLE: Null unboxing in device close guard causes NPE
REVIEWERS: CLAUDE, CODEX
CONFIDENCE: trusted
PROBLEM: `gDevHandle` is a `Long`. The guard `gDevHandle == 0` auto-unboxes and throws `NullPointerException` when `gDevHandle` is null (e.g., close before open or after prior close).
CODE:
```
if (gDevHandle == 0 || deviceHandle != gDevHandle) {
    return;
}
```
FIX:
```
if (gDevHandle == null || deviceHandle != gDevHandle.longValue()) {
    return;
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java
LINE: 229-234
SEVERITY: medium
TITLE: ConcurrentModificationException while closing session keys
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: The loop iterates `sessionResource.keys` and removes from the same set inside the loop, which can throw `ConcurrentModificationException` and leave keys undisposed.
CODE:
```
for (Long keyHandle : sessionResource.keys) {
    sessionResource.removeKey(keyHandle);
    SDF_DestroyKey_Native(sessionHandle, keyHandle);
}
```
FIX:
```
for (Long keyHandle : new java.util.HashSet<>(sessionResource.keys)) {
    sessionResource.removeKey(keyHandle);
    SDF_DestroyKey_Native(sessionHandle, keyHandle);
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java
LINE: 204-208
SEVERITY: medium
TITLE: Session creation assumes device resource initialized
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: `SessionResource` relies on `gDevResource` being non-null. If `SDF_OpenSession` is called when the device is not open, the native call succeeds but Java then throws `NullPointerException`, leaking the native session handle.
CODE:
```
long handle = SDF_OpenSessionNative(deviceHandle);
// 创建 SessionResource 并注册到 gDevResource 和 gSessResource
SessionResource sessionResource = new SessionResource(handle);
gSessResource.put(handle, sessionResource);
```
FIX:
```
if (gDevHandle == null || gDevResource == null || deviceHandle != gDevHandle.longValue()) {
    throw new IllegalStateException("Device not opened");
}
long handle = SDF_OpenSessionNative(deviceHandle);
SessionResource sessionResource = new SessionResource(handle);
gSessResource.put(handle, sessionResource);
```
===END===

===ISSUE===
FILE: sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java
LINE: 68-71
SEVERITY: low
TITLE: DeviceResource.finalize may throw NPE on null handle
REVIEWERS: CLAUDE
CONFIDENCE: likely
PROBLEM: `finalize()` unconditionally passes `gDevHandle` to `SDF_CloseDevice`. If `gDevHandle` is null, auto-unboxing throws `NullPointerException` and skips cleanup.
CODE:
```
@Override
protected void finalize() throws Throwable {
    try {
        SDF_CloseDevice(gDevHandle);
    } finally {
        super.finalize();
    }
}
```
FIX:
```
@Override
protected void finalize() throws Throwable {
    try {
        Long handle = gDevHandle;
        if (handle != null) {
            SDF_CloseDevice(handle.longValue());
        }
    } finally {
        super.finalize();
    }
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java
LINE: 100-103
SEVERITY: low
TITLE: SessionResource.finalize aborts on first key destruction error
REVIEWERS: CLAUDE
CONFIDENCE: likely
PROBLEM: If `SDF_DestroyKey_Native` throws for one key, the loop stops and remaining keys are not destroyed.
CODE:
```
for (Long keyHandle : keys) {
        SDF_DestroyKey_Native(sessionHandle, keyHandle);
}
```
FIX:
```
for (Long keyHandle : new java.util.HashSet<>(keys)) {
    try {
        SDF_DestroyKey_Native(sessionHandle, keyHandle);
    } catch (Exception ignored) {
        // continue cleanup
    }
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/sdf_jni_symmetric.c
LINE: 303-308
SEVERITY: low
TITLE: Decrypt logs plaintext before checking return code
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: Plaintext is logged unconditionally even when decryption fails, which can log uninitialized data or partial plaintext.
CODE:
```
LONG ret = g_sdf_functions.SDF_Decrypt(...);

SDF_JNI_LOG("SDF_Decrypt: output_len=%lu", data_len);
SDF_LOG_HEX("SDF_Decrypt plaintext", data_buf, data_len);
```
FIX:
```
LONG ret = g_sdf_functions.SDF_Decrypt(...);

if (ret == SDR_OK) {
    SDF_JNI_LOG("SDF_Decrypt: output_len=%lu", data_len);
    SDF_LOG_HEX("SDF_Decrypt plaintext", data_buf, data_len);
}
```
===END===

===ISSUE===
FILE: sdf4j/src/main/native/src/sdf_jni_asymmetric.c
LINE: 229-232
SEVERITY: low
TITLE: Wrong log tag in InternalEncrypt_ECC error path
REVIEWERS: CLAUDE
CONFIDENCE: likely
PROBLEM: The error log uses the external-encrypt tag inside `JNI_SDF_InternalEncrypt_ECC`, making logs misleading.
CODE:
```
if (data_buf == NULL) {
    SDF_LOG_ERROR("SDF_ExternalEncrypt_ECC", "GetPrimitiveArrayCritical failed");
    throw_sdf_exception(env, 0x0100001C);  /* SDR_NOBUFFER */
    return NULL;
}
```
FIX:
```
if (data_buf == NULL) {
    SDF_LOG_ERROR("SDF_InternalEncrypt_ECC", "GetPrimitiveArrayCritical failed");
    throw_sdf_exception(env, 0x0100001C);  /* SDR_NOBUFFER */
    return NULL;
}
```
===END===