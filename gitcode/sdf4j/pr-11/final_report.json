{
  "context": {
    "owner": "openHiTLS",
    "repo": "sdf4j",
    "pr_id": "11",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 12,
    "critical": 4,
    "high": 1,
    "medium": 3,
    "low": 4
  },
  "issues": [
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_device.c",
      "line": "227-290",
      "severity": "critical",
      "title": "Plaintext password logging in access-right calls",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "Both access-right JNI functions log the full password string in plaintext, leaking sensitive credentials to logs.",
      "code": "ULONG pwd_len = pwd ? strlen(pwd) : 0;\nSDF_JNI_LOG(\"SDF_GetPrivateKeyAccessRight: pwd='%s', pwd_len=%lu\",\n            pwd ? pwd : \"(null)\", (unsigned long)pwd_len);\n...\nULONG pwd_len = pwd ? strlen(pwd) : 0;\nSDF_JNI_LOG(\"SDF_GetKEKAccessRight: pwd='%s', pwd_len=%lu\",\n            pwd ? pwd : \"(null)\", (unsigned long)pwd_len);",
      "fix": "ULONG pwd_len = pwd ? strlen(pwd) : 0;\nSDF_JNI_LOG(\"SDF_GetPrivateKeyAccessRight: pwd='***', pwd_len=%lu\",\n            (unsigned long)pwd_len);\n...\nULONG pwd_len = pwd ? strlen(pwd) : 0;\nSDF_JNI_LOG(\"SDF_GetKEKAccessRight: pwd='***', pwd_len=%lu\",\n            (unsigned long)pwd_len);"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
      "line": "1114-1142",
      "severity": "critical",
      "title": "AuthEncFinal uses user-sized buffer, risking heap overflow",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "Output buffer size is derived from Java input array length and the code copies input bytes even though the buffer is output-only. If the caller passes a small array, the native SDF_AuthEncFinal can write beyond the allocated buffer.",
      "code": "/* Convert pucEncData to native buffer */\nBYTE *output_buf = NULL;\nULONG output_len = 0;\nif (pucEncData != NULL) {\n    output_len = (*env)->GetArrayLength(env, pucEncData);\n    output_buf = (BYTE*)malloc(output_len);\n    ...\n    (*env)->GetByteArrayRegion(env, pucEncData, 0, output_len, (jbyte*)output_buf);\n}\n...\nLONG ret = g_sdf_functions.SDF_AuthEncFinal(\n    (HANDLE)sessionHandle,\n    output_buf,\n    &output_len,\n    tag_buf,\n    &tag_len\n);",
      "fix": "/* Allocate a safe output buffer for final block + padding */\nULONG output_len = 128; /* or block_size + max padding */\nBYTE *output_buf = (BYTE*)malloc(output_len);\nif (output_buf == NULL) {\n    throw_sdf_exception(env, 0x0100001C);\n    return NULL;\n}\n/* Do not copy from pucEncData; this is output-only */\nLONG ret = g_sdf_functions.SDF_AuthEncFinal(\n    (HANDLE)sessionHandle,\n    output_buf,\n    &output_len,\n    tag_buf,\n    &tag_len\n);"
    },
    {
      "file": "sdf4j/src/main/native/src/type_conversion.c",
      "line": "319-399",
      "severity": "critical",
      "title": "Unbounded ECC byte array copies overflow fixed-size buffers",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "Java-provided ECC arrays are copied into fixed-size native buffers without clamping to `ECCref_MAX_LEN` (and ECCSignature is not zeroed). Oversized inputs can corrupt memory.",
      "code": "jsize len = (*env)->GetArrayLength(env, x_array);\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_cipher->x);\n...\njsize len = (*env)->GetArrayLength(env, x_array);\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_key->x);\n...\njsize len = (*env)->GetArrayLength(env, r_array);\n(*env)->GetByteArrayRegion(env, r_array, 0, len, (jbyte*)native_sig->r);",
      "fix": "/* ECCCipher x/y */\njsize len = (*env)->GetArrayLength(env, x_array);\nif (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_cipher->x);\n\n/* ECCPublicKey x/y */\njsize len = (*env)->GetArrayLength(env, x_array);\nif (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_key->x);\n\n/* ECCSignature */\nmemset(native_sig, 0, sizeof(ECCSignature));\njsize len = (*env)->GetArrayLength(env, r_array);\nif (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;\n(*env)->GetByteArrayRegion(env, r_array, 0, len, (jbyte*)native_sig->r);"
    },
    {
      "file": "sdf4j/src/main/native/src/type_conversion.c",
      "line": "617-628",
      "severity": "critical",
      "title": "ECC private key copy can overflow native buffer",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`java_to_native_ECCPrivateKey` copies the full Java array into `native_key->K` without clamping or zeroing, risking buffer overflow and leaving uninitialized bytes.",
      "code": "/* k */\njbyteArray k_array = (jbyteArray)(*env)->GetObjectField(env, java_key,\n                                                         g_jni_cache.eccPrivateKey.k);\nif (k_array != NULL) {\n    jsize len = (*env)->GetArrayLength(env, k_array);\n    (*env)->GetByteArrayRegion(env, k_array, 0, len, (jbyte*)native_key->K);\n}",
      "fix": "memset(native_key, 0, sizeof(ECCrefPrivateKey));\nnative_key->bits = (*env)->GetIntField(env, java_key, g_jni_cache.eccPrivateKey.bits);\n\njbyteArray k_array = (jbyteArray)(*env)->GetObjectField(env, java_key,\n                                                         g_jni_cache.eccPrivateKey.k);\nif (k_array != NULL) {\n    jsize len = (*env)->GetArrayLength(env, k_array);\n    if (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;\n    (*env)->GetByteArrayRegion(env, k_array, 0, len, (jbyte*)native_key->K);\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/type_conversion.c",
      "line": "344-348",
      "severity": "high",
      "title": "ECCCipher L field can exceed allocated C buffer length",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "`native_cipher->L` is set from Java without validating against the allocated `C` length. A larger `L` can cause over-reads in downstream native operations.",
      "code": "/* L - cipher data length */\nnative_cipher->L = (ULONG)l_value;\nif (native_cipher->L == 0 && c_len > 0) {\n    native_cipher->L = c_len;\n}",
      "fix": "if (l_value > c_len) {\n    SDF_LOG_ERROR(\"java_to_native_ECCCipher_alloc\", \"Invalid L: exceeds C length\");\n    free(native_cipher);\n    return NULL;\n}\nnative_cipher->L = (ULONG)l_value;\nif (native_cipher->L == 0 && c_len > 0) {\n    native_cipher->L = c_len;\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "173-176",
      "severity": "medium",
      "title": "Null unboxing in device close guard causes NPE",
      "reviewers": "CLAUDE, CODEX",
      "confidence": "trusted",
      "problem": "`gDevHandle` is a `Long`. The guard `gDevHandle == 0` auto-unboxes and throws `NullPointerException` when `gDevHandle` is null (e.g., close before open or after prior close).",
      "code": "if (gDevHandle == 0 || deviceHandle != gDevHandle) {\n    return;\n}",
      "fix": "if (gDevHandle == null || deviceHandle != gDevHandle.longValue()) {\n    return;\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "229-234",
      "severity": "medium",
      "title": "ConcurrentModificationException while closing session keys",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "The loop iterates `sessionResource.keys` and removes from the same set inside the loop, which can throw `ConcurrentModificationException` and leave keys undisposed.",
      "code": "for (Long keyHandle : sessionResource.keys) {\n    sessionResource.removeKey(keyHandle);\n    SDF_DestroyKey_Native(sessionHandle, keyHandle);\n}",
      "fix": "for (Long keyHandle : new java.util.HashSet<>(sessionResource.keys)) {\n    sessionResource.removeKey(keyHandle);\n    SDF_DestroyKey_Native(sessionHandle, keyHandle);\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "204-208",
      "severity": "medium",
      "title": "Session creation assumes device resource initialized",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`SessionResource` relies on `gDevResource` being non-null. If `SDF_OpenSession` is called when the device is not open, the native call succeeds but Java then throws `NullPointerException`, leaking the native session handle.",
      "code": "long handle = SDF_OpenSessionNative(deviceHandle);\n// 创建 SessionResource 并注册到 gDevResource 和 gSessResource\nSessionResource sessionResource = new SessionResource(handle);\ngSessResource.put(handle, sessionResource);",
      "fix": "if (gDevHandle == null || gDevResource == null || deviceHandle != gDevHandle.longValue()) {\n    throw new IllegalStateException(\"Device not opened\");\n}\nlong handle = SDF_OpenSessionNative(deviceHandle);\nSessionResource sessionResource = new SessionResource(handle);\ngSessResource.put(handle, sessionResource);"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "68-71",
      "severity": "low",
      "title": "DeviceResource.finalize may throw NPE on null handle",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`finalize()` unconditionally passes `gDevHandle` to `SDF_CloseDevice`. If `gDevHandle` is null, auto-unboxing throws `NullPointerException` and skips cleanup.",
      "code": "@Override\nprotected void finalize() throws Throwable {\n    try {\n        SDF_CloseDevice(gDevHandle);\n    } finally {\n        super.finalize();\n    }\n}",
      "fix": "@Override\nprotected void finalize() throws Throwable {\n    try {\n        Long handle = gDevHandle;\n        if (handle != null) {\n            SDF_CloseDevice(handle.longValue());\n        }\n    } finally {\n        super.finalize();\n    }\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "100-103",
      "severity": "low",
      "title": "SessionResource.finalize aborts on first key destruction error",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "If `SDF_DestroyKey_Native` throws for one key, the loop stops and remaining keys are not destroyed.",
      "code": "for (Long keyHandle : keys) {\n        SDF_DestroyKey_Native(sessionHandle, keyHandle);\n}",
      "fix": "for (Long keyHandle : new java.util.HashSet<>(keys)) {\n    try {\n        SDF_DestroyKey_Native(sessionHandle, keyHandle);\n    } catch (Exception ignored) {\n        // continue cleanup\n    }\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
      "line": "303-308",
      "severity": "low",
      "title": "Decrypt logs plaintext before checking return code",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "Plaintext is logged unconditionally even when decryption fails, which can log uninitialized data or partial plaintext.",
      "code": "LONG ret = g_sdf_functions.SDF_Decrypt(...);\n\nSDF_JNI_LOG(\"SDF_Decrypt: output_len=%lu\", data_len);\nSDF_LOG_HEX(\"SDF_Decrypt plaintext\", data_buf, data_len);",
      "fix": "LONG ret = g_sdf_functions.SDF_Decrypt(...);\n\nif (ret == SDR_OK) {\n    SDF_JNI_LOG(\"SDF_Decrypt: output_len=%lu\", data_len);\n    SDF_LOG_HEX(\"SDF_Decrypt plaintext\", data_buf, data_len);\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_asymmetric.c",
      "line": "229-232",
      "severity": "low",
      "title": "Wrong log tag in InternalEncrypt_ECC error path",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The error log uses the external-encrypt tag inside `JNI_SDF_InternalEncrypt_ECC`, making logs misleading.",
      "code": "if (data_buf == NULL) {\n    SDF_LOG_ERROR(\"SDF_ExternalEncrypt_ECC\", \"GetPrimitiveArrayCritical failed\");\n    throw_sdf_exception(env, 0x0100001C);  /* SDR_NOBUFFER */\n    return NULL;\n}",
      "fix": "if (data_buf == NULL) {\n    SDF_LOG_ERROR(\"SDF_InternalEncrypt_ECC\", \"GetPrimitiveArrayCritical failed\");\n    throw_sdf_exception(env, 0x0100001C);  /* SDR_NOBUFFER */\n    return NULL;\n}"
    }
  ]
}