{
  "context": {
    "owner": "openHiTLS",
    "repo": "sdf4j",
    "pr_id": "11",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 15,
    "critical": 4,
    "high": 3,
    "medium": 6,
    "low": 2
  },
  "issues": [
    {
      "file": "sdf4j/src/main/native/src/type_conversion.c",
      "line": "300-450",
      "severity": "critical",
      "title": "Unbounded ECC field copies can overflow native buffers",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "Java byte arrays are copied into fixed-size ECC buffers without clamping to `ECCref_MAX_LEN`, so oversized inputs can overwrite native structs (ECCCipher x/y, ECCPublicKey x/y, ECCSignature r/s, ECCPrivateKey K).",
      "code": "jsize len = (*env)->GetArrayLength(env, x_array);\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_cipher->x);\n\n...\n\njsize len = (*env)->GetArrayLength(env, y_array);\n(*env)->GetByteArrayRegion(env, y_array, 0, len, (jbyte*)native_key->y);\n\n...\n\njsize len = (*env)->GetArrayLength(env, r_array);\n(*env)->GetByteArrayRegion(env, r_array, 0, len, (jbyte*)native_sig->r);\n\n...\n\njsize len = (*env)->GetArrayLength(env, k_array);\n(*env)->GetByteArrayRegion(env, k_array, 0, len, (jbyte*)native_key->K);",
      "fix": "memset(native_key, 0, sizeof(ECCrefPublicKey));\njsize len = (*env)->GetArrayLength(env, x_array);\nif (len > ECCref_MAX_LEN) len = ECCref_MAX_LEN;\n(*env)->GetByteArrayRegion(env, x_array, 0, len, (jbyte*)native_key->x);\n\n/* Apply the same clamp for y, r, s, and K fields. */"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_util.c",
      "line": "392-448",
      "severity": "critical",
      "title": "Freeing GetPrimitiveArrayCritical buffers corrupts JVM",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`key_buf`, `iv_buf`, and `enc_buf` are obtained via `GetPrimitiveArrayCritical` but are freed with `free()`, which is undefined behavior and can crash the JVM.",
      "code": "if (iv_buf == NULL) {\n    free(key_buf);\n    throw_sdf_exception(env, 0x0100001C);\n    return NULL;\n}\n...\nif (enc_buf == NULL) {\n    free(key_buf);\n    if (iv_buf) free(iv_buf);\n    throw_sdf_exception(env, 0x0100001C);\n    return NULL;\n}\n...\nfree(key_buf);\nif (iv_buf) free(iv_buf);\nfree(enc_buf);",
      "fix": "if (iv_buf == NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, key, key_buf, JNI_ABORT);\n    throw_sdf_exception(env, 0x0100001C);\n    return NULL;\n}\n...\nif (enc_buf == NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, key, key_buf, JNI_ABORT);\n    if (iv_buf) {\n        (*env)->ReleasePrimitiveArrayCritical(env, iv, iv_buf, JNI_ABORT);\n    }\n    throw_sdf_exception(env, 0x0100001C);\n    return NULL;\n}\n...\n(*env)->ReleasePrimitiveArrayCritical(env, key, key_buf, JNI_ABORT);\nif (iv_buf) {\n    (*env)->ReleasePrimitiveArrayCritical(env, iv, iv_buf, JNI_ABORT);\n}\n(*env)->ReleasePrimitiveArrayCritical(env, encData, enc_buf, JNI_ABORT);"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
      "line": "960-967",
      "severity": "critical",
      "title": "Double ReleasePrimitiveArrayCritical on aad_buf in AuthDec",
      "reviewers": "GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "`aad_buf` is released twice in the success cleanup path, which can corrupt JNI state or crash the JVM.",
      "code": "if (aad_buf != NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, aad, aad_buf, JNI_ABORT);\n}\nif (aad_buf != NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, aad, aad_buf, JNI_ABORT);\n}",
      "fix": "if (aad_buf != NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, aad, aad_buf, JNI_ABORT);\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
      "line": "1147-1149",
      "severity": "critical",
      "title": "Invalid free() of pinned Java array in AuthEncFinal error path",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "`output_buf` is obtained via `GetPrimitiveArrayCritical` but is freed with `free()` when `SDF_AuthEncFinal` fails.",
      "code": "if (ret != SDR_OK) {\n    if (output_buf != NULL) free(output_buf);\n    free(tag_buf);\n    throw_sdf_exception(env, ret);\n    return NULL;\n}",
      "fix": "if (ret != SDR_OK) {\n    if (output_buf != NULL) {\n        (*env)->ReleasePrimitiveArrayCritical(env, pucEncData, output_buf, JNI_ABORT);\n    }\n    free(tag_buf);\n    throw_sdf_exception(env, ret);\n    return NULL;\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_keygen.c",
      "line": "666-667",
      "severity": "high",
      "title": "Build break from undefined keyHandle identifier",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "The log statement uses `keyHandle`, but the variable is named `key_handle`, causing a compilation error.",
      "code": "SDF_LOG_EXIT(\"SDF_ImportKey\", ret);\nSDF_JNI_LOG(\"SDF_ImportKey: keyHandle=0x%lX\", (unsigned long)keyHandle);\nreturn (jlong)key_handle;",
      "fix": "SDF_LOG_EXIT(\"SDF_ImportKey\", ret);\nSDF_JNI_LOG(\"SDF_ImportKey: keyHandle=0x%lX\", (unsigned long)key_handle);\nreturn (jlong)key_handle;"
    },
    {
      "file": "sdf4j/src/main/native/include/dynamic_loader.h",
      "line": "93-99",
      "severity": "high",
      "title": "Duplicate typedef of SDF_ImportKey_FN",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`SDF_ImportKey_FN` is defined twice in the same scope, which can fail compilation on strict C compilers.",
      "code": "typedef LONG (*SDF_ImportKey_FN)(HANDLE hSessionHandle, BYTE *pucKey,\n                                 ULONG uiKeyLength, HANDLE *phKeyHandle);\ntypedef LONG (*SDF_DestroyKey_FN)(HANDLE hSessionHandle, HANDLE hKeyHandle);\n\ntypedef LONG (*SDF_ImportKey_FN)(HANDLE hSessionHandle, BYTE *pucKey,\n                                 ULONG uiKeyLength, HANDLE *phKeyHandle);",
      "fix": "typedef LONG (*SDF_ImportKey_FN)(HANDLE hSessionHandle, BYTE *pucKey,\n                                 ULONG uiKeyLength, HANDLE *phKeyHandle);\ntypedef LONG (*SDF_DestroyKey_FN)(HANDLE hSessionHandle, HANDLE hKeyHandle);\n\ntypedef LONG (*SDF_ExchangeDigitEnvelopeBaseOnECC_FN)(HANDLE hSessionHandle, ULONG uiKEKIndex,\n                                                      ULONG uiAlgID, ECCrefPublicKey *pucPublicKey,\n                                                      ECCCipher *pucEncDataIn, ECCCipher *pucEncDataOut);"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_symmetric.c",
      "line": "1233-1236",
      "severity": "high",
      "title": "Invalid free() of aad_buf after ReleasePrimitiveArrayCritical",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`aad_buf` is released and then freed when `tag_buf` allocation fails, which is invalid for pinned Java arrays.",
      "code": "if (aad_buf != NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, aad, aad_buf, JNI_ABORT);\n}\nif (aad_buf != NULL) free(aad_buf);",
      "fix": "if (aad_buf != NULL) {\n    (*env)->ReleasePrimitiveArrayCritical(env, aad, aad_buf, JNI_ABORT);\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "433-623",
      "severity": "medium",
      "title": "Key handles from several APIs are never registered for cleanup",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "Methods that return key handles are declared `native` and bypass `SessionResource.addKey`, so those handles are not tracked and will not be auto-destroyed when sessions close.",
      "code": "public native long SDF_ImportKeyWithISK_RSA(\n        long sessionHandle, int keyIndex, byte[] encryptedKey) throws SDFException;\n\npublic native long SDF_ImportKeyWithISK_ECC(\n        long sessionHandle, int keyIndex, ECCCipher cipher) throws SDFException;\n\npublic native long SDF_GenerateAgreementDataWithECC(\n        long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID, ECCPublicKey sponsorPublicKey,\n        ECCPublicKey sponsorTmpPublicKey) throws SDFException;\n\npublic native long SDF_GenerateKeyWithECC(\n        long sessionHandle, byte[] responseID,\n        ECCPublicKey responsePublicKey, ECCPublicKey responseTmpPublicKey,\n        long agreementHandle) throws SDFException;\n\npublic native long SDF_ImportKeyWithKEK(\n        long sessionHandle, int algID, int kekIndex, byte[] encryptedKey) throws SDFException;",
      "fix": "public long SDF_ImportKeyWithISK_RSA(long sessionHandle, int keyIndex, byte[] encryptedKey) throws SDFException {\n    long keyHandle = SDF_ImportKeyWithISK_RSA_Native(sessionHandle, keyIndex, encryptedKey);\n    if (keyHandle != 0) {\n        SessionResource sr = gSessResource.get(sessionHandle);\n        if (sr != null) sr.addKey(keyHandle);\n    }\n    return keyHandle;\n}\n\nprivate native long SDF_ImportKeyWithISK_RSA_Native(long sessionHandle, int keyIndex, byte[] encryptedKey)\n        throws SDFException;\n\n/* Apply the same wrapper pattern to all key-handle-returning methods. */"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "181-184",
      "severity": "medium",
      "title": "SDF_CloseDevice can throw NPE when gDevHandle is null",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`deviceHandle != gDevHandle` auto-unboxes `gDevHandle`. If `gDevHandle` is null, this throws `NullPointerException` instead of returning safely.",
      "code": "public void SDF_CloseDevice(long deviceHandle) throws SDFException {\n    // 验证 handle 是否匹配\n    if (deviceHandle != gDevHandle) {\n        return;\n    }",
      "fix": "public void SDF_CloseDevice(long deviceHandle) throws SDFException {\n    if (gDevHandle == null || deviceHandle != gDevHandle.longValue()) {\n        return;\n    }"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "216-221",
      "severity": "medium",
      "title": "SDF_OpenSession can NPE when device not opened",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`SessionResource` constructor uses `gDevResource`, which is null if the device is not opened or has been closed, causing an NPE.",
      "code": "public long SDF_OpenSession(long deviceHandle) throws SDFException {\n    // 创建新的 session\n    long handle = SDF_OpenSessionNative(deviceHandle);\n    // 创建 SessionResource 并注册到 gDevResource 和 gSessResource\n    SessionResource sessionResource = new SessionResource(handle);\n    gSessResource.put(handle, sessionResource);\n    return handle;\n}",
      "fix": "public long SDF_OpenSession(long deviceHandle) throws SDFException {\n    if (gDevResource == null || gDevHandle == null) {\n        throw new SDFException(0x0100001D); // SDR_INARGERR or appropriate code\n    }\n    long handle = SDF_OpenSessionNative(deviceHandle);\n    SessionResource sessionResource = new SessionResource(handle);\n    gSessResource.put(handle, sessionResource);\n    return handle;\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "68-71",
      "severity": "medium",
      "title": "finalize() can throw NPE when device already closed",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`finalize()` calls `SDF_CloseDevice(gDevHandle)` without checking for null, which auto-unboxes `gDevHandle` and can throw `NullPointerException`.",
      "code": "@Override\nprotected void finalize() throws Throwable {\n    try {\n        SDF_CloseDevice(gDevHandle);\n    } catch (Exception e) {\n        // 忽略异常\n    } finally {\n        super.finalize();\n    }\n}",
      "fix": "@Override\nprotected void finalize() throws Throwable {\n    try {\n        if (gDevHandle != null) {\n            SDF_CloseDevice(gDevHandle);\n        }\n    } finally {\n        super.finalize();\n    }\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "57-66",
      "severity": "medium",
      "title": "Shared device/session state is not thread-safe",
      "reviewers": "GEMINI, CLAUDE",
      "confidence": "evaluate",
      "problem": "`gSessResource` and session/key sets are plain `HashMap`/`HashSet` accessed across multiple methods without synchronization. `SDF_OpenDevice` also checks and sets cached handles without locking, so a single `SDF` instance used by multiple threads can race or corrupt tracking state.",
      "code": "private Long gDevHandle = null;\nprivate DeviceResource gDevResource = null;\nprivate java.util.Map<Long, SessionResource> gSessResource = new java.util.HashMap<>();\n\n...\n\npublic long SDF_OpenDevice() throws SDFException {\n    if (gDevHandle != null) {\n        return gDevHandle;\n    }\n    gDevHandle = SDF_OpenDeviceNative();\n    gDevResource = new DeviceResource();\n    return gDevHandle;\n}",
      "fix": "private final java.util.Map<Long, SessionResource> gSessResource =\n        new java.util.concurrent.ConcurrentHashMap<>();\nprivate final java.util.Set<Long> sessions =\n        java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap<>());\n\npublic synchronized long SDF_OpenDevice() throws SDFException { ... }\n\n/* Also synchronize close/open session and key tracking operations. */"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_asymmetric.c",
      "line": "344-351",
      "severity": "medium",
      "title": "Output buffer size for SDF_ExchangeDigitEnvelopeBaseOnECC may be insufficient",
      "reviewers": "GEMINI",
      "confidence": "evaluate",
      "problem": "Output ECCCipher is allocated using the input cipher length only. If the SDF implementation outputs a larger envelope, the native call can overflow the buffer.",
      "code": "ULONG out_len = in_cipher->L;\nECCCipher *out_cipher = (ECCCipher*)calloc(1, sizeof(ECCCipher) + out_len);\nout_cipher->L = out_len;\nLONG ret = g_sdf_functions.SDF_ExchangeDigitEnvelopeBaseOnECC(\n    (HANDLE)sessionHandle, (ULONG)keyIndex, (ULONG)algID, &native_pub, in_cipher, out_cipher\n);",
      "fix": "/* Allocate per spec maximum or a documented expansion size. */\nULONG out_len = ECCref_MAX_CIPHER_LEN; /* or in_cipher->L + overhead */\nECCCipher *out_cipher = (ECCCipher*)calloc(1, sizeof(ECCCipher) + out_len);\nout_cipher->L = out_len; /* treat L as capacity if the API supports it */"
    },
    {
      "file": "sdf4j/src/main/native/src/dynamic_loader.c",
      "line": "134-139",
      "severity": "low",
      "title": "SDF_ImportKey resolved twice in dynamic loader",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`load_function` is called twice for `SDF_ImportKey`, which is redundant and potentially confusing.",
      "code": "load_function(handle, (void**)&g_sdf_functions.SDF_ImportKey,\n             \"SDF_ImportKey\", false);\nload_function(handle, (void**)&g_sdf_functions.SDF_DestroyKey,\n             \"SDF_DestroyKey\", false);\nload_function(handle, (void**)&g_sdf_functions.SDF_ImportKey,\n             \"SDF_ImportKey\", false);",
      "fix": "load_function(handle, (void**)&g_sdf_functions.SDF_ImportKey,\n             \"SDF_ImportKey\", false);\nload_function(handle, (void**)&g_sdf_functions.SDF_DestroyKey,\n             \"SDF_DestroyKey\", false);\n/* remove the duplicate SDF_ImportKey load */"
    },
    {
      "file": "examples/src/test/java/org/openhitls/sdf4j/examples/ResourceManagementTest.java",
      "line": "93-113",
      "severity": "low",
      "title": "\"Auto cleanup\" test manually closes device",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`testAutoCleanup` is labeled \"自动清理\" but explicitly closes the device, so it does not test finalizer-based cleanup.",
      "code": "/**\n * 自动清理\n */\n@Test\npublic void testAutoCleanup() throws SDFException {\n    ...\n    // 直接关闭会话，保证session也能被关闭\n    sdf2.SDF_CloseDevice(deviceHandle);\n}",
      "fix": "/**\n * 自动清理 - 依赖 finalize() 方法自动清理资源\n */\n/* Or keep the code and rename the comment to \"手动关闭\" */"
    }
  ]
}