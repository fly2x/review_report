{
  "context": {
    "owner": "openHiTLS",
    "repo": "sdf4j",
    "pr_id": "19",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 7,
    "critical": 0,
    "high": 4,
    "medium": 2,
    "low": 1
  },
  "issues": [
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_keygen.c",
      "line": "363-369",
      "severity": "high",
      "title": "HSM resource leak on KeyAgreementResult object creation failure",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "In `JNI_SDF_GenerateAgreementDataWithECC`, if `native_to_java_KeyAgreementResult` fails (returns NULL due to memory/JNI errors), the `agreement_handle` created by `SDF_GenerateAgreementDataWithECC` is never destroyed. This leaks handles directly on the hardware device. The agreement handle must be cleaned up using `SDF_DestroyKey` before throwing the exception, similar to how `key_handle` is cleaned up in `JNI_SDF_GenerateAgreementDataAndKeyWithECC` at line 519.",
      "code": "/* 创建 KeyAgreementResult 对象 */\njobject result = native_to_java_KeyAgreementResult (env, agreement_handle,\n                                             &sponsor_pub_key, &sponsor_tmp_pub_key);\nif (result == NULL) {\n    THROW_SDF_EXCEPTION(env, 0x0100001C, \"Failed to create KeyAgreementResult\");\n    return NULL;\n}",
      "fix": "/* 创建 KeyAgreementResult 对象 */\njobject result = native_to_java_KeyAgreementResult (env, agreement_handle,\n                                             &sponsor_pub_key, &sponsor_tmp_pub_key);\nif (result == NULL) {\n    if (g_sdf_functions.SDF_DestroyKey != NULL) {\n        (void)g_sdf_functions.SDF_DestroyKey((HANDLE)sessionHandle, (HANDLE)agreement_handle);\n    }\n    THROW_SDF_EXCEPTION(env, 0x0100001C, \"Failed to create KeyAgreementResult\");\n    return NULL;\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "507-508",
      "severity": "high",
      "title": "Missing Java wrapper for SDF_GenerateAgreementDataWithECC leads to untracked agreement handle",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "Unlike `SDF_GenerateKeyWithECC` and `SDF_GenerateAgreementDataAndKeyWithECC`, which are correctly wrapped to register their resulting handles with `SessionResource`, `SDF_GenerateAgreementDataWithECC` is declared as a `native` method without a wrapper. As a result, its returned `agreementHandle` is not tracked and will not be automatically destroyed when the session is closed, potentially leading to a resource leak on the HSM.",
      "code": "public native KeyAgreementResult SDF_GenerateAgreementDataWithECC(long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID) throws SDFException;",
      "fix": "public KeyAgreementResult SDF_GenerateAgreementDataWithECC(long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID) throws SDFException {\n    KeyAgreementResult result = SDF_GenerateAgreementDataWithECC_Native(sessionHandle, keyIndex, keyBits, sponsorID);\n    SessionResource sessionResource = gSessResource.get(sessionHandle);\n    if (sessionResource != null) {\n        sessionResource.addKey(result.getAgreementHandle());\n    }\n    return result;\n}\n\nprivate native KeyAgreementResult SDF_GenerateAgreementDataWithECC_Native(long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID) throws SDFException;"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_register.c",
      "line": "45",
      "severity": "high",
      "title": "Incorrect native method name registration for SDF_GenerateAgreementDataWithECC",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "Due to the missing Java wrapper (the method is `native` instead of wrapped), the JNI method registration for `SDF_GenerateAgreementDataWithECC` does not follow the `_Native` suffix pattern used by other wrapped methods. If the Java wrapper is added as described in the previous issue, this registration must be updated to match the required `_Native` suffix.",
      "code": "{\"SDF_GenerateAgreementDataWithECC\", \"(JII[B)Lorg/openhitls/sdf4j/types/KeyAgreementResult;\", (void*)JNI_SDF_GenerateAgreementDataWithECC},",
      "fix": "{\"SDF_GenerateAgreementDataWithECC_Native\", \"(JII[B)Lorg/openhitls/sdf4j/types/KeyAgreementResult;\", (void*)JNI_SDF_GenerateAgreementDataWithECC},"
    },
    {
      "file": "sdf4j/src/main/native/src/sdf_jni_keygen.c",
      "line": "518-521",
      "severity": "high",
      "title": "Error-path cleanup can dereference a null function pointer",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "On `KeyAgreementResult` creation failure in `JNI_SDF_GenerateAgreementDataAndKeyWithECC`, cleanup unconditionally calls `g_sdf_functions.SDF_DestroyKey` without checking if the function pointer is NULL. If the SDF library failed to load properly or doesn't export this symbol, this becomes a null pointer crash while handling an error.",
      "code": "if (result == NULL) {\n    g_sdf_functions.SDF_DestroyKey((HANDLE)sessionHandle, (HANDLE)key_handle);\n    THROW_SDF_EXCEPTION(env, 0x0100001C, \"Failed to create KeyAgreementResult\");\n    return NULL;\n}",
      "fix": "if (result == NULL) {\n    if (key_handle != 0 && g_sdf_functions.SDF_DestroyKey != NULL) {\n        (void)g_sdf_functions.SDF_DestroyKey((HANDLE)sessionHandle, (HANDLE)key_handle);\n    }\n    THROW_SDF_EXCEPTION(env, 0x0100001C, \"Failed to create KeyAgreementResult\");\n    return NULL;\n}"
    },
    {
      "file": "sdf4j/src/main/native/src/type_conversion.c",
      "line": "643-646",
      "severity": "medium",
      "title": "JNI local reference leak in native_to_java_KeyAgreementResult",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "When `java_tmp_pub_key` conversion fails (returns NULL), the function returns NULL without deleting the local reference to `java_pub_key`. While local references are automatically freed when the native method returns, this is bad practice and could cause issues in long-running native methods with many conversions or if this function is refactored.",
      "code": "jobject java_tmp_pub_key = native_to_java_ECCPublicKey(env, tmp_pub_key);\nif (java_tmp_pub_key == NULL) {\n    return NULL;  // LEAK: java_pub_key not deleted\n}",
      "fix": "jobject java_tmp_pub_key = native_to_java_ECCPublicKey(env, tmp_pub_key);\nif (java_tmp_pub_key == NULL) {\n    (*env)->DeleteLocalRef(env, java_pub_key);\n    return NULL;\n}"
    },
    {
      "file": "sdf4j/src/main/java/org/openhitls/sdf4j/SDF.java",
      "line": "507-568",
      "severity": "medium",
      "title": "Public ECC key-agreement APIs changed incompatibly without migration path",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The PR replaces existing public method signatures for `SDF_GenerateAgreementDataWithECC` (6.3.12) and `SDF_GenerateAgreementDataAndKeyWithECC` (6.3.14). The old signatures took output parameters for public keys and returned a `long` handle. The new signatures return `KeyAgreementResult` objects. Existing downstream code compiled against the old API will break at both source and binary level.",
      "code": "// Old API (before this PR):\npublic native long SDF_GenerateAgreementDataWithECC(\n        long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID, ECCPublicKey sponsorPublicKey,\n        ECCPublicKey sponsorTmpPublicKey) throws SDFException;\n\n// New API (this PR):\npublic native KeyAgreementResult SDF_GenerateAgreementDataWithECC(long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID) throws SDFException;",
      "fix": "@Deprecated\npublic long SDF_GenerateAgreementDataWithECC(\n        long sessionHandle, int keyIndex, int keyBits,\n        byte[] sponsorID, ECCPublicKey sponsorPublicKey,\n        ECCPublicKey sponsorTmpPublicKey) throws SDFException {\n    KeyAgreementResult result = SDF_GenerateAgreementDataWithECC(sessionHandle, keyIndex, keyBits, sponsorID);\n    if (sponsorPublicKey != null) {\n        copyEccPublicKey(result.getPublicKey(), sponsorPublicKey);\n    }\n    if (sponsorTmpPublicKey != null) {\n        copyEccPublicKey(result.getTmpPublicKey(), sponsorTmpPublicKey);\n    }\n    return result.getAgreementHandle();\n}\n\n@Deprecated\npublic long SDF_GenerateAgreementDataAndKeyWithECC(\n        long sessionHandle, int keyIndex, int keyBits,\n        byte[] responseID, byte[] sponsorID,\n        ECCPublicKey sponsorPublicKey, ECCPublicKey sponsorTmpPublicKey,\n        ECCPublicKey responsePublicKey, ECCPublicKey responseTmpPublicKey) throws SDFException {\n    KeyAgreementResult result = SDF_GenerateAgreementDataAndKeyWithECC(\n            sessionHandle, keyIndex, keyBits, responseID, sponsorID, sponsorPublicKey, sponsorTmpPublicKey);\n    if (responsePublicKey != null) {\n        copyEccPublicKey(result.getPublicKey(), responsePublicKey);\n    }\n    if (responseTmpPublicKey != null) {\n        copyEccPublicKey(result.getTmpPublicKey(), responseTmpPublicKey);\n    }\n    return result.getAgreementHandle();\n}\n\nprivate static void copyEccPublicKey(ECCPublicKey src, ECCPublicKey dst) {\n    if (src != null && dst != null) {\n        dst.setBits(src.getBits());\n        dst.setX(src.getX());\n        dst.setY(src.getY());\n    }\n}"
    },
    {
      "file": "sdf4j/src/test/java/org/openhitls/sdf4j/KeyManagementTest.java",
      "line": "707-710",
      "severity": "low",
      "title": "Misleading use of Assume.assumeTrue with contradictory message",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The code uses `Assume.assumeTrue(\"获取私钥权限不需要或不支持，继续测试...\", false)` which always causes the test to be skipped. The message says \"continue testing\" but passing `false` as the condition means \"don't continue - skip the test\". This creates confusion for anyone reading the test code. The intent is clear (skip when not supported), but the message is misleading.",
      "code": "} catch (SDFException e) {\n    if (e.getErrorCode() == ErrorCode.SDR_NOTSUPPORT) {\n        System.out.println(\"[跳过] 获取私钥权限不支持\");\n        Assume.assumeTrue(\"获取私钥权限不需要或不支持，继续测试...\", false);",
      "fix": "} catch (SDFException e) {\n    if (e.getErrorCode() == ErrorCode.SDR_NOTSUPPORT) {\n        System.out.println(\"[跳过] 获取私钥权限不支持\");\n        Assume.assumeTrue(\"获取私钥权限不支持，跳过测试\", false);"
    }
  ]
}