<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/openhitls#999</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/openhitls - PR #999</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">7</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">0</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">2</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">3</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">2</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Inline function without external symbol causes linker errors</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_ntt.c:81-88</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">ÁΩÆ‰ø°Â∫¶: ÂèØ‰ø°</span>
                </div>
                <pre>// In ml_dsa_local.h (line 101)
int32_t MLDSA_PlantardMulReduce(int64_t a);

// In ml_dsa_ntt.c (lines 81-88)
inline int32_t MLDSA_PlantardMulReduce(int64_t a)
{
    int64_t tmp = a;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    tmp = (tmp + (1 &lt;&lt; MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    return (int32_t)tmp;
}</pre>
                <div class="problem"><strong>Issue:</strong> The function `MLDSA_PlantardMulReduce` is defined as `inline` in `ml_dsa_ntt.c` but declared as a non-inline prototype in `ml_dsa_local.h` (line 101) and used in `ml_dsa_core.c` (lines 399, 413). Under C99/C11 inline semantics, an `inline` definition without `extern` or `static` does not emit an external symbol, causing "undefined reference" linker errors when other translation units try to call this function. The function needs to be either `static inline` in the header, or a regular non-inline function.</div>
                <div class="fix-label">Fix:</div><pre>// Option 1: Move to header as static inline (recommended for small function)
// In ml_dsa_local.h
static inline int32_t MLDSA_PlantardMulReduce(int64_t a)
{
    int64_t tmp = a;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    tmp = (tmp + (1 &lt;&lt; MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    return (int32_t)tmp;
}

// Then remove the definition from ml_dsa_ntt.c

// Option 2: Remove inline keyword from the definition
// In ml_dsa_ntt.c
int32_t MLDSA_PlantardMulReduce(int64_t a)
{
    int64_t tmp = a;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    tmp = (tmp + (1 &lt;&lt; MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;
    return (int32_t)tmp;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Right shift of negative signed integer is implementation-defined</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_ntt.c:81-88</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge trusted">ÁΩÆ‰ø°Â∫¶: ÂèØ‰ø°</span>
                </div>
                <pre>inline int32_t MLDSA_PlantardMulReduce(int64_t a)
{
    int64_t tmp = a;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;  // Implementation-defined if tmp is negative
    tmp = (tmp + (1 &lt;&lt; MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;
    tmp &gt;&gt;= MLDSA_PLANTARD_L;  // Implementation-defined if tmp is negative
    return (int32_t)tmp;
}</pre>
                <div class="problem"><strong>Issue:</strong> The `MLDSA_PlantardMulReduce` function uses right shift (`>>=`) on a signed `int64_t` value. In C, right shift of negative signed integers is implementation-defined behavior - the result depends on whether the compiler uses arithmetic or logical shift. This cryptographic code relies on arithmetic right shift behavior, which is not guaranteed by the C standard.</div>
                <div class="fix-label">Fix:</div><pre>static inline int32_t MLDSA_PlantardMulReduce(int64_t a)
{
    int64_t tmp = a;
    // Use portable division for negative values to ensure arithmetic shift behavior
    tmp = (tmp &gt;= 0) ? (tmp &gt;&gt; MLDSA_PLANTARD_L) : 
          ((tmp - ((1LL &lt;&lt; MLDSA_PLANTARD_L) - 1)) &gt;&gt; MLDSA_PLANTARD_L);
    tmp = (tmp + (1 &lt;&lt; MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;
    tmp = (tmp &gt;= 0) ? (tmp &gt;&gt; MLDSA_PLANTARD_L) : 
          ((tmp - ((1LL &lt;&lt; MLDSA_PLANTARD_L) - 1)) &gt;&gt; MLDSA_PLANTARD_L);
    return (int32_t)tmp;
}</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Arithmetic right shift for mask computation is implementation-defined</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_core.c:204-217</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge trusted">ÁΩÆ‰ø°Â∫¶: ÂèØ‰ø°</span>
                </div>
                <pre>const int32_t m0 = (MLDSA_Q - 1 - t0) &gt;&gt; 31;
const int32_t m1 = (MLDSA_Q - 1 - t1) &gt;&gt; 31;
const int32_t m2 = (MLDSA_Q - 1 - t2) &gt;&gt; 31;
const int32_t m3 = (MLDSA_Q - 1 - t3) &gt;&gt; 31;</pre>
                <div class="problem"><strong>Issue:</strong> The mask computation `(MLDSA_Q - 1 - t0) >> 31` relies on arithmetic right shift to produce 0 for non-negative values and -1 for negative values. While this works on most platforms (x86, ARM), the C standard only guarantees this behavior for arithmetic right shift, not logical shift. This could fail on platforms using logical right shift for signed integers.</div>
                <div class="fix-label">Fix:</div><pre>// Portable alternative using comparison
const int32_t m0 = -((MLDSA_Q - 1 - t0) &lt; 0);
const int32_t m1 = -((MLDSA_Q - 1 - t1) &lt; 0);
const int32_t m2 = -((MLDSA_Q - 1 - t2) &lt; 0);
const int32_t m3 = -((MLDSA_Q - 1 - t3) &lt; 0);</pre>
            </div>
<div class="issue">
                <div class="issue-title">Mask computation in RejBoundedPolyEta2 has portability issues</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_core.c:300</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge trusted">ÁΩÆ‰ø°Â∫¶: ÂèØ‰ø°</span>
                </div>
                <pre>int32_t mask = (0xE - z0) &gt;&gt; 31; // 0 or -1
z0 = z0 - ((205 * z0) &gt;&gt; 10) * 5; // 205 == 2^10 / 5
a[i] = (2 - z0) &amp; ~mask; // 2 ‚àí (b mod 5)</pre>
                <div class="problem"><strong>Issue:</strong> The mask `(0xE - z0) >> 31` is meant to be 0 when `z0 < 14` and -1 when `z0 >= 14`. However, this relies on arithmetic right shift. When `z0 = 14`, `0xE - 14 = 0`, and `0 >> 31 = 0`. When `z0 = 15`, `0xE - 15 = -1`, and `-1 >> 31` produces -1 only with arithmetic shift. The code also has a comment saying `b < 15`, suggesting the threshold should be 15, not 14.</div>
                <div class="fix-label">Fix:</div><pre>// Use explicit comparison for portability
// mask = -1 if z0 &lt; 0x0F (15), else 0 (based on comment "b &lt; 15")
int32_t mask = -((uint32_t)z0 &lt; 0x0F); // Portable: produces -1 if true, 0 if false
z0 = z0 - ((205 * z0) &gt;&gt; 10) * 5; // 205 == 2^10 / 5
a[i] = (2 - z0) &amp; ~mask; // 2 ‚àí (b mod 5)</pre>
            </div>
<div class="issue">
                <div class="issue-title">Mask computation in RejBoundedPolyEta4 has portability issues</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_core.c:344</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge trusted">ÁΩÆ‰ø°Â∫¶: ÂèØ‰ø°</span>
                </div>
                <pre>int32_t mask = (0x8 - z0) &gt;&gt; 31;
a[i] = (4 - z0) &amp; ~mask; // if ùúÇ = 4 and b &lt; 9 then a[i] = 4 ‚àí b</pre>
                <div class="problem"><strong>Issue:</strong> Similar to RejBoundedPolyEta2, the mask `(0x8 - z0) >> 31` relies on arithmetic right shift behavior. The comment says `if ùúÇ = 4 and b < 9`, indicating the check should be for `z0 < 9`, but using `(0x8 - z0) >> 31` only works correctly when `z0 > 8` with arithmetic shift.</div>
                <div class="fix-label">Fix:</div><pre>int32_t mask = -((uint32_t)z0 &lt; 0x9); // Portable: mask = -1 if z0 &lt; 9, else 0
a[i] = (4 - z0) &amp; ~mask; // if ùúÇ = 4 and b &lt; 9 then a[i] = 4 ‚àí b</pre>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Buffer size calculation assumes SHAKE128_BLOCKSIZE is divisible by 4</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_core.c:186-188</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">ÁΩÆ‰ø°Â∫¶: ËæÉÂèØ‰ø°</span>
                </div>
                <pre>unsigned int outlen = CRYPT_SHAKE128_BLOCKSIZE;
const uint32_t buflen = CRYPT_SHAKE128_BLOCKSIZE / 4;
uint32_t buf[CRYPT_SHAKE128_BLOCKSIZE / 4];</pre>
                <div class="problem"><strong>Issue:</strong> The buffer `buf` is declared as `uint32_t buf[CRYPT_SHAKE128_BLOCKSIZE / 4]` and `hashMethod->squeeze` is called with `outlen = CRYPT_SHAKE128_BLOCKSIZE`. If `CRYPT_SHAKE128_BLOCKSIZE` is not divisible by 4, integer division truncates the buffer size but the full `outlen` is still written, causing a buffer overflow. While SHAKE128's rate (168) is divisible by 4, this assumption is brittle.</div>
                <div class="fix-label">Fix:</div><pre>unsigned int outlen = CRYPT_SHAKE128_BLOCKSIZE;
const uint32_t buflen = (CRYPT_SHAKE128_BLOCKSIZE + 3) / 4; 
uint32_t buf[(CRYPT_SHAKE128_BLOCKSIZE + 3) / 4];</pre>
            </div>
<div class="issue">
                <div class="issue-title">Missing validation of Plantard constants</div>
                <div class="issue-location">crypto/mldsa/src/ml_dsa_local.h:48-52</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">ÁΩÆ‰ø°Â∫¶: ËæÉÂèØ‰ø°</span>
                </div>
                <pre>#define MLDSA_PLANTARD_L 32
#define MLDSA_PLANTARD_ALPHA 3
#define MLDSA_PLANTARD_INV 1732267787797143553 // inverse_mod(q, 1 &lt;&lt; 64)</pre>
                <div class="problem"><strong>Issue:</strong> The Plantard constants are defined without any compile-time verification that they are correct. For cryptographic code, a wrong constant could cause subtle security issues. A static assertion would help catch errors at compile time.</div>
                <div class="fix-label">Fix:</div><pre>#define MLDSA_PLANTARD_L 32
#define MLDSA_PLANTARD_ALPHA 3
// Verify: MLDSA_PLANTARD_INV * MLDSA_Q ‚â° 1 (mod 2^64)
// 1732267787797143553 * 8380417 = 14522543385665802721 ‚â° 1 (mod 2^64)
#define MLDSA_PLANTARD_INV 1732267787797143553

// Compile-time verification (using static_assert in C11)
_Static_assert(((MLDSA_PLANTARD_INV * (int64_t)MLDSA_Q) &amp; 0xFFFFFFFFFFFFFFFFULL) == 1, 
               "MLDSA_PLANTARD_INV is incorrect");</pre>
            </div>
</div>
</div></body></html>