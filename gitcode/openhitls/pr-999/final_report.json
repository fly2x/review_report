{
  "context": {
    "owner": "openHiTLS",
    "repo": "openhitls",
    "pr_id": "999",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 7,
    "critical": 0,
    "high": 2,
    "medium": 3,
    "low": 2
  },
  "issues": [
    {
      "file": "crypto/mldsa/src/ml_dsa_ntt.c",
      "line": "81-88",
      "severity": "high",
      "title": "Inline function without external symbol causes linker errors",
      "reviewers": "CLAUDE, GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "The function `MLDSA_PlantardMulReduce` is defined as `inline` in `ml_dsa_ntt.c` but declared as a non-inline prototype in `ml_dsa_local.h` (line 101) and used in `ml_dsa_core.c` (lines 399, 413). Under C99/C11 inline semantics, an `inline` definition without `extern` or `static` does not emit an external symbol, causing \"undefined reference\" linker errors when other translation units try to call this function. The function needs to be either `static inline` in the header, or a regular non-inline function.",
      "code": "// In ml_dsa_local.h (line 101)\nint32_t MLDSA_PlantardMulReduce(int64_t a);\n\n// In ml_dsa_ntt.c (lines 81-88)\ninline int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}",
      "fix": "// Option 1: Move to header as static inline (recommended for small function)\n// In ml_dsa_local.h\nstatic inline int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}\n\n// Then remove the definition from ml_dsa_ntt.c\n\n// Option 2: Remove inline keyword from the definition\n// In ml_dsa_ntt.c\nint32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_ntt.c",
      "line": "81-88",
      "severity": "high",
      "title": "Right shift of negative signed integer is implementation-defined",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The `MLDSA_PlantardMulReduce` function uses right shift (`>>=`) on a signed `int64_t` value. In C, right shift of negative signed integers is implementation-defined behavior - the result depends on whether the compiler uses arithmetic or logical shift. This cryptographic code relies on arithmetic right shift behavior, which is not guaranteed by the C standard.",
      "code": "inline int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;  // Implementation-defined if tmp is negative\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;  // Implementation-defined if tmp is negative\n    return (int32_t)tmp;\n}",
      "fix": "static inline int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    // Use portable division for negative values to ensure arithmetic shift behavior\n    tmp = (tmp >= 0) ? (tmp >> MLDSA_PLANTARD_L) : \n          ((tmp - ((1LL << MLDSA_PLANTARD_L) - 1)) >> MLDSA_PLANTARD_L);\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp = (tmp >= 0) ? (tmp >> MLDSA_PLANTARD_L) : \n          ((tmp - ((1LL << MLDSA_PLANTARD_L) - 1)) >> MLDSA_PLANTARD_L);\n    return (int32_t)tmp;\n}"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_core.c",
      "line": "204-217",
      "severity": "medium",
      "title": "Arithmetic right shift for mask computation is implementation-defined",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The mask computation `(MLDSA_Q - 1 - t0) >> 31` relies on arithmetic right shift to produce 0 for non-negative values and -1 for negative values. While this works on most platforms (x86, ARM), the C standard only guarantees this behavior for arithmetic right shift, not logical shift. This could fail on platforms using logical right shift for signed integers.",
      "code": "const int32_t m0 = (MLDSA_Q - 1 - t0) >> 31;\nconst int32_t m1 = (MLDSA_Q - 1 - t1) >> 31;\nconst int32_t m2 = (MLDSA_Q - 1 - t2) >> 31;\nconst int32_t m3 = (MLDSA_Q - 1 - t3) >> 31;",
      "fix": "// Portable alternative using comparison\nconst int32_t m0 = -((MLDSA_Q - 1 - t0) < 0);\nconst int32_t m1 = -((MLDSA_Q - 1 - t1) < 0);\nconst int32_t m2 = -((MLDSA_Q - 1 - t2) < 0);\nconst int32_t m3 = -((MLDSA_Q - 1 - t3) < 0);"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_core.c",
      "line": "300",
      "severity": "medium",
      "title": "Mask computation in RejBoundedPolyEta2 has portability issues",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The mask `(0xE - z0) >> 31` is meant to be 0 when `z0 < 14` and -1 when `z0 >= 14`. However, this relies on arithmetic right shift. When `z0 = 14`, `0xE - 14 = 0`, and `0 >> 31 = 0`. When `z0 = 15`, `0xE - 15 = -1`, and `-1 >> 31` produces -1 only with arithmetic shift. The code also has a comment saying `b < 15`, suggesting the threshold should be 15, not 14.",
      "code": "int32_t mask = (0xE - z0) >> 31; // 0 or -1\nz0 = z0 - ((205 * z0) >> 10) * 5; // 205 == 2^10 / 5\na[i] = (2 - z0) & ~mask; // 2 ‚àí (b mod 5)",
      "fix": "// Use explicit comparison for portability\n// mask = -1 if z0 < 0x0F (15), else 0 (based on comment \"b < 15\")\nint32_t mask = -((uint32_t)z0 < 0x0F); // Portable: produces -1 if true, 0 if false\nz0 = z0 - ((205 * z0) >> 10) * 5; // 205 == 2^10 / 5\na[i] = (2 - z0) & ~mask; // 2 ‚àí (b mod 5)"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_core.c",
      "line": "344",
      "severity": "medium",
      "title": "Mask computation in RejBoundedPolyEta4 has portability issues",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "Similar to RejBoundedPolyEta2, the mask `(0x8 - z0) >> 31` relies on arithmetic right shift behavior. The comment says `if ùúÇ = 4 and b < 9`, indicating the check should be for `z0 < 9`, but using `(0x8 - z0) >> 31` only works correctly when `z0 > 8` with arithmetic shift.",
      "code": "int32_t mask = (0x8 - z0) >> 31;\na[i] = (4 - z0) & ~mask; // if ùúÇ = 4 and b < 9 then a[i] = 4 ‚àí b",
      "fix": "int32_t mask = -((uint32_t)z0 < 0x9); // Portable: mask = -1 if z0 < 9, else 0\na[i] = (4 - z0) & ~mask; // if ùúÇ = 4 and b < 9 then a[i] = 4 ‚àí b"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_core.c",
      "line": "186-188",
      "severity": "low",
      "title": "Buffer size calculation assumes SHAKE128_BLOCKSIZE is divisible by 4",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "The buffer `buf` is declared as `uint32_t buf[CRYPT_SHAKE128_BLOCKSIZE / 4]` and `hashMethod->squeeze` is called with `outlen = CRYPT_SHAKE128_BLOCKSIZE`. If `CRYPT_SHAKE128_BLOCKSIZE` is not divisible by 4, integer division truncates the buffer size but the full `outlen` is still written, causing a buffer overflow. While SHAKE128's rate (168) is divisible by 4, this assumption is brittle.",
      "code": "unsigned int outlen = CRYPT_SHAKE128_BLOCKSIZE;\nconst uint32_t buflen = CRYPT_SHAKE128_BLOCKSIZE / 4;\nuint32_t buf[CRYPT_SHAKE128_BLOCKSIZE / 4];",
      "fix": "unsigned int outlen = CRYPT_SHAKE128_BLOCKSIZE;\nconst uint32_t buflen = (CRYPT_SHAKE128_BLOCKSIZE + 3) / 4; \nuint32_t buf[(CRYPT_SHAKE128_BLOCKSIZE + 3) / 4];"
    },
    {
      "file": "crypto/mldsa/src/ml_dsa_local.h",
      "line": "48-52",
      "severity": "low",
      "title": "Missing validation of Plantard constants",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The Plantard constants are defined without any compile-time verification that they are correct. For cryptographic code, a wrong constant could cause subtle security issues. A static assertion would help catch errors at compile time.",
      "code": "#define MLDSA_PLANTARD_L 32\n#define MLDSA_PLANTARD_ALPHA 3\n#define MLDSA_PLANTARD_INV 1732267787797143553 // inverse_mod(q, 1 << 64)",
      "fix": "#define MLDSA_PLANTARD_L 32\n#define MLDSA_PLANTARD_ALPHA 3\n// Verify: MLDSA_PLANTARD_INV * MLDSA_Q ‚â° 1 (mod 2^64)\n// 1732267787797143553 * 8380417 = 14522543385665802721 ‚â° 1 (mod 2^64)\n#define MLDSA_PLANTARD_INV 1732267787797143553\n\n// Compile-time verification (using static_assert in C11)\n_Static_assert(((MLDSA_PLANTARD_INV * (int64_t)MLDSA_Q) & 0xFFFFFFFFFFFFFFFFULL) == 1, \n               \"MLDSA_PLANTARD_INV is incorrect\");"
    }
  ]
}