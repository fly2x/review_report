[
  {
    "source": "codex",
    "file": "crypto/mldsa/src/ml_dsa_ntt.c",
    "line": "81-87",
    "severity": "high",
    "title": "Inline definition drops external symbol under C99/C11",
    "problem": "`MLDSA_PlantardMulReduce` is defined as `inline` in a .c file but referenced from other translation units (e.g., `ml_dsa_core.c`). Under C99/C11 inline semantics this does not emit an external definition, causing undefined references at link time unless compiling with GNU89 inline semantics or LTO.",
    "code": "inline int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}",
    "fix": "int32_t MLDSA_PlantardMulReduce(int64_t a)\n{\n    int64_t tmp = a;\n    tmp >>= MLDSA_PLANTARD_L;\n    tmp = (tmp + (1 << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}"
  },
  {
    "source": "codex",
    "file": "crypto/mldsa/src/ml_dsa_local.h",
    "line": "99-101",
    "severity": "medium",
    "title": "Signed API for Plantard reduce forces implementation-defined conversions",
    "problem": "The reducer takes `int64_t`, but all new call sites multiply in `uint64_t` (often overflowing INT64_MAX due to `MLDSA_PLANTARD_INV`) and pass the result. Converting a large `uint64_t` to `int64_t` is implementation-defined and can change results across platforms, risking incorrect reductions. Use `uint64_t` in the API/implementation to keep arithmetic defined.",
    "code": "int32_t MLDSA_PlantardMulReduce(int64_t a);",
    "fix": "/* ml_dsa_local.h */\nint32_t MLDSA_PlantardMulReduce(uint64_t a);\n\n/* ml_dsa_ntt.c */\nint32_t MLDSA_PlantardMulReduce(uint64_t a)\n{\n    uint64_t tmp = a >> MLDSA_PLANTARD_L;\n    tmp = (tmp + (1ULL << MLDSA_PLANTARD_ALPHA)) * MLDSA_Q;\n    tmp >>= MLDSA_PLANTARD_L;\n    return (int32_t)tmp;\n}"
  }
]