{
  "context": {
    "owner": "openHiTLS",
    "repo": "openhitls",
    "pr_id": "874",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 11,
    "critical": 0,
    "high": 1,
    "medium": 5,
    "low": 5
  },
  "issues": [
    {
      "file": "crypto/composite/src/composite_encdec.c",
      "line": "292-308",
      "severity": "high",
      "title": "ECDSA public key buffer sized from curve bits, not encoded key length",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`CRYPT_CompositeGetEcdsaPubKey` queries `CRYPT_CTRL_GET_BITS` and converts bits to bytes, which yields the curve size (e.g., 32 for P-256) instead of the encoded public key length (e.g., 65 bytes for uncompressed). This under-allocates the buffer, causing `getPub` to fail or truncate, breaking composite ECDSA public key encoding.",
      "code": "uint32_t pubLen = 0;\nRETURN_RET_IF_ERR(ctx->tradMethod->ctrl(ctx->tradCtx, CRYPT_CTRL_GET_BITS, &pubLen, sizeof(pubLen)), ret);\nRETURN_RET_IF(pubLen == 0, CRYPT_EAL_ALG_NOT_SUPPORT);\npubLen = BITS_TO_BYTES(pubLen);\nuint8_t *pub = (uint8_t *)BSL_SAL_Malloc(pubLen);\n...\nret = ctx->tradMethod->getPub(ctx->tradCtx, &param);",
      "fix": "uint32_t pubLen = 0;\nRETURN_RET_IF_ERR(ctx->tradMethod->ctrl(ctx->tradCtx, CRYPT_CTRL_GET_PUBKEY_LEN, &pubLen, sizeof(pubLen)), ret);\nRETURN_RET_IF(pubLen == 0, CRYPT_EAL_ALG_NOT_SUPPORT);\nuint8_t *pub = (uint8_t *)BSL_SAL_Malloc(pubLen);\nRETURN_RET_IF(pub == NULL, CRYPT_MEM_ALLOC_FAIL);\nBSL_Param param[2] = {{CRYPT_PARAM_EC_PUBKEY, BSL_PARAM_TYPE_OCTETS, pub, pubLen, 0}, BSL_PARAM_END};\nret = ctx->tradMethod->getPub(ctx->tradCtx, &param);\nif (ret != CRYPT_SUCCESS) {\n    BSL_SAL_FREE(pub);\n    return ret;\n}\nencode->data = pub;\nencode->dataLen = param[0].useLen;"
    },
    {
      "file": "crypto/provider/src/default/crypt_default_keymgmt.c",
      "line": "17-22",
      "severity": "medium",
      "title": "Provider gating lost due to operator precedence in #if",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "`&& defined(HITLS_CRYPTO_PROVIDER)` only applies to the first group; `HITLS_CRYPTO_CLASSIC_MCELIECE` or `HITLS_CRYPTO_FRODOKEM` will include this file even when `HITLS_CRYPTO_PROVIDER` is not set, leading to unintended compilation and potential build failures.",
      "code": "#if (defined(HITLS_CRYPTO_DSA) || defined(HITLS_CRYPTO_ED25519) || defined(HITLS_CRYPTO_X25519) || \\\n    defined(HITLS_CRYPTO_RSA) || defined(HITLS_CRYPTO_DH) || defined(HITLS_CRYPTO_ECDSA) || \\\n    defined(HITLS_CRYPTO_ECDH) || defined(HITLS_CRYPTO_SM2) || defined(HITLS_CRYPTO_PAILLIER) || \\\n    defined(HITLS_CRYPTO_ELGAMAL) || defined(HITLS_CRYPTO_SLH_DSA) || defined(HITLS_CRYPTO_MLKEM) || \\\n    defined(HITLS_CRYPTO_MLDSA) || defined(HITLS_CRYPTO_COMPOSITE) || defined(HITLS_CRYPTO_HYBRIDKEM)) && \\\n    defined(HITLS_CRYPTO_PROVIDER) || defined(HITLS_CRYPTO_CLASSIC_MCELIECE) || defined(HITLS_CRYPTO_FRODOKEM)",
      "fix": "#if (defined(HITLS_CRYPTO_DSA) || defined(HITLS_CRYPTO_ED25519) || defined(HITLS_CRYPTO_X25519) || \\\n    defined(HITLS_CRYPTO_RSA) || defined(HITLS_CRYPTO_DH) || defined(HITLS_CRYPTO_ECDSA) || \\\n    defined(HITLS_CRYPTO_ECDH) || defined(HITLS_CRYPTO_SM2) || defined(HITLS_CRYPTO_PAILLIER) || \\\n    defined(HITLS_CRYPTO_ELGAMAL) || defined(HITLS_CRYPTO_SLH_DSA) || defined(HITLS_CRYPTO_MLKEM) || \\\n    defined(HITLS_CRYPTO_MLDSA) || defined(HITLS_CRYPTO_COMPOSITE) || defined(HITLS_CRYPTO_HYBRIDKEM) || \\\n    defined(HITLS_CRYPTO_CLASSIC_MCELIECE) || defined(HITLS_CRYPTO_FRODOKEM)) && \\\n    defined(HITLS_CRYPTO_PROVIDER)"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "249-252",
      "severity": "medium",
      "title": "CRYPT_CompositeSetAlgInfo overwrites contexts without freeing existing ones",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "When `CRYPT_CompositeSetAlgInfo` is called multiple times, it allocates new `pqcCtx`/`tradCtx` without freeing any existing contexts, leaking the previous allocations.",
      "code": "ctx->pqcMethod = pqcMethod;\nctx->tradMethod = tradMethod;\nctx->pqcCtx = pqcMethod->newCtx();\nRETURN_RET_IF((ctx->pqcCtx == NULL), CRYPT_MEM_ALLOC_FAIL);\nctx->tradCtx = tradMethod->newCtx();",
      "fix": "if (ctx->pqcCtx != NULL && ctx->pqcMethod != NULL && ctx->pqcMethod->freeCtx != NULL) {\n    ctx->pqcMethod->freeCtx(ctx->pqcCtx);\n}\nif (ctx->tradCtx != NULL && ctx->tradMethod != NULL && ctx->tradMethod->freeCtx != NULL) {\n    ctx->tradMethod->freeCtx(ctx->tradCtx);\n}\nctx->pqcCtx = NULL;\nctx->tradCtx = NULL;\n\nctx->pqcMethod = pqcMethod;\nctx->tradMethod = tradMethod;\nctx->pqcCtx = pqcMethod->newCtx();\nRETURN_RET_IF(ctx->pqcCtx == NULL, CRYPT_MEM_ALLOC_FAIL);\nctx->tradCtx = tradMethod->newCtx();"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "251-258",
      "severity": "medium",
      "title": "CRYPT_CompositeSetAlgInfo leaves ctx->info set on allocation failure",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "If `tradMethod->newCtx()` fails, the function returns `CRYPT_MEM_ALLOC_FAIL` after freeing only `pqcCtx`, but leaves `ctx->info`, `ctx->pqcMethod`, and `ctx->tradMethod` set. This leaves a partially initialized context that can later be misused (e.g., `CRYPT_COMPOSITE_SetPrvKey` will proceed with `info` set but `pqcCtx`/`tradCtx` NULL).",
      "code": "ctx->tradCtx = tradMethod->newCtx();\nif (ctx->tradCtx == NULL) {\n    pqcMethod->freeCtx(ctx->pqcCtx);\n    ctx->pqcCtx = NULL;\n    return CRYPT_MEM_ALLOC_FAIL;\n}",
      "fix": "ctx->tradCtx = tradMethod->newCtx();\nif (ctx->tradCtx == NULL) {\n    ret = CRYPT_MEM_ALLOC_FAIL;\n    goto ERR;\n}\n/* ... */\nERR:\nif (ctx->pqcCtx != NULL) { pqcMethod->freeCtx(ctx->pqcCtx); }\nif (ctx->tradCtx != NULL) { tradMethod->freeCtx(ctx->tradCtx); }\nctx->pqcCtx = NULL;\nctx->tradCtx = NULL;\nctx->info = NULL;\nctx->pqcMethod = NULL;\nctx->tradMethod = NULL;\nreturn ret;"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "162-176",
      "severity": "medium",
      "title": "DupCtx leaks duplicated sub-context when one dupCtx fails",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`CRYPT_COMPOSITE_DupCtx` calls both `dupCtx` functions before checking results. If one succeeds and the other fails, `goto ERR` calls `CRYPT_COMPOSITE_FreeCtx(newCtx)` while `newCtx->pqcMethod`/`tradMethod` are still NULL, so the successfully duplicated sub-context is not freed.",
      "code": "if (ctx->pqcMethod != NULL && ctx->tradMethod != NULL) {\n    newCtx->pqcCtx = ctx->pqcMethod->dupCtx(ctx->pqcCtx);\n    newCtx->tradCtx = ctx->tradMethod->dupCtx(ctx->tradCtx);\n    if (newCtx->pqcCtx == NULL || newCtx->tradCtx == NULL) {\n        BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);\n        goto ERR;\n    }\n}",
      "fix": "newCtx->pqcMethod = ctx->pqcMethod;\nnewCtx->tradMethod = ctx->tradMethod;\nif (newCtx->pqcMethod != NULL && newCtx->tradMethod != NULL) {\n    newCtx->pqcCtx = newCtx->pqcMethod->dupCtx(ctx->pqcCtx);\n    if (newCtx->pqcCtx == NULL) { BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL); goto ERR; }\n    newCtx->tradCtx = newCtx->tradMethod->dupCtx(ctx->tradCtx);\n    if (newCtx->tradCtx == NULL) { BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL); goto ERR; }\n}"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "432-456",
      "severity": "medium",
      "title": "SetPrvKey/SetPubKey accept oversized composite keys without validation",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "`CRYPT_COMPOSITE_SetPrvKey` and `CRYPT_COMPOSITE_SetPubKey` only check that input length is larger than the PQC portion, but do not cap the total length. Oversized buffers are accepted and passed to the traditional key setters with a length larger than expected, allowing malformed input and potential downstream failures.",
      "code": "RETURN_RET_IF(ctx->info == NULL, CRYPT_COMPOSITE_KEYINFO_NOT_SET);\nRETURN_RET_IF(prv->len <= ctx->info->pqcPrvkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);\nctx->prvKey = (uint8_t *)BSL_SAL_Malloc(prv->len);\n...\nRETURN_RET_IF(pub->len <= ctx->info->pqcPubkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);\nctx->pubKey = (uint8_t *)BSL_SAL_Malloc(pub->len);",
      "fix": "RETURN_RET_IF(prv->len <= ctx->info->pqcPrvkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);\nRETURN_RET_IF(prv->len > ctx->info->pqcPrvkeyLen + ctx->info->tradPrvkeyLen,\n              CRYPT_COMPOSITE_KEYLEN_ERROR);\n\nRETURN_RET_IF(pub->len <= ctx->info->pqcPubkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);\nRETURN_RET_IF(pub->len > ctx->info->pqcPubkeyLen + ctx->info->tradPubkeyLen,\n              CRYPT_COMPOSITE_KEYLEN_ERROR);"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "386-388",
      "severity": "low",
      "title": "Potential overflow when summing component key lengths",
      "reviewers": "CLAUDE",
      "confidence": "evaluate",
      "problem": "`ctx->prvLen` and `ctx->pubLen` are computed by adding two lengths without overflow checks. If the inputs are malformed or unexpectedly large, the addition can wrap and lead to undersized allocations and memory corruption.",
      "code": "ctx->prvLen = pqcPrv.dataLen + tradPrv.dataLen;\nctx->pubLen = pqcPub.dataLen + tradPub.dataLen;\nRETURN_RET_IF_ERR(CRYPT_CompositeCreateKeyBuf(ctx), ret);",
      "fix": "if (pqcPrv.dataLen > UINT32_MAX - tradPrv.dataLen ||\n    pqcPub.dataLen > UINT32_MAX - tradPub.dataLen) {\n    ret = CRYPT_COMPOSITE_KEYLEN_ERROR;\n    goto ERR;\n}\nctx->prvLen = pqcPrv.dataLen + tradPrv.dataLen;\nctx->pubLen = pqcPub.dataLen + tradPub.dataLen;"
    },
    {
      "file": "crypto/composite/src/composite.c",
      "line": "390-393",
      "severity": "low",
      "title": "memcpy_s return values ignored when assembling composite key material",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The `memcpy_s` return values are discarded in `CRYPT_COMPOSITE_GenKey`. If any copy fails, the function continues with partially copied key material.",
      "code": "(void)memcpy_s(ctx->prvKey, ctx->prvLen, pqcPrv.data, pqcPrv.dataLen);\n(void)memcpy_s(ctx->prvKey + pqcPrv.dataLen, ctx->prvLen - pqcPrv.dataLen, tradPrv.data, tradPrv.dataLen);\n(void)memcpy_s(ctx->pubKey, ctx->pubLen, pqcPub.data, pqcPub.dataLen);\n(void)memcpy_s(ctx->pubKey + pqcPub.dataLen, ctx->pubLen - pqcPub.dataLen, tradPub.data, tradPub.dataLen);",
      "fix": "ret = memcpy_s(ctx->prvKey, ctx->prvLen, pqcPrv.data, pqcPrv.dataLen);\nGOTO_ERR_IF(ret != EOK, ret);\nret = memcpy_s(ctx->prvKey + pqcPrv.dataLen, ctx->prvLen - pqcPrv.dataLen, tradPrv.data, tradPrv.dataLen);\nGOTO_ERR_IF(ret != EOK, ret);\nret = memcpy_s(ctx->pubKey, ctx->pubLen, pqcPub.data, pqcPub.dataLen);\nGOTO_ERR_IF(ret != EOK, ret);\nret = memcpy_s(ctx->pubKey + pqcPub.dataLen, ctx->pubLen - pqcPub.dataLen, tradPub.data, tradPub.dataLen);\nGOTO_ERR_IF(ret != EOK, ret);"
    },
    {
      "file": "crypto/composite/src/composite_encdec.c",
      "line": "330-335",
      "severity": "low",
      "title": "Ed25519 public key length control call return ignored",
      "reviewers": "CLAUDE, CODEX",
      "confidence": "trusted",
      "problem": "`CRYPT_CompositeGetEd25519PubKey` ignores the return value from `ctrl`, so an error is silently masked and treated as “not supported,” complicating debugging and error handling.",
      "code": "uint32_t pubLen = 0;\nctx->tradMethod->ctrl(ctx->tradCtx, CRYPT_CTRL_GET_BITS, &pubLen, sizeof(pubLen));\nRETURN_RET_IF(pubLen == 0, CRYPT_EAL_ALG_NOT_SUPPORT);",
      "fix": "uint32_t pubLen = 0;\nRETURN_RET_IF_ERR(ctx->tradMethod->ctrl(ctx->tradCtx, CRYPT_CTRL_GET_BITS, &pubLen, sizeof(pubLen)), ret);\nRETURN_RET_IF(pubLen == 0, CRYPT_EAL_ALG_NOT_SUPPORT);"
    },
    {
      "file": "crypto/composite/src/composite_encdec.c",
      "line": "439-441",
      "severity": "low",
      "title": "Passing pointer-to-array instead of element pointer to setPrv/setPub",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "`&rsaParam` is a pointer to an array (`BSL_Param (*)[N]`), not a `BSL_Param *`. This is a type mismatch and may compile with warnings or lead to incorrect pointer arithmetic in the callee.",
      "code": "RETURN_RET_IF_ERR(ctx->tradMethod->setPrv(ctx->tradCtx, &rsaParam), ret);\nRETURN_RET_IF_ERR(ctx->tradMethod->setPub(ctx->tradCtx, &rsaParam), ret);\n...\nRETURN_RET_IF_ERR(ctx->tradMethod->setPub(ctx->tradCtx, &rsaParam), ret);",
      "fix": "RETURN_RET_IF_ERR(ctx->tradMethod->setPrv(ctx->tradCtx, rsaParam), ret);\nRETURN_RET_IF_ERR(ctx->tradMethod->setPub(ctx->tradCtx, rsaParam), ret);"
    },
    {
      "file": "crypto/codecskey/src/crypt_decoder_composite.c",
      "line": "82-85",
      "severity": "low",
      "title": "Missing error push on allocation failure in ParsePkcs8key",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "When `CRYPT_COMPOSITE_NewCtxEx` fails, the function returns `CRYPT_MEM_ALLOC_FAIL` without pushing the error code, unlike other error paths.",
      "code": "CRYPT_CompositeCtx *pctx = CRYPT_COMPOSITE_NewCtxEx(libCtx);\nif (pctx == NULL) {\n    return CRYPT_MEM_ALLOC_FAIL;\n}",
      "fix": "CRYPT_CompositeCtx *pctx = CRYPT_COMPOSITE_NewCtxEx(libCtx);\nif (pctx == NULL) {\n    BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);\n    return CRYPT_MEM_ALLOC_FAIL;\n}"
    }
  ]
}