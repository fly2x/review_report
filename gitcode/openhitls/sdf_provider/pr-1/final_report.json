{
  "context": {
    "owner": "openHiTLS",
    "repo": "sdf_provider",
    "pr_id": "1",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 13,
    "critical": 1,
    "high": 1,
    "medium": 9,
    "low": 2
  },
  "issues": [
    {
      "file": "src/log.c",
      "line": "20",
      "severity": "critical",
      "title": "Buffer overflow in LOG_ERROR due to unbounded vsprintf",
      "reviewers": "GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "The function uses `vsprintf` to write to a fixed-size buffer `log_buf` of 1024 bytes without bounds checking. If the formatted log message exceeds this length, it will cause a buffer overflow, potentially leading to crashes or arbitrary code execution.",
      "code": "va_start(args, lpFormat);\nvsprintf(log_buf, lpFormat, args);\nva_end(args);",
      "fix": "va_start(args, lpFormat);\nvsnprintf(log_buf, sizeof(log_buf), lpFormat, args);\nva_end(args);"
    },
    {
      "file": "src/sm2_keymgmt.c",
      "line": "459",
      "severity": "high",
      "title": "Insufficient buffer size for SM2 public key export",
      "reviewers": "GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "In `CRYPT_SM2_Export`, the `pubkey` buffer is allocated with 32 bytes, but an uncompressed SM2 public key (0x04 || X || Y) requires 65 bytes. `CRYPT_SM2_GetPubKeyEx` checks if the buffer is at least 65 bytes (line 199 checks `pub.len < SM2_POINT_COORDINATE_LEN` where SM2_POINT_COORDINATE_LEN is 65) and will fail, making public key export impossible.",
      "code": "uint8_t prvkey[32] = {0};\nuint8_t pubkey[32] = {0};",
      "fix": "uint8_t prvkey[32] = {0};\nuint8_t pubkey[65] = {0};"
    },
    {
      "file": "src/sm2_pkeycipher.c",
      "line": "154-169",
      "severity": "medium",
      "title": "Memory leak when SDF private key access operations fail",
      "reviewers": "GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "In `CRYPT_SM2_Decrypt`, `pucEncData` is allocated at line 133 but is not freed if `SDF_GetPrivateKeyAccessRight` fails at line 154-158 or if `SDF_ReleasePrivateKeyAccessRight` fails at line 166-169. Only the failure path for `SDF_InternalDecrypt_ECC` properly frees the memory.",
      "code": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}\nret = SDF_InternalDecrypt_ECC(ctx->hSessionHandle, ctx->KeyIndex, pucEncData, out, outlen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalDecrypt_ECC error, ret = %08x\", ret);\n    BSL_SAL_Free(pucEncData);\n    return CRYPT_SM2_DECRYPT_FAIL;\n}\nret = SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_ReleasePrivateKeyAccessRight error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}",
      "fix": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    BSL_SAL_Free(pucEncData);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}\nret = SDF_InternalDecrypt_ECC(ctx->hSessionHandle, ctx->KeyIndex, pucEncData, out, outlen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalDecrypt_ECC error, ret = %08x\", ret);\n    BSL_SAL_Free(pucEncData);\n    return CRYPT_SM2_DECRYPT_FAIL;\n}\nret = SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_ReleasePrivateKeyAccessRight error, ret = %08x\", ret);\n    BSL_SAL_Free(pucEncData);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}"
    },
    {
      "file": "src/rsa_sign.c",
      "line": "95-115",
      "severity": "medium",
      "title": "Private key access right not released on RSA sign error",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "If `SDF_InternalPrivateKeyOperation_RSA` fails at line 103-108, the function jumps to EXIT without releasing the private key access right acquired at line 96. This can leave the key in an acquired state, potentially locking it for other operations.",
      "code": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\nret = SDF_InternalPrivateKeyOperation_RSA(ctx->hSessionHandle, ctx->KeyIndex,\n        pad, padLen, sign, signLen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalPrivateKeyOperation_RSA error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}",
      "fix": "int accessGranted = 0;\nret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\naccessGranted = 1;\n\nret = SDF_InternalPrivateKeyOperation_RSA(ctx->hSessionHandle, ctx->KeyIndex,\n        pad, padLen, sign, signLen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalPrivateKeyOperation_RSA error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\n\nret = SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_ReleasePrivateKeyAccessRight error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n}\naccessGranted = 0;\nret = CRYPT_SUCCESS;\nEXIT:\nif (accessGranted) {\n    SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\n}"
    },
    {
      "file": "src/rsa_pkeycipher.c",
      "line": "134-154",
      "severity": "medium",
      "title": "Private key access right not released on RSA decrypt error",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "If `SDF_InternalPrivateKeyOperation_RSA` fails at line 142-147 or if `SDF_ReleasePrivateKeyAccessRight` fails at line 149-153, the function jumps to EXIT without properly handling the access right release. This can leak privileges or lock the key.",
      "code": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\nret = SDF_InternalPrivateKeyOperation_RSA(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)data, dataLen, pad, &padLen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalPrivateKeyOperation_RSA error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}",
      "fix": "int accessGranted = 0;\nret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\naccessGranted = 1;\n\nret = SDF_InternalPrivateKeyOperation_RSA(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)data, dataLen, pad, &padLen);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalPrivateKeyOperation_RSA error, ret = %08x\", ret);\n    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    goto EXIT;\n}\n\n/* Continue with release and cleanup before EXIT */\nEXIT:\nif (accessGranted) {\n    int32_t rret = SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\n    if (rret != SDR_OK && ret == CRYPT_SUCCESS) {\n        LOG_ERROR(\"SDF_ReleasePrivateKeyAccessRight error, ret = %08x\", rret);\n        ret = CRYPT_RSA_ERR_INVALID_PRVKEY;\n    }\n}"
    },
    {
      "file": "src/sm2_sign.c",
      "line": "88-99",
      "severity": "medium",
      "title": "Private key access right not released on SM2 sign error",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "If `SDF_InternalSign_ECC` fails at line 95-98, the function returns directly without releasing the private key access right acquired at line 89. This leaves the key in an acquired state.",
      "code": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}\nret = SDF_InternalSign_ECC(ctx->hSessionHandle, ctx->KeyIndex, tbs, tbsLen, &pucSignature);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalSign_ECC error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}",
      "fix": "ret = SDF_GetPrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex,\n        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_GetPrivateKeyAccessRight error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}\nret = SDF_InternalSign_ECC(ctx->hSessionHandle, ctx->KeyIndex, tbs, tbsLen, &pucSignature);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_InternalSign_ECC error, ret = %08x\", ret);\n    SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}\nret = SDF_ReleasePrivateKeyAccessRight(ctx->hSessionHandle, ctx->KeyIndex);\nif (ret != SDR_OK) {\n    LOG_ERROR(\"SDF_ReleasePrivateKeyAccessRight error, ret = %08x\", ret);\n    return CRYPT_SM2_INVALID_PRVKEY;\n}"
    },
    {
      "file": "src/crypt_util_mgf.c",
      "line": "41-43",
      "severity": "medium",
      "title": "Missing digest size zero check can cause infinite loop in MGF1",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "If `CRYPT_EAL_MdGetDigestSize` returns 0 for an unsupported or invalid hash algorithm, `hashLen` becomes 0. At line 61, `partLen` would be calculated as 0 when `outLen >= maskLen`, causing the loop at line 54 to never increment `outLen`, resulting in an infinite loop.",
      "code": "uint32_t hashLen = CRYPT_EAL_MdGetDigestSize(id);\nif (hashLen > HASH_MAX_MDSIZE) {\n    return CRYPT_RSA_ERR_INPUT_VALUE;\n}",
      "fix": "uint32_t hashLen = CRYPT_EAL_MdGetDigestSize(id);\nif (hashLen == 0 || hashLen > HASH_MAX_MDSIZE) {\n    return CRYPT_RSA_ERR_INPUT_VALUE;\n}"
    },
    {
      "file": "src/crypt_util_pkey.c",
      "line": "22-26",
      "severity": "medium",
      "title": "Uninitialized args pointer when process args parameter is absent",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "If `CRYPT_PARAM_PKEY_PROCESS_ARGS` isn't present in the params, `*args` is never initialized. The callback function may receive an uninitialized garbage pointer value, potentially causing undefined behavior.",
      "code": "BSL_Param *argsParam = BSL_PARAM_FindParam(params, CRYPT_PARAM_PKEY_PROCESS_ARGS);\nif (argsParam != NULL) {\n    GOTO_ERR_IF_EX(BSL_PARAM_GetPtrValue(argsParam, CRYPT_PARAM_PKEY_PROCESS_ARGS,\n        BSL_PARAM_TYPE_CTX_PTR, args, NULL), ret);\n}",
      "fix": "if (args != NULL) {\n    *args = NULL;\n}\nBSL_Param *argsParam = BSL_PARAM_FindParam(params, CRYPT_PARAM_PKEY_PROCESS_ARGS);\nif (argsParam != NULL) {\n    GOTO_ERR_IF_EX(BSL_PARAM_GetPtrValue(argsParam, CRYPT_PARAM_PKEY_PROCESS_ARGS,\n        BSL_PARAM_TYPE_CTX_PTR, args, NULL), ret);\n}"
    },
    {
      "file": "src/provider.h",
      "line": "10",
      "severity": "medium",
      "title": "Hardcoded default password for private key access",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "`DEFAULT_PASS` is hardcoded as \"12345678\". This password is used throughout the codebase to access private keys in the SDF device. Hardcoding such sensitive credentials is insecure and should be configurable or provided by the user/application at runtime.",
      "code": "#define DEFAULT_PASS \"12345678\"\n#define DEFAULT_PASS_LEN strlen(DEFAULT_PASS)",
      "fix": "/* Remove hardcoded DEFAULT_PASS and implement a mechanism to pass the key password from the application through the provider context or control APIs. */"
    },
    {
      "file": "src/rsa_keymgmt.c",
      "line": "584-595",
      "severity": "medium",
      "title": "RSA key check reports success without validation",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "The `CRYPT_RSA_Check` function returns `CRYPT_SUCCESS` for `CRYPT_PKEY_CHECK_KEYPAIR` and `CRYPT_PKEY_CHECK_PRVKEY` checks but does not actually validate anything (marked with `// TODO`). Invalid keys can be treated as valid, potentially causing security issues.",
      "code": "case CRYPT_PKEY_CHECK_KEYPAIR:\n    // TODO\n    return CRYPT_SUCCESS;\ncase CRYPT_PKEY_CHECK_PRVKEY:\n    // TODO\n    return CRYPT_SUCCESS;",
      "fix": "case CRYPT_PKEY_CHECK_KEYPAIR:\ncase CRYPT_PKEY_CHECK_PRVKEY:\n    return CRYPT_NOT_SUPPORT;"
    },
    {
      "file": "src/sm2_keymgmt.c",
      "line": "301-318",
      "severity": "medium",
      "title": "SM2 key check reports success without validation",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "The `CRYPT_SM2_Check` function returns `CRYPT_SUCCESS` for `CRYPT_PKEY_CHECK_KEYPAIR` and `CRYPT_PKEY_CHECK_PRVKEY` checks but does not validate the key material (marked with `// TODO`). This allows invalid keys to pass validation.",
      "code": "case CRYPT_PKEY_CHECK_KEYPAIR:\n    if (pkey1 == NULL || pkey2 == NULL) {\n        return CRYPT_NULL_INPUT;\n    }\n    // TODO\n    ret = CRYPT_SUCCESS;\n    break;\ncase CRYPT_PKEY_CHECK_PRVKEY:\n    if (pkey1 == NULL) {\n        return CRYPT_NULL_INPUT;\n    }\n    // TODO\n    ret = CRYPT_SUCCESS;\n    break;",
      "fix": "case CRYPT_PKEY_CHECK_KEYPAIR:\ncase CRYPT_PKEY_CHECK_PRVKEY:\n    return CRYPT_NOT_SUPPORT;"
    },
    {
      "file": "src/log.c",
      "line": "24",
      "severity": "low",
      "title": "Use of thread-unsafe localtime function",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "`localtime` returns a pointer to a static structure which is shared among all threads. In a multi-threaded environment, this can lead to race conditions where the timestamp in the log is corrupted.",
      "code": "time(&timep);\np = localtime(&timep);",
      "fix": "struct tm tm_res;\ntime(&timep);\np = localtime_r(&timep, &tm_res);"
    },
    {
      "file": "src/sm2_keymgmt.c",
      "line": "103",
      "severity": "low",
      "title": "KeyIndex masquerading as private key data",
      "reviewers": "GEMINI",
      "confidence": "evaluate",
      "problem": "If the provided private key data consists of zeros except for the last byte, it is interpreted as a `KeyIndex`. When exporting this key back, `CRYPT_SM2_GetPrvKeyEx` returns this \"fake\" private key. This design pattern can lead to security issues or interoperability failures if this key is imported into a system that expects real private key bytes.",
      "code": "if (memcmp(prv.data, zero, prv.len - 1) == 0) {\n    // data with leading 0x00, use it as KeyIndex\n    ctx->KeyIndex = prv.data[prv.len - 1];\n}",
      "fix": "/* Use a separate parameter type (e.g. CRYPT_PARAM_KEY_INDEX) to specify hardware key indices instead of overloading the private key buffer. */"
    }
  ]
}