<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/sdf_provider#1</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/sdf_provider - PR #1</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">13</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">1</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">1</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">9</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">2</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title critical">Critical</div>
<div class="issue">
                <div class="issue-title">Buffer overflow in LOG_ERROR due to unbounded vsprintf</div>
                <div class="issue-location">src/log.c:20</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>va_start(args, lpFormat);
vsprintf(log_buf, lpFormat, args);
va_end(args);</pre>
                <div class="problem"><strong>Issue:</strong> The function uses `vsprintf` to write to a fixed-size buffer `log_buf` of 1024 bytes without bounds checking. If the formatted log message exceeds this length, it will cause a buffer overflow, potentially leading to crashes or arbitrary code execution.</div>
                <div class="fix-label">Fix:</div><pre>va_start(args, lpFormat);
vsnprintf(log_buf, sizeof(log_buf), lpFormat, args);
va_end(args);</pre>
            </div>
</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Insufficient buffer size for SM2 public key export</div>
                <div class="issue-location">src/sm2_keymgmt.c:459</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>uint8_t prvkey[32] = {0};
uint8_t pubkey[32] = {0};</pre>
                <div class="problem"><strong>Issue:</strong> In `CRYPT_SM2_Export`, the `pubkey` buffer is allocated with 32 bytes, but an uncompressed SM2 public key (0x04 || X || Y) requires 65 bytes. `CRYPT_SM2_GetPubKeyEx` checks if the buffer is at least 65 bytes (line 199 checks `pub.len < SM2_POINT_COORDINATE_LEN` where SM2_POINT_COORDINATE_LEN is 65) and will fail, making public key export impossible.</div>
                <div class="fix-label">Fix:</div><pre>uint8_t prvkey[32] = {0};
uint8_t pubkey[65] = {0};</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Memory leak when SDF private key access operations fail</div>
                <div class="issue-location">src/sm2_pkeycipher.c:154-169</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}
ret = SDF_InternalDecrypt_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, pucEncData, out, outlen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalDecrypt_ECC error, ret = %08x", ret);
    BSL_SAL_Free(pucEncData);
    return CRYPT_SM2_DECRYPT_FAIL;
}
ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}</pre>
                <div class="problem"><strong>Issue:</strong> In `CRYPT_SM2_Decrypt`, `pucEncData` is allocated at line 133 but is not freed if `SDF_GetPrivateKeyAccessRight` fails at line 154-158 or if `SDF_ReleasePrivateKeyAccessRight` fails at line 166-169. Only the failure path for `SDF_InternalDecrypt_ECC` properly frees the memory.</div>
                <div class="fix-label">Fix:</div><pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    BSL_SAL_Free(pucEncData);
    return CRYPT_SM2_INVALID_PRVKEY;
}
ret = SDF_InternalDecrypt_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, pucEncData, out, outlen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalDecrypt_ECC error, ret = %08x", ret);
    BSL_SAL_Free(pucEncData);
    return CRYPT_SM2_DECRYPT_FAIL;
}
ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
    BSL_SAL_Free(pucEncData);
    return CRYPT_SM2_INVALID_PRVKEY;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Private key access right not released on RSA sign error</div>
                <div class="issue-location">src/rsa_sign.c:95-115</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}
ret = SDF_InternalPrivateKeyOperation_RSA(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        pad, padLen, sign, signLen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalPrivateKeyOperation_RSA error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}</pre>
                <div class="problem"><strong>Issue:</strong> If `SDF_InternalPrivateKeyOperation_RSA` fails at line 103-108, the function jumps to EXIT without releasing the private key access right acquired at line 96. This can leave the key in an acquired state, potentially locking it for other operations.</div>
                <div class="fix-label">Fix:</div><pre>int accessGranted = 0;
ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}
accessGranted = 1;

ret = SDF_InternalPrivateKeyOperation_RSA(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        pad, padLen, sign, signLen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalPrivateKeyOperation_RSA error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}

ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
}
accessGranted = 0;
ret = CRYPT_SUCCESS;
EXIT:
if (accessGranted) {
    SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Private key access right not released on RSA decrypt error</div>
                <div class="issue-location">src/rsa_pkeycipher.c:134-154</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}
ret = SDF_InternalPrivateKeyOperation_RSA(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)data, dataLen, pad, &amp;padLen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalPrivateKeyOperation_RSA error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}</pre>
                <div class="problem"><strong>Issue:</strong> If `SDF_InternalPrivateKeyOperation_RSA` fails at line 142-147 or if `SDF_ReleasePrivateKeyAccessRight` fails at line 149-153, the function jumps to EXIT without properly handling the access right release. This can leak privileges or lock the key.</div>
                <div class="fix-label">Fix:</div><pre>int accessGranted = 0;
ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}
accessGranted = 1;

ret = SDF_InternalPrivateKeyOperation_RSA(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)data, dataLen, pad, &amp;padLen);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalPrivateKeyOperation_RSA error, ret = %08x", ret);
    ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    goto EXIT;
}

/* Continue with release and cleanup before EXIT */
EXIT:
if (accessGranted) {
    int32_t rret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
    if (rret != SDR_OK &amp;&amp; ret == CRYPT_SUCCESS) {
        LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", rret);
        ret = CRYPT_RSA_ERR_INVALID_PRVKEY;
    }
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Private key access right not released on SM2 sign error</div>
                <div class="issue-location">src/sm2_sign.c:88-99</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}
ret = SDF_InternalSign_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, tbs, tbsLen, &amp;pucSignature);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalSign_ECC error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}</pre>
                <div class="problem"><strong>Issue:</strong> If `SDF_InternalSign_ECC` fails at line 95-98, the function returns directly without releasing the private key access right acquired at line 89. This leaves the key in an acquired state.</div>
                <div class="fix-label">Fix:</div><pre>ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
        (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}
ret = SDF_InternalSign_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, tbs, tbsLen, &amp;pucSignature);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_InternalSign_ECC error, ret = %08x", ret);
    SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
    return CRYPT_SM2_INVALID_PRVKEY;
}
ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
if (ret != SDR_OK) {
    LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
    return CRYPT_SM2_INVALID_PRVKEY;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Missing digest size zero check can cause infinite loop in MGF1</div>
                <div class="issue-location">src/crypt_util_mgf.c:41-43</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>uint32_t hashLen = CRYPT_EAL_MdGetDigestSize(id);
if (hashLen &gt; HASH_MAX_MDSIZE) {
    return CRYPT_RSA_ERR_INPUT_VALUE;
}</pre>
                <div class="problem"><strong>Issue:</strong> If `CRYPT_EAL_MdGetDigestSize` returns 0 for an unsupported or invalid hash algorithm, `hashLen` becomes 0. At line 61, `partLen` would be calculated as 0 when `outLen >= maskLen`, causing the loop at line 54 to never increment `outLen`, resulting in an infinite loop.</div>
                <div class="fix-label">Fix:</div><pre>uint32_t hashLen = CRYPT_EAL_MdGetDigestSize(id);
if (hashLen == 0 || hashLen &gt; HASH_MAX_MDSIZE) {
    return CRYPT_RSA_ERR_INPUT_VALUE;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Uninitialized args pointer when process args parameter is absent</div>
                <div class="issue-location">src/crypt_util_pkey.c:22-26</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>BSL_Param *argsParam = BSL_PARAM_FindParam(params, CRYPT_PARAM_PKEY_PROCESS_ARGS);
if (argsParam != NULL) {
    GOTO_ERR_IF_EX(BSL_PARAM_GetPtrValue(argsParam, CRYPT_PARAM_PKEY_PROCESS_ARGS,
        BSL_PARAM_TYPE_CTX_PTR, args, NULL), ret);
}</pre>
                <div class="problem"><strong>Issue:</strong> If `CRYPT_PARAM_PKEY_PROCESS_ARGS` isn't present in the params, `*args` is never initialized. The callback function may receive an uninitialized garbage pointer value, potentially causing undefined behavior.</div>
                <div class="fix-label">Fix:</div><pre>if (args != NULL) {
    *args = NULL;
}
BSL_Param *argsParam = BSL_PARAM_FindParam(params, CRYPT_PARAM_PKEY_PROCESS_ARGS);
if (argsParam != NULL) {
    GOTO_ERR_IF_EX(BSL_PARAM_GetPtrValue(argsParam, CRYPT_PARAM_PKEY_PROCESS_ARGS,
        BSL_PARAM_TYPE_CTX_PTR, args, NULL), ret);
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Hardcoded default password for private key access</div>
                <div class="issue-location">src/provider.h:10</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>#define DEFAULT_PASS "12345678"
#define DEFAULT_PASS_LEN strlen(DEFAULT_PASS)</pre>
                <div class="problem"><strong>Issue:</strong> `DEFAULT_PASS` is hardcoded as "12345678". This password is used throughout the codebase to access private keys in the SDF device. Hardcoding such sensitive credentials is insecure and should be configurable or provided by the user/application at runtime.</div>
                <div class="fix-label">Fix:</div><pre>/* Remove hardcoded DEFAULT_PASS and implement a mechanism to pass the key password from the application through the provider context or control APIs. */</pre>
            </div>
<div class="issue">
                <div class="issue-title">RSA key check reports success without validation</div>
                <div class="issue-location">src/rsa_keymgmt.c:584-595</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>case CRYPT_PKEY_CHECK_KEYPAIR:
    // TODO
    return CRYPT_SUCCESS;
case CRYPT_PKEY_CHECK_PRVKEY:
    // TODO
    return CRYPT_SUCCESS;</pre>
                <div class="problem"><strong>Issue:</strong> The `CRYPT_RSA_Check` function returns `CRYPT_SUCCESS` for `CRYPT_PKEY_CHECK_KEYPAIR` and `CRYPT_PKEY_CHECK_PRVKEY` checks but does not actually validate anything (marked with `// TODO`). Invalid keys can be treated as valid, potentially causing security issues.</div>
                <div class="fix-label">Fix:</div><pre>case CRYPT_PKEY_CHECK_KEYPAIR:
case CRYPT_PKEY_CHECK_PRVKEY:
    return CRYPT_NOT_SUPPORT;</pre>
            </div>
<div class="issue">
                <div class="issue-title">SM2 key check reports success without validation</div>
                <div class="issue-location">src/sm2_keymgmt.c:301-318</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>case CRYPT_PKEY_CHECK_KEYPAIR:
    if (pkey1 == NULL || pkey2 == NULL) {
        return CRYPT_NULL_INPUT;
    }
    // TODO
    ret = CRYPT_SUCCESS;
    break;
case CRYPT_PKEY_CHECK_PRVKEY:
    if (pkey1 == NULL) {
        return CRYPT_NULL_INPUT;
    }
    // TODO
    ret = CRYPT_SUCCESS;
    break;</pre>
                <div class="problem"><strong>Issue:</strong> The `CRYPT_SM2_Check` function returns `CRYPT_SUCCESS` for `CRYPT_PKEY_CHECK_KEYPAIR` and `CRYPT_PKEY_CHECK_PRVKEY` checks but does not validate the key material (marked with `// TODO`). This allows invalid keys to pass validation.</div>
                <div class="fix-label">Fix:</div><pre>case CRYPT_PKEY_CHECK_KEYPAIR:
case CRYPT_PKEY_CHECK_PRVKEY:
    return CRYPT_NOT_SUPPORT;</pre>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Use of thread-unsafe localtime function</div>
                <div class="issue-location">src/log.c:24</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>time(&amp;timep);
p = localtime(&amp;timep);</pre>
                <div class="problem"><strong>Issue:</strong> `localtime` returns a pointer to a static structure which is shared among all threads. In a multi-threaded environment, this can lead to race conditions where the timestamp in the log is corrupted.</div>
                <div class="fix-label">Fix:</div><pre>struct tm tm_res;
time(&amp;timep);
p = localtime_r(&amp;timep, &amp;tm_res);</pre>
            </div>
<div class="issue">
                <div class="issue-title">KeyIndex masquerading as private key data</div>
                <div class="issue-location">src/sm2_keymgmt.c:103</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge evaluate">置信度: 需评估</span>
                </div>
                <pre>if (memcmp(prv.data, zero, prv.len - 1) == 0) {
    // data with leading 0x00, use it as KeyIndex
    ctx-&gt;KeyIndex = prv.data[prv.len - 1];
}</pre>
                <div class="problem"><strong>Issue:</strong> If the provided private key data consists of zeros except for the last byte, it is interpreted as a `KeyIndex`. When exporting this key back, `CRYPT_SM2_GetPrvKeyEx` returns this "fake" private key. This design pattern can lead to security issues or interoperability failures if this key is imported into a system that expects real private key bytes.</div>
                <div class="fix-label">Fix:</div><pre>/* Use a separate parameter type (e.g. CRYPT_PARAM_KEY_INDEX) to specify hardware key indices instead of overloading the private key buffer. */</pre>
            </div>
</div>
</div></body></html>