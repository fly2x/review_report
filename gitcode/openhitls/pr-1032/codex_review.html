<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/openhitls#1032 - CODEX</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/openhitls#1032 - CODEX</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">IP SAN compared to hostname string (binary mismatch + OOB read)</div>
                <div class="issue-location">pki/x509_common/src/hitls_x509_util.c:182-184</div>
                <pre>} else if (gn-&gt;type == HITLS_X509_GN_IP) {
            ret = memcmp(gn-&gt;value.data, hostname, gn-&gt;value.dataLen);
            if (ret == HITLS_PKI_SUCCESS) {</pre>
                <div class="problem"><strong>Issue:</strong> `memcmp` compares raw SAN IP bytes against the ASCII hostname string for `gn->value.dataLen` bytes. This never matches valid IP SANs and can read past the hostname buffer (e.g., IPv6 "::" is 2 bytes but SAN length is 16), causing out-of-bounds reads and false verification failures.</div>
                <div class="fix-label">Fix:</div><pre>} else if (gn-&gt;type == HITLS_X509_GN_IP) {
            uint8_t ipbuf[16];
            int af = (gn-&gt;value.dataLen == 4) ? AF_INET :
                     (gn-&gt;value.dataLen == 16) ? AF_INET6 : -1;
            if (af != -1 &amp;&amp; inet_pton(af, hostname, ipbuf) == 1 &amp;&amp;
                memcmp(gn-&gt;value.data, ipbuf, gn-&gt;value.dataLen) == 0) {
                ret = HITLS_PKI_SUCCESS;
                break;
            }
        }</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Hostname/IP verification uses AND semantics</div>
                <div class="issue-location">pki/x509_verify/src/hitls_x509_verify.c:1998-2011</div>
                <pre>if (storeCtx-&gt;verifyParam.hostnames != NULL &amp;&amp; BSL_LIST_COUNT(storeCtx-&gt;verifyParam.hostnames) &gt; 0) {
        ret = CheckHostnames(storeCtx, chain);
        if (ret != HITLS_PKI_SUCCESS) {
            return ret;
        }
    }

    if (storeCtx-&gt;verifyParam.ip != NULL) {
        HITLS_X509_Cert *certee = BSL_LIST_GET_FIRST(chain);
        ret = HITLS_X509_VerifyHostname(certee, storeCtx-&gt;verifyParam.hostflags, storeCtx-&gt;verifyParam.ip, strlen(storeCtx-&gt;verifyParam.ip));
        if (ret != HITLS_PKI_SUCCESS) {
            return ret;
        }
    }
    return HITLS_PKI_SUCCESS;</pre>
                <div class="problem"><strong>Issue:</strong> If both hostnames and IP are configured, the function requires the hostname match to succeed before it even checks the IP. This makes verification fail even when the IP matches, which is surprising for an API that allows multiple hosts/IPs.</div>
                <div class="fix-label">Fix:</div><pre>bool matched = false;

    if (storeCtx-&gt;verifyParam.hostnames != NULL &amp;&amp; BSL_LIST_COUNT(storeCtx-&gt;verifyParam.hostnames) &gt; 0) {
        matched = (CheckHostnames(storeCtx, chain) == HITLS_PKI_SUCCESS);
    }

    if (!matched &amp;&amp; storeCtx-&gt;verifyParam.ip != NULL) {
        HITLS_X509_Cert *certee = BSL_LIST_GET_FIRST(chain);
        matched = (HITLS_X509_VerifyHostname(certee, storeCtx-&gt;verifyParam.hostflags,
            storeCtx-&gt;verifyParam.ip, strlen(storeCtx-&gt;verifyParam.ip)) == HITLS_PKI_SUCCESS);
    }

    return matched ? HITLS_PKI_SUCCESS : HITLS_X509_ERR_VFY_HOSTNAME_FAIL;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">Host flag value read incorrectly on big-endian targets</div>
                <div class="issue-location">tls/cert/hitls_x509_adapt/hitls_x509_cert_store.c:105-110</div>
                <pre>case CERT_STORE_CTRL_SET_HOST_FLAG:
            if (*(int64_t *)input &gt; UINT32_MAX || *(int64_t *)input &lt; 0) {
                return HITLS_CERT_STORE_CTRL_ERR_SET_HOST_FLAG;
            }
            return HITLS_X509_StoreCtxCtrl(store, HITLS_X509_STORECTX_SET_HOST_FLAG, (int64_t *)input,
                sizeof(uint32_t));</pre>
                <div class="problem"><strong>Issue:</strong> `CERT_STORE_CTRL_SET_HOST_FLAG` passes an `int64_t*` with a 4-byte length. On big-endian systems, `X509_SetHostFlags` will read the high 32 bits (zero for valid values), so hostflags are effectively ignored.</div>
                <div class="fix-label">Fix:</div><pre>case CERT_STORE_CTRL_SET_HOST_FLAG: {
            if (*(int64_t *)input &gt; UINT32_MAX || *(int64_t *)input &lt; 0) {
                return HITLS_CERT_STORE_CTRL_ERR_SET_HOST_FLAG;
            }
            uint32_t hostflag = (uint32_t)*(int64_t *)input;
            return HITLS_X509_StoreCtxCtrl(store, HITLS_X509_STORECTX_SET_HOST_FLAG, &amp;hostflag,
                sizeof(hostflag));
        }</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Hostname verification ignores configured host flags</div>
                <div class="issue-location">pki/x509_verify/src/hitls_x509_verify.c:1977-1979</div>
                <pre>for (char *hostname = BSL_LIST_GET_FIRST(storeCtx-&gt;verifyParam.hostnames); hostname != NULL;) {
        ret = HITLS_X509_VerifyHostname(certee, 0, hostname, strlen(hostname));
        if (ret == HITLS_PKI_SUCCESS) {</pre>
                <div class="problem"><strong>Issue:</strong> DNS hostname checks always pass `0` as flags, so the newly added `hostflags` setting is never applied to DNS matches (only to IP checks). This makes the host flag API ineffective for DNS validation.</div>
                <div class="fix-label">Fix:</div><pre>for (char *hostname = BSL_LIST_GET_FIRST(storeCtx-&gt;verifyParam.hostnames); hostname != NULL;) {
        ret = HITLS_X509_VerifyHostname(certee, storeCtx-&gt;verifyParam.hostflags, hostname, strlen(hostname));
        if (ret == HITLS_PKI_SUCCESS) {</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">Missing error handling for hostnames copy failure</div>
                <div class="issue-location">pki/x509_verify/src/hitls_x509_verify.c:969-973</div>
                <pre>if (verifyParam-&gt;hostnames != NULL) {
        BSL_LIST_FREE(storeCtx-&gt;verifyParam.hostnames, (BSL_LIST_PFUNC_FREE)BSL_SAL_Free);
        storeCtx-&gt;verifyParam.hostnames = BSL_LIST_Copy(verifyParam-&gt;hostnames, (BSL_LIST_PFUNC_DUP)DupString,
            (BSL_LIST_PFUNC_FREE)BSL_SAL_Free);
    }</pre>
                <div class="problem"><strong>Issue:</strong> `BSL_LIST_Copy` can return NULL on allocation failure, but the code ignores it and returns success, silently dropping hostnames and masking the error.</div>
                <div class="fix-label">Fix:</div><pre>if (verifyParam-&gt;hostnames != NULL) {
        BSL_LIST_FREE(storeCtx-&gt;verifyParam.hostnames, (BSL_LIST_PFUNC_FREE)BSL_SAL_Free);
        storeCtx-&gt;verifyParam.hostnames = BSL_LIST_Copy(verifyParam-&gt;hostnames, (BSL_LIST_PFUNC_DUP)DupString,
            (BSL_LIST_PFUNC_FREE)BSL_SAL_Free);
        if (storeCtx-&gt;verifyParam.hostnames == NULL) {
            BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);
            return BSL_MALLOC_FAIL;
        }
    }</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
</div></body></html>