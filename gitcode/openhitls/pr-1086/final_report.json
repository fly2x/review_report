{
  "context": {
    "owner": "openHiTLS",
    "repo": "openhitls",
    "pr_id": "1086",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 9,
    "critical": 1,
    "high": 4,
    "medium": 4,
    "low": 0
  },
  "issues": [
    {
      "file": "apps/src/app_utils.c",
      "line": "1102-1107",
      "severity": "critical",
      "title": "Undefined variable `len` causes compilation error in HITLS_APP_SM_MODE",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The variable `len` is used in the CRYPT_EAL_ProviderRandInitCtx call but is never defined. When replacing sprintf_s with snprintf, the return value (which provided the length) was discarded but the variable `len` remained in the function call. This causes a compilation error when HITLS_APP_SM_MODE is enabled.",
      "code": "static int32_t InitRand(AppInitParam *param)\n{\n#ifdef HITLS_APP_SM_MODE\n    pid_t pid = getpid();\n    char str[32] = {0};\n    (void)snprintf(str, sizeof(str), \"%d\", pid);\n    if (param->smParam->smTag == 1 && param->randAlgId == CRYPT_RAND_SHA256) {\n        param->randAlgId = CRYPT_RAND_SM4_CTR_DF;\n    }\n    int32_t ret = CRYPT_EAL_ProviderRandInitCtx(APP_GetCurrent_LibCtx(), param->randAlgId,\n        param->provider->providerAttr, (const uint8_t *)str, len, NULL);",
      "fix": "static int32_t InitRand(AppInitParam *param)\n{\n#ifdef HITLS_APP_SM_MODE\n    pid_t pid = getpid();\n    char str[32] = {0};\n    int len = snprintf(str, sizeof(str), \"%d\", pid);\n    if (len < 0 || (size_t)len >= sizeof(str)) {\n        AppPrintError(\"Failed to set pid, pid = %d.\\n\", pid);\n        return HITLS_APP_INVALID_ARG;\n    }\n    if (param->smParam->smTag == 1 && param->randAlgId == CRYPT_RAND_SHA256) {\n        param->randAlgId = CRYPT_RAND_SM4_CTR_DF;\n    }\n    int32_t ret = CRYPT_EAL_ProviderRandInitCtx(APP_GetCurrent_LibCtx(), param->randAlgId,\n        param->provider->providerAttr, (const uint8_t *)str, (uint32_t)len, NULL);"
    },
    {
      "file": "bsl/sal/src/sal_mem.c",
      "line": "159-187",
      "severity": "high",
      "title": "Insecure memory clearing may be optimized away by compiler",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "The CleanSensitiveData function uses non-volatile assignments to wipe sensitive memory. With -O3 optimization enabled (line 114), the compiler may optimize away these writes as dead stores, leaving sensitive data in memory. The original code used memset_s which guarantees the memory is written.",
      "code": "static void CleanSensitiveData(void *buf, uint32_t bufLen)\n{\n    uint8_t *tmp = (uint8_t *)buf;\n    uint32_t boundOpt;\n\n    if (((uintptr_t)buf & 0x3) == 0) {\n        boundOpt = (bufLen >> 4) << 4;\n        for (uint32_t i = 0; i < boundOpt; i += 16) {\n            uint32_t *ctmp = (uint32_t *)(uintptr_t)(tmp + i);\n            ctmp[0] = 0;\n            ctmp[1] = 0;\n            ctmp[2] = 0;\n            ctmp[3] = 0;\n        }\n    } else {\n        boundOpt = (bufLen >> 2) << 2;\n        for (uint32_t i = 0; i < boundOpt; i += 4) {\n            tmp[i] = 0;\n            tmp[i + 1] = 0;\n            tmp[i + 2] = 0;\n            tmp[i + 3] = 0;\n        }\n    }\n    for (uint32_t i = boundOpt; i < bufLen; ++i) {\n        tmp[i] = 0;\n    }\n}",
      "fix": "static void CleanSensitiveData(void *buf, uint32_t bufLen)\n{\n    volatile uint8_t *tmp = (volatile uint8_t *)buf;\n    uint32_t boundOpt;\n\n    if (((uintptr_t)buf & 0x3) == 0) {\n        boundOpt = (bufLen >> 4) << 4;\n        for (uint32_t i = 0; i < boundOpt; i += 16) {\n            volatile uint32_t *ctmp = (volatile uint32_t *)(volatile uintptr_t)(tmp + i);\n            ctmp[0] = 0;\n            ctmp[1] = 0;\n            ctmp[2] = 0;\n            ctmp[3] = 0;\n        }\n    } else {\n        boundOpt = (bufLen >> 2) << 2;\n        for (uint32_t i = 0; i < boundOpt; i += 4) {\n            tmp[i] = 0;\n            tmp[i + 1] = 0;\n            tmp[i + 2] = 0;\n            tmp[i + 3] = 0;\n        }\n    }\n    for (uint32_t i = boundOpt; i < bufLen; ++i) {\n        tmp[i] = 0;\n    }\n}"
    },
    {
      "file": "tls/handshake/send/src/send_client_hello.c",
      "line": "330",
      "severity": "high",
      "title": "PSK secret material cleared with insecure memset instead of secure wipe",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The PSK buffer contains secret key material but is cleared using memset, which can be optimized away by the compiler. The original code used memset_s which guarantees secure wiping. This should use BSL_SAL_CleanseData which is already available in the codebase and used elsewhere for secure data clearing.",
      "code": "if (pskLen > HS_PSK_MAX_LEN) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID17111, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN, \"pskLen err\", 0, 0, 0, 0);\n    memset(psk, 0, HS_PSK_MAX_LEN);\n    return HITLS_MSG_HANDLE_ILLEGAL_PSK_LEN;\n}\n\nHITLS_Session *sess = HITLS_SESS_New();\nif (sess == NULL) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID17112, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN, \"sess new fail\", 0, 0, 0, 0);\n    memset(psk, 0, HS_PSK_MAX_LEN);\n    return HITLS_MEMALLOC_FAIL;\n}\n\nHITLS_SESS_SetMasterKey(sess, psk, pskLen);\nHITLS_SESS_SetCipherSuite(sess, HITLS_AES_128_GCM_SHA256);\nHITLS_SESS_SetProtocolVersion(sess, HITLS_VERSION_TLS13);\n*pskSession = sess;\nmemset(psk, 0, HS_PSK_MAX_LEN);",
      "fix": "if (pskLen > HS_PSK_MAX_LEN) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID17111, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN, \"pskLen err\", 0, 0, 0, 0);\n    BSL_SAL_CleanseData(psk, HS_PSK_MAX_LEN);\n    return HITLS_MSG_HANDLE_ILLEGAL_PSK_LEN;\n}\n\nHITLS_Session *sess = HITLS_SESS_New();\nif (sess == NULL) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID17112, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN, \"sess new fail\", 0, 0, 0, 0);\n    BSL_SAL_CleanseData(psk, HS_PSK_MAX_LEN);\n    return HITLS_MEMALLOC_FAIL;\n}\n\nHITLS_SESS_SetMasterKey(sess, psk, pskLen);\nHITLS_SESS_SetCipherSuite(sess, HITLS_AES_128_GCM_SHA256);\nHITLS_SESS_SetProtocolVersion(sess, HITLS_VERSION_TLS13);\n*pskSession = sess;\nBSL_SAL_CleanseData(psk, HS_PSK_MAX_LEN);"
    },
    {
      "file": "tls/handshake/common/src/hs_kx.c",
      "line": "436",
      "severity": "high",
      "title": "Pre-master secret cleared with insecure memset instead of secure wipe",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The tmpPskPmsBufTmp buffer contains pre-master secret material but is cleared using memset, which can be optimized away by the compiler. The original code used memset_s which guarantees secure wiping. This should use BSL_SAL_CleanseData.",
      "code": "memcpy(pmsBuf, tmpPskPmsBufTmp, offset);\n*pmsUsedLen = offset;\n\nmemset(tmpPskPmsBufTmp, 0, MAX_PRE_MASTER_SECRET_SIZE);\n\nreturn HITLS_SUCCESS;\nERR:\nmemset(tmpPskPmsBufTmp, 0, MAX_PRE_MASTER_SECRET_SIZE);\nBSL_ERR_PUSH_ERROR(HITLS_MEMCPY_FAIL);\nreturn HITLS_MEMCPY_FAIL;",
      "fix": "memcpy(pmsBuf, tmpPskPmsBufTmp, offset);\n*pmsUsedLen = offset;\n\nBSL_SAL_CleanseData(tmpPskPmsBufTmp, MAX_PRE_MASTER_SECRET_SIZE);\n\nreturn HITLS_SUCCESS;\nERR:\nBSL_SAL_CleanseData(tmpPskPmsBufTmp, MAX_PRE_MASTER_SECRET_SIZE);\nBSL_ERR_PUSH_ERROR(HITLS_MEMCPY_FAIL);\nreturn HITLS_MEMCPY_FAIL;"
    },
    {
      "file": "tls/handshake/common/src/hs_kx.c",
      "line": "667",
      "severity": "high",
      "title": "Master secret cleared with insecure memset instead of secure wipe",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The keyPara.masterSecret buffer contains the master secret but is cleared using memset. The original code used memset_s. This should use BSL_SAL_CleanseData.",
      "code": "memcpy(keyPara.masterSecret, ctx->hsCtx->masterKey, MASTER_SECRET_LEN);\nret = REC_InitPendingState(ctx, &keyPara);\n\nmemset(keyPara.masterSecret, 0, MASTER_SECRET_LEN);\nreturn ret;",
      "fix": "memcpy(keyPara.masterSecret, ctx->hsCtx->masterKey, MASTER_SECRET_LEN);\nret = REC_InitPendingState(ctx, &keyPara);\n\nBSL_SAL_CleanseData(keyPara.masterSecret, MASTER_SECRET_LEN);\nreturn ret;"
    },
    {
      "file": "bsl/log/src/log.c",
      "line": "39-43",
      "severity": "medium",
      "title": "Missing length validation in BSL_LOG_GetVersion can cause buffer overflow",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The original code verified that strlen(g_openHiTLSVersion) fits in the caller's buffer via memcpy_s. The new code only checks *versionLen >= HITLS_VERSION_LEN but doesn't verify the actual string length. If g_openHiTLSVersion is longer than expected (e.g., due to build configuration), it could overflow the caller's buffer.",
      "code": "if (*versionLen < HITLS_VERSION_LEN) {\n    return BSL_LOG_ERR_BAD_PARAM;\n}\n\nuint32_t len = (uint32_t)strlen(g_openHiTLSVersion);\n\nmemcpy(version, g_openHiTLSVersion, len);\n\n*versionLen = len;\nreturn BSL_SUCCESS;",
      "fix": "if (*versionLen < HITLS_VERSION_LEN) {\n    return BSL_LOG_ERR_BAD_PARAM;\n}\n\nuint32_t len = (uint32_t)strlen(g_openHiTLSVersion);\nif (len > *versionLen) {\n    return BSL_MEMCPY_FAIL;\n}\nmemcpy(version, g_openHiTLSVersion, len);\n\n*versionLen = len;\nreturn BSL_SUCCESS;"
    },
    {
      "file": "tls/cm/src/conn_create.c",
      "line": "838-844",
      "severity": "medium",
      "title": "Incorrect offset increment logic in Uint8ToHex after snprintf conversion",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The original code used `offsetTemp += sizeof(uint16_t)` (which is 2) because sprintf_s with \"%02x\" always writes 2 hex digits. The new code uses the actual snprintf return value. While the validation check handles error cases, if snprintf returns a value other than 2 (e.g., due to truncation), the offset calculation could be incorrect. For correctness, the offset should always increment by 2 for each byte since each hex byte is exactly 2 characters.",
      "code": "for (size_t i = 0u; i < srcLen; i++) {\n    int n = snprintf((char *)&destBuf[offsetTemp], (destMaxSize - offsetTemp), \"%02x\", srcBuf[i]);\n    if (n < 0 || (size_t)n >= (destMaxSize - offsetTemp)) {\n        BSL_LOG_BINLOG_FIXLEN(BINLOG_ID16481, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,\n            \"snprintf fail\", 0, 0, 0, 0);\n        return HITLS_INVALID_INPUT;\n    }\n    offsetTemp += (size_t)n;",
      "fix": "for (size_t i = 0u; i < srcLen; i++) {\n    int n = snprintf((char *)&destBuf[offsetTemp], (destMaxSize - offsetTemp), \"%02x\", srcBuf[i]);\n    if (n < 0 || n != 2 || (size_t)n >= (destMaxSize - offsetTemp)) {\n        BSL_LOG_BINLOG_FIXLEN(BINLOG_ID16481, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,\n            \"snprintf fail\", 0, 0, 0, 0);\n        return HITLS_INVALID_INPUT;\n    }\n    offsetTemp += 2;  // Each hex byte is exactly 2 characters"
    },
    {
      "file": "apps/src/app_enc.c",
      "line": "128-132",
      "severity": "medium",
      "title": "Missing output validation in Int2Hex after snprintf_s replacement",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The original code verified that snprintf_s wrote exactly REC_HEX_BUF_LENGTH (8) characters by checking strlen(hexBuf) != REC_HEX_BUF_LENGTH. The new code with standard snprintf doesn't validate the output. While the format \"%08X\" should always write 8 hex digits for a 32-bit int, the validation was removed entirely.",
      "code": "static int32_t Int2Hex(int32_t num, char *hexBuf)\n{\n    (void)snprintf(hexBuf, REC_HEX_BUF_LENGTH + 1, \"%08X\", num);\n    return HITLS_APP_SUCCESS;\n}",
      "fix": "static int32_t Int2Hex(int32_t num, char *hexBuf)\n{\n    int ret = snprintf(hexBuf, REC_HEX_BUF_LENGTH + 1, \"%08X\", num);\n    if (ret < 0 || ret != REC_HEX_BUF_LENGTH) {\n        AppPrintError(\"enc: error in uint to hex.\\n\");\n        return HITLS_APP_ENCODE_FAIL;\n    }\n    return HITLS_APP_SUCCESS;\n}"
    },
    {
      "file": "tls/handshake/common/src/hs_common.c",
      "line": "716-723",
      "severity": "medium",
      "title": "Incorrect condition in IsSpecialLabel after memcpy_s replacement",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The original code used memcpy_s error return to detect if the label was too long. The new condition `useLabelLen <= sizeof(labelBuf)` is semantically incorrect. When the label is short (which is the normal case), the code copies it and then returns true (indicating \"special handling needed\"). The function should only return true when the label is too long, not when it fits.",
      "code": "size_t useLabelLen = labelLen;\nif (labelLen > MAX_LABEL_SIZE) {\n    useLabelLen = MAX_LABEL_SIZE;\n}\nif (labelLen != 0 && useLabelLen <= sizeof(labelBuf)) {\n    memcpy(labelBuf, label, useLabelLen);\n} else if (labelLen != 0) {\n    return true;\n}",
      "fix": "size_t useLabelLen = labelLen;\nif (labelLen != 0) {\n    if (labelLen > sizeof(labelBuf) - 1) {\n        return true;  // Label too long, needs special handling\n    }\n    memcpy(labelBuf, label, labelLen);\n}"
    }
  ]
}