[
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "597",
    "severity": "critical",
    "title": "Breaking change in file format without version increment",
    "problem": "The encryption file format has changed from ASCII hex strings to big-endian binary integers (and optionally encoded body), but `HITLS_APP_ENC_VERSION` remains `1`. This breaks backward compatibility: new tools cannot decrypt old files (header parsing will fail or produce garbage), and old tools cannot decrypt new files.",
    "code": "#define HITLS_APP_ENC_VERSION 1\n// ...\nstatic void WriteUint32Be(uint8_t *buf, uint32_t value)\n{\n    buf[HITLS_APP_ENC_U32_IDX_0] = (uint8_t)((value >> HITLS_APP_ENC_SHIFT_24) & 0xFFU);\n// ...\n}",
    "fix": "// Increment version to distinguish from legacy format\n#define HITLS_APP_ENC_VERSION 2"
  },
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "631",
    "severity": "high",
    "title": "Integer truncation and potential buffer overflow in DecodeInputForDec",
    "problem": "`readLen` (uint64_t) is cast to `uint32_t` without checking if it exceeds `UINT32_MAX`. If the input file is larger than 4GB, `readLen` will be truncated, leading to incorrect buffer allocation sizes (e.g., `decodedLen`) and subsequent memory corruption or logic errors. This effectively breaks support for large files and introduces security risks.",
    "code": "if (encOpt->format == HITLS_APP_FORMAT_HEX) {\n        if ((readLen % HITLS_APP_ENC_HEX_CHAR_STEP) != 0) {\n            BSL_SAL_FREE(readBuf);\n            AppPrintError(\"enc: Invalid hex string length, must be even.\\n\");\n            return HITLS_APP_ENCODE_FAIL;\n        }\n        uint32_t decodedLen = (uint32_t)(readLen / HITLS_APP_ENC_HEX_CHAR_STEP);\n        uint8_t *decoded = (uint8_t *)BSL_SAL_Calloc(decodedLen + 1, 1);",
    "fix": "if (encOpt->format == HITLS_APP_FORMAT_HEX) {\n        if (readLen > UINT32_MAX || (readLen % HITLS_APP_ENC_HEX_CHAR_STEP) != 0) {\n            BSL_SAL_FREE(readBuf);\n            AppPrintError(\"enc: Invalid hex string length or file too large.\\n\");\n            return HITLS_APP_ENCODE_FAIL;\n        }\n        uint32_t decodedLen = (uint32_t)(readLen / HITLS_APP_ENC_HEX_CHAR_STEP);"
  },
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "663",
    "severity": "high",
    "title": "Integer truncation in base64 decoding length calculation",
    "problem": "Similar to the hex case, `readLen` is cast to `uint32_t` before calculating the base64 decode length. If `readLen` exceeds `UINT32_MAX`, the length is truncated, leading to insufficient memory allocation and potential heap corruption during decoding.",
    "code": "if (encOpt->format == HITLS_APP_FORMAT_BASE64) {\n        uint32_t decodedLen = HITLS_BASE64_DECODE_LENGTH((uint32_t)readLen);\n        uint8_t *decoded = (uint8_t *)BSL_SAL_Calloc(decodedLen + 1, 1);",
    "fix": "if (encOpt->format == HITLS_APP_FORMAT_BASE64) {\n        if (readLen > UINT32_MAX) {\n            BSL_SAL_FREE(readBuf);\n            return HITLS_APP_ENCODE_FAIL;\n        }\n        uint32_t decodedLen = HITLS_BASE64_DECODE_LENGTH((uint32_t)readLen);"
  },
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "1076",
    "severity": "high",
    "title": "Integer overflow in buffer allocation causing heap overflow",
    "problem": "`outLen` calculation `encOpt->cipherBufLen + encOpt->keySet->blockSize` can overflow if `cipherBufLen` is close to `UINT32_MAX`. This would result in `BSL_SAL_Malloc` allocating a small buffer, while `CRYPT_EAL_CipherUpdate` writes the full decrypted output, causing a heap buffer overflow.",
    "code": "uint32_t outLen = encOpt->cipherBufLen + encOpt->keySet->blockSize;\n    uint8_t *resBuf = (uint8_t *)BSL_SAL_Malloc(outLen);\n    if (resBuf == NULL) {",
    "fix": "if (encOpt->cipherBufLen > UINT32_MAX - encOpt->keySet->blockSize) {\n        return HITLS_APP_MEM_ALLOC_FAIL;\n    }\n    uint32_t outLen = encOpt->cipherBufLen + encOpt->keySet->blockSize;\n    uint8_t *resBuf = (uint8_t *)BSL_SAL_Malloc(outLen);"
  },
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "629",
    "severity": "medium",
    "title": "Regression in large file support (Decryption)",
    "problem": "The new decryption implementation (`DoCipherUpdateDec` relying on `DecodeInputForDec`) reads the *entire* input file into memory using `HITLS_APP_OptReadUio` (with `UINT64_MAX` limit). This causes denial of service (OOM) for large files that fit in the previous streaming implementation. Encryption (`DoCipherUpdateEnc`) still appears to support streaming.",
    "code": "static int32_t DecodeInputForDec(EncCmdOpt *encOpt)\n{\n    uint8_t *readBuf = NULL;\n    uint64_t readLen = 0;\n    int32_t ret = HITLS_APP_OptReadUio(encOpt->encUio->rUio, &readBuf, &readLen, UINT64_MAX);",
    "fix": "// Restore streaming processing for decryption, or strictly limit input size and document the limitation.\n// Ideally, implement a streaming decoder for Hex/Base64 to feed the cipher update loop."
  },
  {
    "source": "gemini",
    "file": "apps/src/app_enc.c",
    "line": "376",
    "severity": "low",
    "title": "Typo in constant name HILTS_APP_FORMAT_UNDEF",
    "problem": "The constant `HILTS_APP_FORMAT_UNDEF` contains a typo (`HILTS` instead of `HITLS`). While this matches the definition in `apps/include/app_opt.h`, it is inconsistent with other constants like `HITLS_APP_FORMAT_HEX` and the project naming convention.",
    "code": "if (encOpt->format == HILTS_APP_FORMAT_UNDEF) {\n        encOpt->format = HITLS_APP_FORMAT_BINARY;\n    }",
    "fix": "if (encOpt->format == HITLS_APP_FORMAT_UNDEF) { // Requires fixing header definition as well\n        encOpt->format = HITLS_APP_FORMAT_BINARY;\n    }"
  }
]