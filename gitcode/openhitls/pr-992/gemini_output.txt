I will start by checking the current git status and recent commit history to understand the context of the PR and verify the base commit.
I will list the changed files and their diff statistics to confirm the scope of the changes.
I will read the content of `crypto/lms/src/lms_core.c` to examine the core LMS cryptographic logic.
I will read `crypto/lms/src/lms_ots.c` to examine the LMS One-Time Signature implementation, focusing on parameter validation and complexity.
I will check `crypto/lms/src/lms_local.h` to verify macros such as `LMS_MAX_HASH` and `LMS_CHECKSUM_LEN` and ensure buffer safety.
I will read `crypto/lms/include/crypt_lms.h` to locate the definition of `LMS_MAX_HASH` and check for other relevant definitions.
I will read `crypto/lms/src/lms_params.h` to locate the definition of `LMS_MAX_HASH` and check for other parameter definitions.
I will search for the definition of `LmsLookupParamSet` in the `crypto/lms/src/` directory to verify its implementation and check for any potential issues.
I will read `crypto/lms/src/lms_hash.c` to examine `LmsLookupParamSet` and `LmsHash` implementations.
I will read `crypto/lms/src/hss_core.c` to examine the HSS implementation and how it utilizes the LMS functions.
I will read `crypto/lms/src/hss_utils.c` to examine the implementation of `HssCalculateTreeIndices` and other utility functions.
I will read `config/macro_config/hitls_config_layer_crypto.h` to confirm if the LMS configuration is enabled.
===ISSUE===
FILE: crypto/lms/src/hss_utils.c
LINE: 274
SEVERITY: critical
TITLE: HSS Tree Index Calculation Uses Wrong Level Height
PROBLEM: The calculation of `sigsPerTree[i]` incorrectly uses the height of the child level (`i + 1`) instead of the current level (`i`). `sigsPerTree[i]` represents the capacity (number of bottom-level signatures) covered by a tree at level `i`. It should be `sigsPerTree[i + 1] * (1 << height_of_level_i)`. The current code computes `sigsPerTree[i + 1] * (1 << height_of_level_i_plus_1)`, effectively using the child's height twice. This results in incorrect tree and leaf indices when different levels have different heights (e.g., h=10 at level 0, h=20 at level 1).
CODE:
```c
    for (int32_t i = (int32_t)para->levels - 2; i >= 0; i--) {
        uint32_t childHeight = para->levelPara[i + 1].height;
        sigsPerTree[i] = sigsPerTree[i + 1] * (1ULL << childHeight);
    }
```
FIX:
```c
    for (int32_t i = (int32_t)para->levels - 2; i >= 0; i--) {
        uint32_t height = para->levelPara[i].height;
        sigsPerTree[i] = sigsPerTree[i + 1] * (1ULL << height);
    }
```
===END===

===ISSUE===
FILE: crypto/lms/src/lms_core.c
LINE: 133
SEVERITY: medium
TITLE: Unsafe Memory Allocation for Large Merkle Trees
PROBLEM: `LmsComputeRoot` allocates memory for the entire Merkle tree (`2 * numLeaves * n`). While `LmsParaInit` restricts height to 15 (max ~1MB), `LmsLookupParamSet` supports heights up to 25. If `LmsComputeRoot` is called with a valid parameter set for h=20 (1M leaves) or h=25 (32M leaves) — which is permitted by `LmsLookupParamSet` — it will attempt to allocate 64MB or 2GB of contiguous memory, potentially causing Denial of Service or OOM on constrained systems. The implementation should either support large trees using a low-memory algorithm (e.g., TreeHash) or explicitly validate `height` within `LmsComputeRoot` against the implementation's limit.
CODE:
```c
    uint32_t numLeaves = 1u << para->height;
    size_t treeSize = 2 * numLeaves * para->n;
    uint8_t *tree = BSL_SAL_Calloc(treeSize, 1);
```
FIX:
```c
    // Validate height to prevent excessive memory allocation
    if (para->height > LMS_MAX_PRACTICAL_HEIGHT) {
        return CRYPT_LMS_INVALID_PARAM;
    }

    uint32_t numLeaves = 1u << para->height;
    size_t treeSize = 2 * numLeaves * para->n;
    uint8_t *tree = BSL_SAL_Calloc(treeSize, 1);
```
===END===