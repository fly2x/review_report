[
  {
    "source": "codex",
    "file": "crypto/lms/src/hss_utils.c",
    "line": "117-224",
    "severity": "high",
    "title": "HSS param compression allows unsupported levels leading to OOB read on decompress",
    "problem": "The compressed parameter format only has 8 bytes (max 3 levels), but HssCompressParamSet accepts levels up to 8 and silently truncates. HssDecompressParamSet then trusts `levels` and reads `compressed[...+1]`, which goes out of bounds when levels ≥ 4 (index 8). This is an out-of-bounds read and also produces keys that can’t be safely reloaded.",
    "code": "if (para->levels < HSS_MIN_LEVELS || para->levels > HSS_MAX_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\n\nmemset(compressed, 0, HSS_COMPRESSED_PARAMS_LEN);\ncompressed[0] = (uint8_t)para->levels;\n\nfor (uint32_t i = 0; i < para->levels && i < HSS_MAX_COMPRESSED_LEVELS; i++) {\n    ...\n}\n\nuint32_t levels = compressed[0];\nif (levels < HSS_MIN_LEVELS || levels > HSS_MAX_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\n\nfor (uint32_t i = 0; i < levels; i++) {\n    uint8_t lmsComp = compressed[HSS_COMPRESSED_LEVEL_FIELD_SIZE + i * HSS_COMPRESSED_PARAM_PAIR_SIZE];\n    uint8_t otsComp = compressed[HSS_COMPRESSED_LEVEL_FIELD_SIZE + i * HSS_COMPRESSED_PARAM_PAIR_SIZE + 1];\n    ...\n}",
    "fix": "if (para->levels < HSS_MIN_LEVELS || para->levels > HSS_MAX_LEVELS ||\n    para->levels > HSS_MAX_COMPRESSED_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\n\nmemset(compressed, 0, HSS_COMPRESSED_PARAMS_LEN);\ncompressed[0] = (uint8_t)para->levels;\n\nfor (uint32_t i = 0; i < para->levels; i++) {\n    ...\n}\n\nuint32_t levels = compressed[0];\nif (levels < HSS_MIN_LEVELS || levels > HSS_MAX_LEVELS ||\n    levels > HSS_MAX_COMPRESSED_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\n\nfor (uint32_t i = 0; i < levels; i++) {\n    ...\n}"
  },
  {
    "source": "codex",
    "file": "crypto/lms/src/hss_api.c",
    "line": "362-395",
    "severity": "medium",
    "title": "HSS public key load never initializes derived parameters",
    "problem": "CRYPT_HSS_SetPubKey only stores `levels`, `lmsType[0]`, and `otsType[0]` but never calls HssParaInit. As a result `levelPara[*].sigLen` stays zero and HssParseSignature/Verify parse signatures incorrectly (verification always fails for a freshly loaded public key).",
    "code": "ctx->para->levels = levels;\nctx->para->lmsType[0] = lmsType;\nctx->para->otsType[0] = otsType;\n\nreturn CRYPT_SUCCESS;",
    "fix": "ctx->para->levels = levels;\nctx->para->lmsType[0] = lmsType;\nctx->para->otsType[0] = otsType;\n\nfor (uint32_t i = 0; i < levels; i++) {\n    if (ctx->para->lmsType[i] == 0 || ctx->para->otsType[i] == 0) {\n        return CRYPT_HSS_INVALID_PARAM;\n    }\n}\n\nint32_t ret = HssParaInit(ctx->para, levels, ctx->para->lmsType, ctx->para->otsType);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}"
  },
  {
    "source": "codex",
    "file": "crypto/lms/src/hss_core.c",
    "line": "361-395",
    "severity": "low",
    "title": "HSS signature parsing ignores trailing bytes",
    "problem": "HssParseSignature only checks `bottomSigLen > remaining` and then sets `bottomSig`, which means extra trailing bytes are silently ignored. This makes signature parsing non-strict and allows malleable signatures with junk suffixes to pass structure validation.",
    "code": "parsed->bottomSigLen = para->levelPara[bottomLevel].sigLen;\n\nif (parsed->bottomSigLen > remaining) {\n    return CRYPT_HSS_SIGNATURE_PARSE_FAIL;\n}\n\nparsed->bottomSig = sigPtr;\nreturn CRYPT_SUCCESS;",
    "fix": "parsed->bottomSigLen = para->levelPara[bottomLevel].sigLen;\n\nif (parsed->bottomSigLen != remaining) {\n    return CRYPT_HSS_SIGNATURE_PARSE_FAIL;\n}\n\nparsed->bottomSig = sigPtr;\nreturn CRYPT_SUCCESS;"
  },
  {
    "source": "codex",
    "file": "crypto/lms/src/lms_api.c",
    "line": "124-152",
    "severity": "low",
    "title": "LMS context comparison treats missing keys as equal",
    "problem": "CRYPT_LMS_Cmp compares keys only when both sides are non-NULL. If one context has a public/private key and the other doesn’t, it returns success, incorrectly reporting equality.",
    "code": "/* Compare public keys */\nif (ctx1->publicKey != NULL && ctx2->publicKey != NULL) {\n    if (memcmp(ctx1->publicKey, ctx2->publicKey, ctx1->para->pubKeyLen) != 0) {\n        return CRYPT_LMS_CMP_FALSE;\n    }\n}\n\n/* Compare private keys */\nif (ctx1->privateKey != NULL && ctx2->privateKey != NULL) {\n    if (memcmp(ctx1->privateKey, ctx2->privateKey, ctx1->para->prvKeyLen) != 0) {\n        return CRYPT_LMS_CMP_FALSE;\n    }\n}",
    "fix": "if ((ctx1->publicKey == NULL) != (ctx2->publicKey == NULL)) {\n    return CRYPT_LMS_CMP_FALSE;\n}\nif (ctx1->publicKey != NULL &&\n    memcmp(ctx1->publicKey, ctx2->publicKey, ctx1->para->pubKeyLen) != 0) {\n    return CRYPT_LMS_CMP_FALSE;\n}\n\nif ((ctx1->privateKey == NULL) != (ctx2->privateKey == NULL)) {\n    return CRYPT_LMS_CMP_FALSE;\n}\nif (ctx1->privateKey != NULL &&\n    memcmp(ctx1->privateKey, ctx2->privateKey, ctx1->para->prvKeyLen) != 0) {\n    return CRYPT_LMS_CMP_FALSE;\n}"
  }
]