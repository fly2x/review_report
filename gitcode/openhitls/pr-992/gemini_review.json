[
  {
    "source": "gemini",
    "file": "crypto/lms/src/hss_utils.c",
    "line": "317",
    "severity": "critical",
    "title": "HSS Index Calculation Logic Error leading to OTS Key Reuse",
    "problem": "The calculation of `leafIndex[i]` uses `sigsPerTree[i + 1]` as the divisor. This is incorrect. `sigsPerTree[i]` represents the weight/stride of level `i`, while `sigsPerTree[i+1]` is the weight of level `i+1`. Using the smaller weight of the next level causes the leaf index at the current level (e.g., the top level) to change too rapidly (for every message instead of every subtree). This results in the same One-Time Signature (OTS) key at the top level being used to sign multiple different child tree roots (different messages), which is a catastrophic security failure allowing forgery.",
    "code": "if (i == para->levels - 1) {\n            // Bottom level: leaf = globalIndex mod (2^height)\n            leafIndex[i] = (uint32_t)(globalIndex % maxLeaves);\n        } else {\n            // Higher levels: leaf = (globalIndex / sigsPerTree[i+1]) mod (2^height)\n            leafIndex[i] = (uint32_t)((globalIndex / sigsPerTree[i + 1]) % maxLeaves);\n        }",
    "fix": "// Leaf index at level i = (globalIndex / sigsPerTree[i]) % (2^height[i])\n        // Note: sigsPerTree[i] accounts for all levels below i.\n        leafIndex[i] = (uint32_t)((globalIndex / sigsPerTree[i]) % maxLeaves);"
  },
  {
    "source": "gemini",
    "file": "crypto/lms/src/hss_utils.c",
    "line": "305",
    "severity": "critical",
    "title": "HSS Tree Index Calculation Logic Error",
    "problem": "The calculation `treeIndex[i] = globalIndex / sigsPerTree[i]` is incorrect. `sigsPerTree[i]` is the capacity of the *subtrees* rooted at level `i` (number of bottom-level signatures per leaf at level `i`). Dividing by this value gives the cumulative index of the leaf at level `i`, not the index of the tree *containing* that leaf. For level `i`, the tree index should be determined by the capacity of the tree at level `i` (which is `sigsPerTree[i-1]` in the conceptual hierarchy, or `sigsPerTree[i] * 2^height[i]`). Using the wrong divisor means the derived tree seeds are incorrect and change too frequently, further compounding the OTS reuse issue.",
    "code": "for (uint32_t i = 0; i < para->levels; i++) {\n        // Tree index at level i = globalIndex / sigsPerTree[i]\n        treeIndex[i] = globalIndex / sigsPerTree[i];",
    "fix": "uint64_t currentCapacity = 0;\n    // Calculate capacity of the top level tree (Level 0)\n    if (para->levels > 0) {\n         uint32_t h0 = para->levelPara[0].height;\n         currentCapacity = sigsPerTree[0] * (1ULL << h0);\n    }\n\n    for (uint32_t i = 0; i < para->levels; i++) {\n        // Capacity of the tree at level i\n        uint64_t treeCapacity; \n        if (i == 0) {\n             treeCapacity = currentCapacity; // Should theoretically be infinite/total cap\n             treeIndex[i] = 0; // Root tree is always index 0\n        } else {\n             // Capacity of a tree at level i is sigsPerTree[i-1]\n             treeCapacity = sigsPerTree[i-1];\n             treeIndex[i] = globalIndex / treeCapacity;\n        }\n        \n        // Leaf calculation uses sigsPerTree[i] (signatures per leaf at level i)\n        uint32_t height = para->levelPara[i].height;\n        uint64_t maxLeaves = 1ULL << height;\n        leafIndex[i] = (uint32_t)((globalIndex / sigsPerTree[i]) % maxLeaves);\n    }"
  },
  {
    "source": "gemini",
    "file": "crypto/lms/src/lms_ots.c",
    "line": "105",
    "severity": "high",
    "title": "Unbounded Memory Allocation in LmOtsComputeQ",
    "problem": "The function allocates memory based on `messageLen` which is provided by the caller. If a user passes a very large message (e.g., a large file mapped into memory), this triggers a large allocation. This can lead to Denial of Service (DoS) via memory exhaustion. Furthermore, buffering the entire message to hash it is inefficient; a streaming hash update should be used.",
    "code": "uint8_t *prefix = BSL_SAL_Malloc(LMS_MESG_PREFIX_LEN(n) + messageLen);\n    if (prefix == NULL) {\n        return CRYPT_MEM_ALLOC_FAIL;\n    }\n\n    (void)memcpy_s(prefix + LMS_MESG_I_OFFSET, LMS_I_LEN, I, LMS_I_LEN);\n    // ...\n    (void)memcpy_s(prefix + LMS_MESG_PREFIX_LEN(n), messageLen, message, messageLen);\n\n    LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(n) + messageLen);\n    BSL_SAL_FREE(prefix);",
    "fix": "// Initialize Hash Context\n    void *ctx = NULL; // Assume EAL_MdCtxNew wrapper exists or use specific stack context\n    // EAL_MdInit(ctx, SHA256) ...\n    \n    // Hash Prefix\n    uint8_t prefixBuf[LMS_MESG_PREFIX_LEN(LMS_MAX_HASH)];\n    // ... Fill prefixBuf ...\n    // EAL_MdUpdate(ctx, prefixBuf, prefixLen);\n    \n    // Hash Message\n    // EAL_MdUpdate(ctx, message, messageLen);\n    \n    // Finalize\n    // EAL_MdFinal(ctx, Q);\n    \n    // Alternatively, if streaming API is not available, enforce a maximum message size\n    if (messageLen > HITLS_MAX_MESSAGE_SIZE) {\n        return CRYPT_INVALID_ARG;\n    }"
  },
  {
    "source": "gemini",
    "file": "crypto/lms/src/lms_core.c",
    "line": "316",
    "severity": "medium",
    "title": "Performance/DoS Risk in LmsSign",
    "problem": "`LmsSign` calls `LmsSignWriteSignature`, which calls `LmsGenerateAuthPath`. `LmsGenerateAuthPath` (via `LmsComputeLeafNodes`) regenerates the **entire Merkle Tree** (all leaves and internal nodes) for every single signature. For larger tree parameters (e.g., H=20, 1M leaves), this involves millions of hash operations per signature, making the signing operation extremely slow (seconds to minutes) and resource-intensive. This renders the implementation unusable for high-performance applications and susceptible to DoS.",
    "code": "int32_t LmsGenerateAuthPath(uint8_t *authPath, const LMS_Para *para,\n    const uint8_t *I, const uint8_t *seed, uint32_t q)\n{\n    // ...\n    int32_t ret = LmsComputeLeafNodes(tree, para, I, seed, numLeaves);\n    // ...\n}",
    "fix": "/*\n * Optimizing the tree traversal (e.g., using the fractal tree representation or caching) \n * is required for H > 15. \n * For now, at least add a warning or restriction on height for this implementation.\n */\n// In LmsParaInit or LmsKeyGen check:\nif (para->height > 15) {\n    // Return error or warning that performance will be degraded\n}"
  }
]