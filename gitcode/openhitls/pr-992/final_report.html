<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/openhitls#992</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/openhitls - PR #992</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">9</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">0</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">3</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">4</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">1</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Missing NULL check for ctx->para before dereferencing</div>
                <div class="issue-location">crypto/lms/src/hss_api.c:185-203</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>static int32_t HssCtrlSetLmsType(CRYPT_HSS_Ctx *ctx, void *val, uint32_t valLen)
{
    if (valLen &lt; 2 * sizeof(uint32_t)) {
        return CRYPT_HSS_INVALID_PARAM;
    }
    uint32_t *params = (uint32_t *)val;
    uint32_t levelIdx = params[0];
    uint32_t lmsType = params[1];

    if (levelIdx &gt;= ctx-&gt;para-&gt;levels) {  // NULL pointer dereference if ctx-&gt;para is NULL</pre>
                <div class="problem"><strong>Issue:</strong> Multiple control functions in hss_api.c dereference ctx->para without checking if it's NULL first. While CRYPT_HSS_NewCtx always allocates ctx->para, the para member could be NULL in error conditions or if memory allocation failed partially. This could cause NULL pointer dereferences.</div>
                <div class="fix-label">Fix:</div><pre>static int32_t HssCtrlSetLmsType(CRYPT_HSS_Ctx *ctx, void *val, uint32_t valLen)
{
    if (valLen &lt; 2 * sizeof(uint32_t)) {
        return CRYPT_HSS_INVALID_PARAM;
    }
    if (ctx-&gt;para == NULL) {
        return CRYPT_NULL_INPUT;
    }
    uint32_t *params = (uint32_t *)val;
    uint32_t levelIdx = params[0];
    uint32_t lmsType = params[1];

    if (levelIdx &gt;= ctx-&gt;para-&gt;levels) {</pre>
            </div>
<div class="issue">
                <div class="issue-title">HSS param compression allows unsupported levels leading to OOB read on decompress</div>
                <div class="issue-location">crypto/lms/src/hss_utils.c:117-224</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>int32_t HssCompressParamSet(uint8_t compressed[8], const HSS_Para *para)
{
    if (para == NULL) {
        return CRYPT_NULL_INPUT;
    }

    if (para-&gt;levels &lt; HSS_MIN_LEVELS || para-&gt;levels &gt; HSS_MAX_LEVELS) {
        return CRYPT_HSS_INVALID_LEVEL;
    }

    memset(compressed, 0, HSS_COMPRESSED_PARAMS_LEN);
    compressed[0] = (uint8_t)para-&gt;levels;

    for (uint32_t i = 0; i &lt; para-&gt;levels &amp;&amp; i &lt; HSS_MAX_COMPRESSED_LEVELS; i++) {
        // ... writes to compressed buffer
    }

int32_t HssDecompressParamSet(HSS_Para *para, const uint8_t compressed[8])
{
    if (para == NULL) {
        return CRYPT_NULL_INPUT;
    }

    uint32_t levels = compressed[0];
    if (levels &lt; HSS_MIN_LEVELS || levels &gt; HSS_MAX_LEVELS) {
        return CRYPT_HSS_INVALID_LEVEL;
    }

    uint32_t lmsTypes[HSS_MAX_LEVELS];
    uint32_t otsTypes[HSS_MAX_LEVELS];

    for (uint32_t i = 0; i &lt; levels; i++) {
        uint8_t lmsComp = compressed[HSS_COMPRESSED_LEVEL_FIELD_SIZE + i * HSS_COMPRESSED_PARAM_PAIR_SIZE];
        uint8_t otsComp = compressed[HSS_COMPRESSED_LEVEL_FIELD_SIZE + i * HSS_COMPRESSED_PARAM_PAIR_SIZE + 1];</pre>
                <div class="problem"><strong>Issue:</strong> The compressed parameter format only has 8 bytes (max 3 levels stored with 2 bytes each for type pairs plus 1 byte for levels), but HssCompressParamSet accepts levels up to 8 and silently truncates. HssDecompressParamSet then trusts the levels value from compressed data and reads beyond the compressed buffer when levels >= 4. This is an out-of-bounds read.</div>
                <div class="fix-label">Fix:</div><pre>int32_t HssCompressParamSet(uint8_t compressed[8], const HSS_Para *para)
{
    if (para == NULL) {
        return CRYPT_NULL_INPUT;
    }

    if (para-&gt;levels &lt; HSS_MIN_LEVELS || para-&gt;levels &gt; HSS_MAX_LEVELS ||
        para-&gt;levels &gt; HSS_MAX_COMPRESSED_LEVELS) {
        return CRYPT_HSS_INVALID_LEVEL;
    }
    // ... rest of function

int32_t HssDecompressParamSet(HSS_Para *para, const uint8_t compressed[8])
{
    if (para == NULL) {
        return CRYPT_NULL_INPUT;
    }

    uint32_t levels = compressed[0];
    if (levels &lt; HSS_MIN_LEVELS || levels &gt; HSS_MAX_LEVELS ||
        levels &gt; HSS_MAX_COMPRESSED_LEVELS) {
        return CRYPT_HSS_INVALID_LEVEL;
    }
    // ... rest of function</pre>
            </div>
<div class="issue">
                <div class="issue-title">HSS public key load never initializes derived parameters</div>
                <div class="issue-location">crypto/lms/src/hss_api.c:362-395</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>int32_t CRYPT_HSS_SetPubKey(CRYPT_HSS_Ctx *ctx, BSL_Param *param)
{
    if (ctx == NULL || param == NULL) {
        return CRYPT_NULL_INPUT;
    }

    // Find public key parameter
    const BSL_Param *pubKeyParam = BSL_PARAM_FindConstParam(param, CRYPT_PARAM_HSS_PUBKEY);
    if (pubKeyParam == NULL || pubKeyParam-&gt;value == NULL) {
        return CRYPT_HSS_NO_KEY;
    }

    if (pubKeyParam-&gt;valueLen != HSS_PUBKEY_LEN) {
        return CRYPT_HSS_INVALID_KEY_LEN;
    }

    // Copy public key
    (void)memcpy_s(ctx-&gt;publicKey, HSS_PUBKEY_LEN, pubKeyParam-&gt;value, HSS_PUBKEY_LEN);

    // Extract and validate parameters from public key
    uint32_t levels = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_LEVELS_OFFSET, LMS_TYPE_LEN);
    uint32_t lmsType = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_LMS_TYPE_OFFSET, LMS_TYPE_LEN);
    uint32_t otsType = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_OTS_TYPE_OFFSET, LMS_TYPE_LEN);

    if (levels &lt; HSS_MIN_LEVELS || levels &gt; HSS_MAX_LEVELS) {
        return CRYPT_HSS_INVALID_PARAM;
    }

    // Store top-level parameters
    ctx-&gt;para-&gt;levels = levels;
    ctx-&gt;para-&gt;lmsType[0] = lmsType;
    ctx-&gt;para-&gt;otsType[0] = otsType;

    return CRYPT_SUCCESS;  // Missing HssParaInit call!
}</pre>
                <div class="problem"><strong>Issue:</strong> CRYPT_HSS_SetPubKey only stores levels, lmsType[0], and otsType[0] but never calls HssParaInit. As a result, levelPara[*].sigLen stays zero and subsequent operations like HssParseSignature or verification parse signatures incorrectly because sigLen is not initialized.</div>
                <div class="fix-label">Fix:</div><pre>int32_t CRYPT_HSS_SetPubKey(CRYPT_HSS_Ctx *ctx, BSL_Param *param)
{
    if (ctx == NULL || ctx-&gt;para == NULL || param == NULL) {
        return CRYPT_NULL_INPUT;
    }

    // Find public key parameter
    const BSL_Param *pubKeyParam = BSL_PARAM_FindConstParam(param, CRYPT_PARAM_HSS_PUBKEY);
    if (pubKeyParam == NULL || pubKeyParam-&gt;value == NULL) {
        return CRYPT_HSS_NO_KEY;
    }

    if (pubKeyParam-&gt;valueLen != HSS_PUBKEY_LEN) {
        return CRYPT_HSS_INVALID_KEY_LEN;
    }

    // Copy public key
    (void)memcpy_s(ctx-&gt;publicKey, HSS_PUBKEY_LEN, pubKeyParam-&gt;value, HSS_PUBKEY_LEN);

    // Extract and validate parameters from public key
    uint32_t levels = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_LEVELS_OFFSET, LMS_TYPE_LEN);
    uint32_t lmsType = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_LMS_TYPE_OFFSET, LMS_TYPE_LEN);
    uint32_t otsType = (uint32_t)LmsGetBigendian(ctx-&gt;publicKey + HSS_PUBKEY_OTS_TYPE_OFFSET, LMS_TYPE_LEN);

    if (levels &lt; HSS_MIN_LEVELS || levels &gt; HSS_MAX_LEVELS) {
        return CRYPT_HSS_INVALID_PARAM;
    }

    // Store top-level parameters
    ctx-&gt;para-&gt;levels = levels;
    ctx-&gt;para-&gt;lmsType[0] = lmsType;
    ctx-&gt;para-&gt;otsType[0] = otsType;

    // Initialize all levels - for public key we only have level 0 types
    // Need to copy level 0 types to all levels for proper initialization
    for (uint32_t i = 1; i &lt; levels; i++) {
        ctx-&gt;para-&gt;lmsType[i] = lmsType;
        ctx-&gt;para-&gt;otsType[i] = otsType;
    }

    int32_t ret = HssParaInit(ctx-&gt;para, levels, ctx-&gt;para-&gt;lmsType, ctx-&gt;para-&gt;otsType);
    if (ret != CRYPT_SUCCESS) {
        return ret;
    }

    return CRYPT_SUCCESS;
}</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">HSS signature parsing ignores trailing bytes</div>
                <div class="issue-location">crypto/lms/src/hss_core.c:361-395</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>int32_t HssParseSignature(HSS_ParsedSig *parsed, const HSS_Para *para, const uint8_t *signature, size_t signatureLen)
{
    // ... parsing code ...
    
    uint32_t bottomLevel = para-&gt;levels - 1;
    parsed-&gt;bottomSigLen = para-&gt;levelPara[bottomLevel].sigLen;

    if (parsed-&gt;bottomSigLen &gt; remaining) {
        return CRYPT_HSS_SIGNATURE_PARSE_FAIL;
    }

    parsed-&gt;bottomSig = sigPtr;
    return CRYPT_SUCCESS;  // Does not check if remaining == bottomSigLen
}</pre>
                <div class="problem"><strong>Issue:</strong> HssParseSignature only checks bottomSigLen > remaining and then sets bottomSig, which means extra trailing bytes are silently ignored. This makes signature parsing non-strict and allows malleable signatures with junk suffixes to pass structure validation.</div>
                <div class="fix-label">Fix:</div><pre>uint32_t bottomLevel = para-&gt;levels - 1;
    parsed-&gt;bottomSigLen = para-&gt;levelPara[bottomLevel].sigLen;

    if (parsed-&gt;bottomSigLen != remaining) {
        return CRYPT_HSS_SIGNATURE_PARSE_FAIL;
    }

    parsed-&gt;bottomSig = sigPtr;
    return CRYPT_SUCCESS;</pre>
            </div>
<div class="issue">
                <div class="issue-title">LMS context comparison treats missing keys as equal</div>
                <div class="issue-location">crypto/lms/src/lms_api.c:124-152</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>int32_t CRYPT_LMS_Cmp(CRYPT_LMS_Ctx *ctx1, CRYPT_LMS_Ctx *ctx2)
{
    // ... parameter comparison ...
    
    /* Compare public keys */
    if (ctx1-&gt;publicKey != NULL &amp;&amp; ctx2-&gt;publicKey != NULL) {
        if (memcmp(ctx1-&gt;publicKey, ctx2-&gt;publicKey, ctx1-&gt;para-&gt;pubKeyLen) != 0) {
            return CRYPT_LMS_CMP_FALSE;
        }
    }

    /* Compare private keys */
    if (ctx1-&gt;privateKey != NULL &amp;&amp; ctx2-&gt;privateKey != NULL) {
        if (memcmp(ctx1-&gt;privateKey, ctx2-&gt;privateKey, ctx1-&gt;para-&gt;prvKeyLen) != 0) {
            return CRYPT_LMS_CMP_FALSE;
        }
    }

    return CRYPT_SUCCESS;  // Returns success even if one has key and other doesn't
}</pre>
                <div class="problem"><strong>Issue:</strong> CRYPT_LMS_Cmp compares keys only when both sides are non-NULL. If one context has a public/private key and the other doesn't, it returns success, incorrectly reporting equality.</div>
                <div class="fix-label">Fix:</div><pre>int32_t CRYPT_LMS_Cmp(CRYPT_LMS_Ctx *ctx1, CRYPT_LMS_Ctx *ctx2)
{
    // ... parameter comparison ...
    
    /* Compare public keys */
    if ((ctx1-&gt;publicKey == NULL) != (ctx2-&gt;publicKey == NULL)) {
        return CRYPT_LMS_CMP_FALSE;
    }
    if (ctx1-&gt;publicKey != NULL &amp;&amp;
        memcmp(ctx1-&gt;publicKey, ctx2-&gt;publicKey, ctx1-&gt;para-&gt;pubKeyLen) != 0) {
        return CRYPT_LMS_CMP_FALSE;
    }

    /* Compare private keys */
    if ((ctx1-&gt;privateKey == NULL) != (ctx2-&gt;privateKey == NULL)) {
        return CRYPT_LMS_CMP_FALSE;
    }
    if (ctx1-&gt;privateKey != NULL &amp;&amp;
        memcmp(ctx1-&gt;privateKey, ctx2-&gt;privateKey, ctx1-&gt;para-&gt;prvKeyLen) != 0) {
        return CRYPT_LMS_CMP_FALSE;
    }

    return CRYPT_SUCCESS;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Unbounded memory allocation in LmOtsComputeQ</div>
                <div class="issue-location">crypto/lms/src/lms_ots.c:151-169</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>static int32_t LmOtsComputeQ(uint8_t *Q, const uint8_t *I, uint32_t q, uint32_t n, const uint8_t *C,
    const uint8_t *message, size_t messageLen, uint32_t w, uint32_t ls)
{
    uint8_t *prefix = BSL_SAL_Malloc(LMS_MESG_PREFIX_LEN(n) + messageLen);
    if (prefix == NULL) {
        return CRYPT_MEM_ALLOC_FAIL;
    }

    (void)memcpy_s(prefix + LMS_MESG_I_OFFSET, LMS_I_LEN, I, LMS_I_LEN);
    LmsPutBigendian(prefix + LMS_MESG_Q_OFFSET, q, LMS_Q_LEN);
    LmsSetD(prefix + LMS_MESG_D_OFFSET, LMS_D_MESG);
    (void)memcpy_s(prefix + LMS_MESG_C_OFFSET, n, C, C);
    (void)memcpy_s(prefix + LMS_MESG_PREFIX_LEN(n), messageLen, message, messageLen);

    LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(n) + messageLen);
    BSL_SAL_FREE(prefix);</pre>
                <div class="problem"><strong>Issue:</strong> The function allocates memory based on messageLen which is provided by the caller. If a user passes a very large message, this triggers a large allocation leading to potential Denial of Service via memory exhaustion. Additionally, buffering the entire message to hash it is inefficient.</div>
                <div class="fix-label">Fix:</div><pre>static int32_t LmOtsComputeQ(uint8_t *Q, const uint8_t *I, uint32_t q, uint32_t n, const uint8_t *C,
    const uint8_t *message, size_t messageLen, uint32_t w, uint32_t ls)
{
    // Enforce maximum message size to prevent DoS
    if (messageLen &gt; LMS_MAX_MESSAGE_SIZE) {
        return CRYPT_INVALID_ARG;
    }

    uint8_t *prefix = BSL_SAL_Malloc(LMS_MESG_PREFIX_LEN(n) + messageLen);
    if (prefix == NULL) {
        return CRYPT_MEM_ALLOC_FAIL;
    }
    // ... rest of function</pre>
            </div>
<div class="issue">
                <div class="issue-title">Performance/DoS risk in LmsGenerateAuthPath regenerates entire Merkle tree</div>
                <div class="issue-location">crypto/lms/src/lms_core.c:150-183</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>int32_t LmsGenerateAuthPath(uint8_t *authPath, const LMS_Para *para,
    const uint8_t *I, const uint8_t *seed, uint32_t q)
{
    uint32_t numLeaves = 1u &lt;&lt; para-&gt;height;

    if (q &gt;= numLeaves) {
        return CRYPT_LMS_INVALID_LEAF_INDEX;
    }

    size_t treeSize = 2 * numLeaves * para-&gt;n;
    uint8_t *tree = BSL_SAL_Calloc(treeSize, 1);
    if (tree == NULL) {
        return CRYPT_MEM_ALLOC_FAIL;
    }

    int32_t ret = LmsComputeLeafNodes(tree, para, I, seed, numLeaves);  // Regenerates ALL leaves
    if (ret != CRYPT_SUCCESS) {
        BSL_SAL_FREE(tree);
        return ret;
    }

    ret = LmsComputeInternalNodes(tree, I, para-&gt;n, numLeaves);  // Regenerates ALL internal nodes
    if (ret != CRYPT_SUCCESS) {
        BSL_SAL_FREE(tree);
        return ret;
    }</pre>
                <div class="problem"><strong>Issue:</strong> LmsSign calls LmsSignWriteSignature, which calls LmsGenerateAuthPath. LmsGenerateAuthPath regenerates the entire Merkle tree (all leaves and internal nodes) for every single signature. For larger tree parameters (e.g., H=20, 1M leaves), this involves millions of hash operations per signature, making signing extremely slow and resource-intensive.</div>
                <div class="fix-label">Fix:</div><pre>/*
 * Add a height restriction check in LmsParaInit or LmsKeyGen:
 */
if (para-&gt;height &gt; 15) {
    // Log warning or return error for performance reasons
    return CRYPT_LMS_INVALID_PARAM;  // or implement a warning mechanism
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">HSS tree and leaf index calculation logic needs verification</div>
                <div class="issue-location">crypto/lms/src/hss_utils.c:343-384</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge evaluate">置信度: 需评估</span>
                </div>
                <pre>int32_t HssCalculateTreeIndices(const HSS_Para *para, uint64_t globalIndex,
    uint64_t treeIndex[HSS_MAX_LEVELS],
    uint32_t leafIndex[HSS_MAX_LEVELS])
{
    // ...
    // Calculate signatures per tree at each level
    // sigsPerTree[i] = product of (2^height) for all levels below i
    uint64_t sigsPerTree[HSS_MAX_LEVELS];
    sigsPerTree[para-&gt;levels - 1] = 1;  // Bottom level: 1 sig per tree

    for (int32_t i = (int32_t)para-&gt;levels - 2; i &gt;= 0; i--) {
        uint32_t childHeight = para-&gt;levelPara[i + 1].height;
        sigsPerTree[i] = sigsPerTree[i + 1] * (1ULL &lt;&lt; childHeight);
    }

    // Calculate tree and leaf indices for each level
    for (uint32_t i = 0; i &lt; para-&gt;levels; i++) {
        // Tree index at level i = globalIndex / sigsPerTree[i]
        treeIndex[i] = globalIndex / sigsPerTree[i];

        // Leaf index at level i = (globalIndex / sigsPerTree[i+1]) % (2^height[i])
        uint32_t height = para-&gt;levelPara[i].height;
        uint64_t maxLeaves = 1ULL &lt;&lt; height;

        if (i == para-&gt;levels - 1) {
            // Bottom level: leaf = globalIndex mod (2^height)
            leafIndex[i] = (uint32_t)(globalIndex % maxLeaves);
        } else {
            // Higher levels: leaf = (globalIndex / sigsPerTree[i+1]) mod (2^height)
            leafIndex[i] = (uint32_t)((globalIndex / sigsPerTree[i + 1]) % maxLeaves);
        }
    }</pre>
                <div class="problem"><strong>Issue:</strong> GEMINI reports potential logic errors in HssCalculateTreeIndices. The calculation uses sigsPerTree[i+1] as divisor for leafIndex[i], which GEMINI claims causes OTS key reuse. However, this requires deeper cryptanalysis to confirm as the HSS specification is complex and the actual behavior depends on how sigsPerTree is computed and used.</div>
                
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Unnecessary memory zeroization after freeing members</div>
                <div class="issue-location">crypto/lms/src/hss_api.c:72-95</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>int32_t CRYPT_HSS_FreeCtx(CRYPT_HSS_Ctx *ctx)
{
    if (ctx == NULL) {
        return CRYPT_SUCCESS;
    }

    if (ctx-&gt;privateKey != NULL) {
        LmsZeroize(ctx-&gt;privateKey, HSS_PRVKEY_LEN);
        BSL_SAL_Free(ctx-&gt;privateKey);
    }

    if (ctx-&gt;publicKey != NULL) {
        BSL_SAL_Free(ctx-&gt;publicKey);
    }

    if (ctx-&gt;para != NULL) {
        LmsZeroize(ctx-&gt;para, sizeof(HSS_Para));
        BSL_SAL_Free(ctx-&gt;para);
    }

    LmsZeroize(ctx, sizeof(CRYPT_HSS_Ctx));  // Unnecessary - ctx will be freed immediately
    BSL_SAL_Free(ctx);
    return CRYPT_SUCCESS;
}</pre>
                <div class="problem"><strong>Issue:</strong> The function CRYPT_HSS_FreeCtx calls LmsZeroize(ctx, sizeof(CRYPT_HSS_Ctx)) after freeing ctx->privateKey, ctx->publicKey, and ctx->para. Since ctx is about to be freed, zeroizing the context structure itself is unnecessary and adds overhead.</div>
                <div class="fix-label">Fix:</div><pre>int32_t CRYPT_HSS_FreeCtx(CRYPT_HSS_Ctx *ctx)
{
    if (ctx == NULL) {
        return CRYPT_SUCCESS;
    }

    if (ctx-&gt;privateKey != NULL) {
        LmsZeroize(ctx-&gt;privateKey, HSS_PRVKEY_LEN);
        BSL_SAL_Free(ctx-&gt;privateKey);
    }

    if (ctx-&gt;publicKey != NULL) {
        BSL_SAL_Free(ctx-&gt;publicKey);
    }

    if (ctx-&gt;para != NULL) {
        LmsZeroize(ctx-&gt;para, sizeof(HSS_Para));
        BSL_SAL_Free(ctx-&gt;para);
    }

    BSL_SAL_Free(ctx);
    return CRYPT_SUCCESS;
}</pre>
            </div>
</div>
</div></body></html>