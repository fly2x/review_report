{
  "context": {
    "owner": "openhitls",
    "repo": "openhitls",
    "pr_id": "992",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 9,
    "critical": 2,
    "high": 0,
    "medium": 4,
    "low": 3
  },
  "issues": [
    {
      "file": "crypto/lms/src/lms_api.c",
      "line": "510",
      "severity": "critical",
      "title": "Missing error code CRYPT_LMS_PAIRWISE_CHECK_FAIL",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The code in lms_api.c uses CRYPT_LMS_PAIRWISE_CHECK_FAIL error code at lines 510, 515, and 529 in the LMSKeyPairCheck function, but this error code is not defined in crypt_errno.h. This will cause compilation errors when HITLS_CRYPTO_LMS_CHECK is enabled.",
      "code": "if (pubLmsType != prvLmsType || pubOtsType != prvOtsType) {\n    return CRYPT_LMS_PAIRWISE_CHECK_FAIL;\n}\n\n// Compare I values\nif (memcmp(pubKey->publicKey + LMS_PUBKEY_I_OFFSET, prvKey->privateKey + LMS_PRVKEY_I_OFFSET, LMS_I_LEN) != 0) {\n    return CRYPT_LMS_PAIRWISE_CHECK_FAIL;\n}\n\nif (memcmp(computedRoot, pubKey->publicKey + LMS_PUBKEY_ROOT_OFFSET, LMS_SHA256_N) != 0) {\n    return CRYPT_LMS_PAIRWISE_CHECK_FAIL;\n}",
      "fix": "// Add to include/crypto/crypt_errno.h after CRYPT_HSS_KEYGEN_FAIL:\n    CRYPT_LMS_PAIRWISE_CHECK_FAIL,               /**< LMS key pair check failed. */\n    CRYPT_HSS_PAIRWISE_CHECK_FAIL,               /**< HSS key pair check failed. */"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "439",
      "severity": "critical",
      "title": "Missing error code CRYPT_HSS_PAIRWISE_CHECK_FAIL",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "The code in hss_api.c uses CRYPT_HSS_PAIRWISE_CHECK_FAIL error code at lines 439, 445, 455, and 471 in the HSS key pair check functions, but this error code is not defined in crypt_errno.h. This will cause compilation errors when HITLS_CRYPTO_HSS_CHECK is enabled.",
      "code": "if (pubLevels != prvKey->para->levels) {\n    return CRYPT_HSS_PAIRWISE_CHECK_FAIL;\n}\n\nif (pubLmsType != prvKey->para->lmsType[0] || pubOtsType != prvKey->para->otsType[0]) {\n    return CRYPT_HSS_PAIRWISE_CHECK_FAIL;\n}\n\nif (memcmp(rootI, pubKey->publicKey + HSS_PUBKEY_I_OFFSET, LMS_I_LEN) != 0) {\n    return CRYPT_HSS_PAIRWISE_CHECK_FAIL;\n}\n\nif (memcmp(computedRoot, pubKey->publicKey + HSS_PUBKEY_ROOT_OFFSET, LMS_SHA256_N) != 0) {\n    return CRYPT_HSS_PAIRWISE_CHECK_FAIL;\n}",
      "fix": "// Add to include/crypto/crypt_errno.h after CRYPT_HSS_KEYGEN_FAIL:\n    CRYPT_LMS_PAIRWISE_CHECK_FAIL,               /**< LMS key pair check failed. */\n    CRYPT_HSS_PAIRWISE_CHECK_FAIL,               /**< HSS key pair check failed. */"
    },
    {
      "file": "crypto/lms/src/lms_hash.c",
      "line": "161",
      "severity": "medium",
      "title": "Seed derivation ignores hash failure",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "LmsSeedDerive calls LmsHash at line 161 but does not check the return value. If the hash operation fails, the seed buffer will contain uninitialized/invalid data, but the function still returns CRYPT_SUCCESS and advances the j counter. This could result in invalid keys or signatures being generated without any error indication.",
      "code": "int32_t LmsSeedDerive(uint8_t *seed, LMS_SeedDerive *derive, bool incrementJ)\n{\n    uint8_t buffer[LMS_PRG_LEN];\n\n    (void)memcpy_s(buffer + LMS_PRG_I_OFFSET, LMS_I_LEN, derive->I, LMS_I_LEN);\n    LmsPutBigendian(buffer + LMS_PRG_Q_OFFSET, derive->q, LMS_Q_LEN);\n    LmsPutBigendian(buffer + LMS_PRG_J_OFFSET, derive->j, LMS_K_LEN);\n    buffer[LMS_PRG_FF_OFFSET] = LMS_PRG_FF_VALUE;\n    (void)memcpy_s(buffer + LMS_PRG_SEED_OFFSET, LMS_SEED_LEN, derive->masterSeed, LMS_SEED_LEN);\n\n    LmsHash(seed, buffer, LMS_PRG_LEN);\n    LmsZeroize(buffer, LMS_PRG_LEN);\n\n    if (incrementJ) {\n        derive->j += 1;\n    }\n    return CRYPT_SUCCESS;\n}",
      "fix": "int32_t LmsSeedDerive(uint8_t *seed, LMS_SeedDerive *derive, bool incrementJ)\n{\n    uint8_t buffer[LMS_PRG_LEN];\n\n    (void)memcpy_s(buffer + LMS_PRG_I_OFFSET, LMS_I_LEN, derive->I, LMS_I_LEN);\n    LmsPutBigendian(buffer + LMS_PRG_Q_OFFSET, derive->q, LMS_Q_LEN);\n    LmsPutBigendian(buffer + LMS_PRG_J_OFFSET, derive->j, LMS_K_LEN);\n    buffer[LMS_PRG_FF_OFFSET] = LMS_PRG_FF_VALUE;\n    (void)memcpy_s(buffer + LMS_PRG_SEED_OFFSET, LMS_SEED_LEN, derive->masterSeed, LMS_SEED_LEN);\n\n    int32_t ret = LmsHash(seed, buffer, LMS_PRG_LEN);\n    LmsZeroize(buffer, LMS_PRG_LEN);\n    if (ret != CRYPT_SUCCESS) {\n        return CRYPT_LMS_HASH_FAIL;\n    }\n\n    if (incrementJ) {\n        derive->j += 1;\n    }\n    return CRYPT_SUCCESS;\n}"
    },
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "172",
      "severity": "medium",
      "title": "LM-OTS Q computation ignores hash failure",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "LmOtsComputeQ calls LmsHash at line 172 but does not check the return value. If the hash operation fails, an invalid Q and checksum will be computed, but the function returns CRYPT_SUCCESS. This could result in invalid signatures being generated without any error indication.",
      "code": "LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(ctx->n) + messageLen);\n    BSL_SAL_FREE(prefix);\n\n    LmsPutBigendian(&Q[ctx->n], LmOtsComputeChecksum(Q, ctx->n, ctx->w, ctx->ls), LMS_CHECKSUM_LEN);\n    return CRYPT_SUCCESS;",
      "fix": "int32_t ret = LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(ctx->n) + messageLen);\n    BSL_SAL_FREE(prefix);\n    if (ret != CRYPT_SUCCESS) {\n        return CRYPT_LMS_HASH_FAIL;\n    }\n\n    LmsPutBigendian(&Q[ctx->n], LmOtsComputeChecksum(Q, ctx->n, ctx->w, ctx->ls), LMS_CHECKSUM_LEN);\n    return CRYPT_SUCCESS;"
    },
    {
      "file": "crypto/lms/src/lms_api.c",
      "line": "118-120",
      "severity": "medium",
      "title": "libCtx field not copied in CRYPT_LMS_DupCtx",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The CRYPT_LMS_DupCtx function does not copy the libCtx field from the source context. The duplicated context will always have libCtx = NULL (from CRYPT_LMS_NewCtx initialization), even if the source context had a valid library context pointer. This can cause issues when the duplicated context is used with provider APIs that rely on libCtx.",
      "code": "ctx->signatureIndex = srcCtx->signatureIndex;\n\n    return ctx;\n}",
      "fix": "ctx->signatureIndex = srcCtx->signatureIndex;\n    ctx->libCtx = srcCtx->libCtx;\n\n    return ctx;\n}"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "121-123",
      "severity": "medium",
      "title": "libCtx field not copied in CRYPT_HSS_DupCtx",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The CRYPT_HSS_DupCtx function does not copy the libCtx field from the source context. The duplicated context will always have libCtx = NULL, even if the source context had a valid library context pointer. This can cause issues when the duplicated context is used with provider APIs that rely on libCtx.",
      "code": "// Copy state\n    newCtx->signatureIndex = srcCtx->signatureIndex;\n\n    return newCtx;\n}",
      "fix": "// Copy state\n    newCtx->signatureIndex = srcCtx->signatureIndex;\n    newCtx->libCtx = srcCtx->libCtx;\n\n    return newCtx;\n}"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "91-92",
      "severity": "low",
      "title": "Context structure not zeroized before free in CRYPT_HSS_FreeCtx",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "Unlike CRYPT_LMS_FreeCtx which zeroizes the ctx structure before freeing (line 73), CRYPT_HSS_FreeCtx does not zeroize the ctx structure before calling BSL_SAL_Free. The ctx structure contains signatureIndex which may be considered sensitive state information. For consistency with LMS and proper secure cleanup, ctx should be zeroized.",
      "code": "if (ctx->para != NULL) {\n        LmsZeroize(ctx->para, sizeof(HSS_Para));\n        BSL_SAL_Free(ctx->para);\n    }\n\n    BSL_SAL_Free(ctx);\n}",
      "fix": "if (ctx->para != NULL) {\n        LmsZeroize(ctx->para, sizeof(HSS_Para));\n        BSL_SAL_Free(ctx->para);\n    }\n\n    LmsZeroize(ctx, sizeof(CRYPT_HSS_Ctx));\n    BSL_SAL_Free(ctx);\n}"
    },
    {
      "file": "crypto/provider/src/cmvp/cmvp_utils/cmvp_selftest_lms.c",
      "line": "45-51",
      "severity": "low",
      "title": "Magic numbers used for control commands instead of defined constants",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The selftest code uses magic numbers 1 and 2 for CRYPT_EAL_PkeyCtrl calls instead of the defined symbolic constants CRYPT_CTRL_LMS_SET_TYPE and CRYPT_CTRL_LMS_SET_OTS_TYPE. Also, magic numbers 5 and 4 are used for lmsType and otsType instead of enum constants. This makes the code harder to maintain and could break if the control command values change.",
      "code": "uint32_t lmsType = 5;  // LMS_SHA256_M32_H5\n    uint32_t otsType = 4;  // LMOTS_SHA256_N32_W8\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, 1, &lmsType, sizeof(lmsType)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, 2, &otsType, sizeof(otsType)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);",
      "fix": "uint32_t lmsType = LMS_SHA256_M32_H5;\n    uint32_t otsType = LMOTS_SHA256_N32_W8;\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, CRYPT_CTRL_LMS_SET_TYPE, &lmsType, sizeof(lmsType)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, CRYPT_CTRL_LMS_SET_OTS_TYPE, &otsType, sizeof(otsType)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);"
    },
    {
      "file": "crypto/provider/src/cmvp/cmvp_utils/cmvp_selftest_hss.c",
      "line": "48-62",
      "severity": "low",
      "title": "Magic numbers used for control commands instead of defined constants",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "The selftest code uses magic numbers 1, 2, and 3 for CRYPT_EAL_PkeyCtrl calls instead of the defined symbolic constants CRYPT_CTRL_HSS_SET_LEVELS, CRYPT_CTRL_HSS_SET_LMS_TYPE, and CRYPT_CTRL_HSS_SET_OTS_TYPE. This makes the code harder to maintain and could break if the control command values change.",
      "code": "GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, 1, &levels, sizeof(levels)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, 2, lmsParams, sizeof(lmsParams)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, 3, otsParams, sizeof(otsParams)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);",
      "fix": "GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, CRYPT_CTRL_HSS_SET_LEVELS, &levels, sizeof(levels)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, CRYPT_CTRL_HSS_SET_LMS_TYPE, lmsParams, sizeof(lmsParams)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);\n    GOTO_ERR_IF_TRUE(CRYPT_EAL_PkeyCtrl(pkey, CRYPT_CTRL_HSS_SET_OTS_TYPE, otsParams, sizeof(otsParams)) != CRYPT_SUCCESS,\n        CRYPT_CMVP_ERR_ALGO_SELFTEST);"
    }
  ]
}