{
  "context": {
    "owner": "openHiTLS",
    "repo": "openhitls",
    "pr_id": "992",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 11,
    "critical": 1,
    "high": 5,
    "medium": 2,
    "low": 3
  },
  "issues": [
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "136",
      "severity": "critical",
      "title": "Ignored return value of LmsHash in LmOtsGeneratePublicKey",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "The return value of `LmsHash` is ignored when generating the public key. If the hash calculation fails (e.g., due to hardware failure or resource exhaustion), the function returns `CRYPT_SUCCESS` but the `publicKey` buffer will contain uninitialized or partial data, leading to a compromised key.",
      "code": "LmsHash(publicKey, buffer, LMS_PBLC_PREFIX_LEN + params.p * params.n);\nBSL_SAL_FREE(buffer);\n\nreturn CRYPT_SUCCESS;",
      "fix": "ret = LmsHash(publicKey, buffer, LMS_PBLC_PREFIX_LEN + params.p * params.n);\nBSL_SAL_FREE(buffer);\n\nreturn ret;"
    },
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "172",
      "severity": "high",
      "title": "Ignored return value of LmsHash in LmOtsComputeQ",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "The return value of `LmsHash` is ignored when computing the message digest `Q`. Failure to compute the hash correctly will result in an invalid signature or verification failure, but the function proceeds as if successful.",
      "code": "LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(ctx->n) + messageLen);\nBSL_SAL_FREE(prefix);\n\nLmsPutBigendian(&Q[ctx->n], LmOtsComputeChecksum(Q, ctx->n, ctx->w, ctx->ls), LMS_CHECKSUM_LEN);\nreturn CRYPT_SUCCESS;",
      "fix": "int32_t ret = LmsHash(Q, prefix, LMS_MESG_PREFIX_LEN(ctx->n) + messageLen);\nBSL_SAL_FREE(prefix);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\nLmsPutBigendian(&Q[ctx->n], LmOtsComputeChecksum(Q, ctx->n, ctx->w, ctx->ls), LMS_CHECKSUM_LEN);\nreturn CRYPT_SUCCESS;"
    },
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "198",
      "severity": "high",
      "title": "Ignored return value of LmsHash in LmOtsSignChains",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "`LmsHash` return value is ignored inside the signature chain generation loop. If any hash step fails, the resulting signature chain `tmp` will be invalid, creating a broken signature.",
      "code": "(void)memcpy_s(iterBuf + LMS_ITER_PREV_OFFSET, ctx->n, tmp, ctx->n);\nLmsHash(tmp, iterBuf, LMS_ITER_LEN(ctx->n));",
      "fix": "(void)memcpy_s(iterBuf + LMS_ITER_PREV_OFFSET, ctx->n, tmp, ctx->n);\nif (LmsHash(tmp, iterBuf, LMS_ITER_LEN(ctx->n)) != CRYPT_SUCCESS) {\n    return CRYPT_LMS_HASH_FAIL;\n}"
    },
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "288",
      "severity": "high",
      "title": "Ignored return value of LmsHash in LmOtsValidateChains",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "`LmsHash` return value is ignored during signature validation chain recomputation. This can lead to incorrect validation results (false positives or false negatives) if the hash function fails.",
      "code": "(void)memcpy_s(iterBuf + LMS_ITER_PREV_OFFSET, ctx->n, tmp, ctx->n);\nLmsHash(tmp, iterBuf, LMS_ITER_LEN(ctx->n));",
      "fix": "(void)memcpy_s(iterBuf + LMS_ITER_PREV_OFFSET, ctx->n, tmp, ctx->n);\nif (LmsHash(tmp, iterBuf, LMS_ITER_LEN(ctx->n)) != CRYPT_SUCCESS) {\n    return CRYPT_LMS_HASH_FAIL;\n}"
    },
    {
      "file": "crypto/lms/src/lms_ots.c",
      "line": "333",
      "severity": "high",
      "title": "Ignored return value of LmsHash in LmOtsValidateSignature",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "The final hash step to compute the public key candidate in `LmOtsValidateSignature` ignores the return value of `LmsHash`. This can cause incorrect signature validation if the hash fails.",
      "code": "LmsHash(computedPubKey, finalBuf, LMS_PBLC_PREFIX_LEN + params.p * params.n);\n\nLmsZeroize(Q, sizeof(Q));\nBSL_SAL_FREE(finalBuf);\n\nreturn CRYPT_SUCCESS;",
      "fix": "int32_t ret2 = LmsHash(computedPubKey, finalBuf, LMS_PBLC_PREFIX_LEN + params.p * params.n);\n\nLmsZeroize(Q, sizeof(Q));\nBSL_SAL_FREE(finalBuf);\n\nreturn ret2;"
    },
    {
      "file": "crypto/lms/src/hss_utils.c",
      "line": "360-362",
      "severity": "high",
      "title": "Wrong height used for HSS tree index calculation",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The loop uses the child height (`para->levelPara[i + 1].height`) instead of the current level height when computing `sigsPerTree[i]`. This miscomputes `treeIndex`/`leafIndex` for non-uniform hierarchies, which can cause LM-OTS key reuse and incorrect capacity tracking. It also lacks overflow checks.",
      "code": "for (int32_t i = (int32_t)para->levels - 2; i >= 0; i--) {\n    uint32_t childHeight = para->levelPara[i + 1].height;\n    sigsPerTree[i] = sigsPerTree[i + 1] * (1ULL << childHeight);\n}",
      "fix": "for (int32_t i = (int32_t)para->levels - 2; i >= 0; i--) {\n    uint32_t height = para->levelPara[i].height;\n    if (height > 63 || sigsPerTree[i + 1] > (UINT64_MAX >> height)) {\n        return CRYPT_HSS_INVALID_PARAM;\n    }\n    sigsPerTree[i] = sigsPerTree[i + 1] * (1ULL << height);\n}"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "373-378",
      "severity": "medium",
      "title": "HSS private-key load leaves stale tree cache",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "After loading a new private key via `CRYPT_HSS_SetPrvKey`, cached Merkle trees from the previous key remain marked valid, so signing can reuse stale trees and produce invalid signatures or key reuse.",
      "code": "int32_t ret = HssDecompressParamSet(ctx->para, compressed);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\nreturn CRYPT_SUCCESS;",
      "fix": "int32_t ret = HssDecompressParamSet(ctx->para, compressed);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\nfor (uint32_t i = 0; i < HSS_MAX_LEVELS; i++) {\n    if (ctx->cachedTrees[i] != NULL) {\n        LmsZeroize(ctx->cachedTrees[i], ctx->cachedTreeSizes[i]);\n        BSL_SAL_Free(ctx->cachedTrees[i]);\n        ctx->cachedTrees[i] = NULL;\n        ctx->cachedTreeSizes[i] = 0;\n    }\n    ctx->treeCacheValid[i] = false;\n}\n\nreturn CRYPT_SUCCESS;"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "191-195",
      "severity": "medium",
      "title": "Levels accepted that key format cannot encode",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The control API allows up to 8 levels (`HSS_MAX_LEVELS`), but the compressed parameter set in the private key only supports 3 levels (`HSS_MAX_COMPRESSED_LEVELS`), so valid configuration can still fail later in keygen or SetPrvKey.",
      "code": "if (levels < HSS_MIN_LEVELS || levels > HSS_MAX_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\nctx->para->levels = levels;",
      "fix": "if (levels < HSS_MIN_LEVELS || levels > HSS_MAX_LEVELS || levels > HSS_MAX_COMPRESSED_LEVELS) {\n    return CRYPT_HSS_INVALID_LEVEL;\n}\nctx->para->levels = levels;"
    },
    {
      "file": "crypto/lms/src/hss_utils.c",
      "line": "284-286",
      "severity": "low",
      "title": "Master seed not cleared on root-seed hash failure",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "On hash failure, the stack buffer containing `masterSeed` is returned without zeroization, leaving sensitive material in memory.",
      "code": "int32_t ret = LmsHash(hash, buffer, HSS_ROOT_SEED_DERIVE_BUF_LEN);\nif (ret != CRYPT_SUCCESS) {\n    return CRYPT_HSS_SEED_DERIVE_FAIL;\n}",
      "fix": "int32_t ret = LmsHash(hash, buffer, HSS_ROOT_SEED_DERIVE_BUF_LEN);\nif (ret != CRYPT_SUCCESS) {\n    LmsZeroize(buffer, sizeof(buffer));\n    LmsZeroize(hash, sizeof(hash));\n    return CRYPT_HSS_SEED_DERIVE_FAIL;\n}"
    },
    {
      "file": "crypto/lms/src/hss_utils.c",
      "line": "294-296",
      "severity": "low",
      "title": "Master seed not cleared on second hash failure",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "On the second hash failure in `HssGenerateRootSeed`, the stack buffer containing `masterSeed` is returned without zeroization, leaving sensitive material in memory.",
      "code": "ret = LmsHash(rootSeed, buffer, HSS_ROOT_SEED_DERIVE_BUF_LEN);\nif (ret != CRYPT_SUCCESS) {\n    return CRYPT_HSS_SEED_DERIVE_FAIL;\n}",
      "fix": "ret = LmsHash(rootSeed, buffer, HSS_ROOT_SEED_DERIVE_BUF_LEN);\nif (ret != CRYPT_SUCCESS) {\n    LmsZeroize(buffer, sizeof(buffer));\n    LmsZeroize(hash, sizeof(hash));\n    return CRYPT_HSS_SEED_DERIVE_FAIL;\n}"
    },
    {
      "file": "crypto/lms/src/hss_api.c",
      "line": "173-177",
      "severity": "low",
      "title": "HSS compare ignores private seed",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "Two different private keys with different master seeds can compare equal if public keys are not set, which can lead to incorrect key matching/caching. The comparison only checks the counter and parameters, not the secret seed.",
      "code": "if (ctx1->privateKey != NULL && ctx2->privateKey != NULL) {\n    // Only compare the counter and parameters, not the secret seed\n    if (memcmp(ctx1->privateKey, ctx2->privateKey, HSS_PRVKEY_SEED_OFFSET) != 0) {\n        return CRYPT_HSS_CMP_FALSE;\n    }\n}",
      "fix": "if (ctx1->privateKey != NULL && ctx2->privateKey != NULL) {\n    if (memcmp(ctx1->privateKey, ctx2->privateKey, HSS_PRVKEY_LEN) != 0) {\n        return CRYPT_HSS_CMP_FALSE;\n    }\n}"
    }
  ]
}