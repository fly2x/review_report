<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/sdf_provider#1 - GEMINI</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/sdf_provider#1 - GEMINI</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title critical">Critical</div>
<div class="issue">
                <div class="issue-title">Buffer overflow vulnerability in LOG_ERROR</div>
                <div class="issue-location">src/log.c:20</div>
                <pre>va_start(args, lpFormat);
    vsprintf(log_buf, lpFormat, args);
    va_end(args);</pre>
                <div class="problem"><strong>Issue:</strong> The function uses `vsprintf` to write to a fixed-size buffer `log_buf` of 1024 bytes. If the formatted log message exceeds this length, it will cause a buffer overflow, which can lead to crashes or arbitrary code execution.</div>
                <div class="fix-label">Fix:</div><pre>va_start(args, lpFormat);
    vsnprintf(log_buf, sizeof(log_buf), lpFormat, args);
    va_end(args);</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Insufficient buffer size for SM2 public key export</div>
                <div class="issue-location">src/sm2_keymgmt.c:421</div>
                <pre>uint8_t pubkey[32] = {0};
    CRYPT_EAL_ProcessFuncCb processCb = NULL;
    void *args = NULL;
    BSL_Param sm2Params[3] = {0};
    int32_t ret = CRYPT_GetPkeyProcessParams_ex(params, &amp;processCb, &amp;args);
    if (ret != CRYPT_SUCCESS) {
        return ret;
    }
    if (ctx-&gt;KeyIndex != 0 || ctx-&gt;PrivateKey != NULL) {
        (void)BSL_PARAM_InitValue(&amp;sm2Params[index], CRYPT_PARAM_EC_PRVKEY, BSL_PARAM_TYPE_OCTETS, prvkey, sizeof(prvkey));
        ret = CRYPT_SM2_GetPrvKeyEx(ctx, sm2Params);
        if (ret != CRYPT_SUCCESS) {
            return ret;
        }
        sm2Params[index].valueLen = sm2Params[index].useLen;
        index++;
    }
    if (ctx-&gt;KeyIndex != 0 || ctx-&gt;PublicKey != NULL) {
        (void)BSL_PARAM_InitValue(&amp;sm2Params[index], CRYPT_PARAM_EC_PUBKEY, BSL_PARAM_TYPE_OCTETS,
            pubkey, sizeof(pubkey));
        ret = CRYPT_SM2_GetPubKeyEx(ctx, sm2Params);</pre>
                <div class="problem"><strong>Issue:</strong> In `CRYPT_SM2_Export`, the `pubkey` buffer is allocated with 32 bytes, but an uncompressed SM2 public key (0x04 || X || Y) requires 65 bytes. `CRYPT_SM2_GetPubKeyEx` (called via `sm2Params`) checks if the buffer is at least 65 bytes and will fail, making public key export impossible.</div>
                <div class="fix-label">Fix:</div><pre>uint8_t prvkey[32] = {0};
    uint8_t pubkey[65] = {0};
    CRYPT_EAL_ProcessFuncCb processCb = NULL;
    void *args = NULL;
    BSL_Param sm2Params[3] = {0};
    int32_t ret = CRYPT_GetPkeyProcessParams_ex(params, &amp;processCb, &amp;args);
    if (ret != CRYPT_SUCCESS) {
        return ret;
    }
    if (ctx-&gt;KeyIndex != 0 || ctx-&gt;PrivateKey != NULL) {
        (void)BSL_PARAM_InitValue(&amp;sm2Params[index], CRYPT_PARAM_EC_PRVKEY, BSL_PARAM_TYPE_OCTETS, prvkey, sizeof(prvkey));
        ret = CRYPT_SM2_GetPrvKeyEx(ctx, sm2Params);
        if (ret != CRYPT_SUCCESS) {
            return ret;
        }
        sm2Params[index].valueLen = sm2Params[index].useLen;
        index++;
    }
    if (ctx-&gt;KeyIndex != 0 || ctx-&gt;PublicKey != NULL) {
        (void)BSL_PARAM_InitValue(&amp;sm2Params[index], CRYPT_PARAM_EC_PUBKEY, BSL_PARAM_TYPE_OCTETS,
            pubkey, sizeof(pubkey));
        ret = CRYPT_SM2_GetPubKeyEx(ctx, sm2Params);</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Memory leak in CRYPT_SM2_Decrypt on error paths</div>
                <div class="issue-location">src/sm2_pkeycipher.c:153</div>
                <pre>// support key index and external key both
    if (ctx-&gt;KeyIndex != 0) {
        ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
                (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
            return CRYPT_SM2_INVALID_PRVKEY;
        }
        ret = SDF_InternalDecrypt_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, pucEncData, out, outlen);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_InternalDecrypt_ECC error, ret = %08x", ret);
            BSL_SAL_Free(pucEncData);
            return CRYPT_SM2_DECRYPT_FAIL;
        }
        ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
            return CRYPT_SM2_INVALID_PRVKEY;
        }
    }</pre>
                <div class="problem"><strong>Issue:</strong> `pucEncData` is allocated at the beginning of `CRYPT_SM2_Decrypt` but is not freed if `SDF_GetPrivateKeyAccessRight` or `SDF_ReleasePrivateKeyAccessRight` fails.</div>
                <div class="fix-label">Fix:</div><pre>// support key index and external key both
    if (ctx-&gt;KeyIndex != 0) {
        ret = SDF_GetPrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex,
                (unsigned char *)DEFAULT_PASS, DEFAULT_PASS_LEN);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_GetPrivateKeyAccessRight error, ret = %08x", ret);
            BSL_SAL_Free(pucEncData);
            return CRYPT_SM2_INVALID_PRVKEY;
        }
        ret = SDF_InternalDecrypt_ECC(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex, pucEncData, out, outlen);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_InternalDecrypt_ECC error, ret = %08x", ret);
            BSL_SAL_Free(pucEncData);
            return CRYPT_SM2_DECRYPT_FAIL;
        }
        ret = SDF_ReleasePrivateKeyAccessRight(ctx-&gt;hSessionHandle, ctx-&gt;KeyIndex);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_ReleasePrivateKeyAccessRight error, ret = %08x", ret);
            BSL_SAL_Free(pucEncData);
            return CRYPT_SM2_INVALID_PRVKEY;
        }
    }</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Resource-heavy context creation (Device/Session leak potential)</div>
                <div class="issue-location">src/rsa_keymgmt.c:21</div>
                <pre>ret = SDF_OpenDevice(&amp;hDeviceHandle);
    if (ret != SDR_OK) {
        LOG_ERROR("SDF_OpenDevice error, ret = %08x", ret);
        BSL_SAL_Free(ctx);
        return NULL;
    }

    ret = SDF_OpenSession(hDeviceHandle, &amp;hSessionHandle);
    if (ret != SDR_OK) {
        LOG_ERROR("SDF_OpenSession error, ret = %08x", ret);
        SDF_CloseDevice(hDeviceHandle);
        BSL_SAL_Free(ctx);
        return NULL;
    }</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_RSA_NewCtxEx` opens a new SDF device handle and a new session for every single RSA context created. This is extremely inefficient and can quickly exhaust the hardware's limit on open devices or sessions. Device handles should ideally be shared or managed at the provider level.</div>
                <div class="fix-label">Fix:</div><pre>/* Implementation should be refactored to manage hDeviceHandle at the Provider context level (src/provider.c) and potentially use a session pool or share sessions across contexts. */</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Potential NULL pointer dereference in DupCtx</div>
                <div class="issue-location">src/rsa_keymgmt.c:512</div>
                <pre>if (ctx-&gt;hDeviceHandle != NULL) {
        ret = SDF_OpenDevice(&amp;newCtx-&gt;hDeviceHandle);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_OpenDevice error, ret = %08x", ret);
            goto ERR;
        }
    }
    if (ctx-&gt;hSessionHandle != NULL) {
        ret = SDF_OpenSession(newCtx-&gt;hDeviceHandle, &amp;newCtx-&gt;hSessionHandle);</pre>
                <div class="problem"><strong>Issue:</strong> In `CRYPT_RSA_DupCtx`, `SDF_OpenSession` is called using `newCtx->hDeviceHandle`. If `ctx->hDeviceHandle` was NULL, `newCtx->hDeviceHandle` remains NULL (from `Calloc`), leading to a NULL pointer dereference in `SDF_OpenSession` if `ctx->hSessionHandle` was non-NULL.</div>
                <div class="fix-label">Fix:</div><pre>if (ctx-&gt;hDeviceHandle != NULL) {
        ret = SDF_OpenDevice(&amp;newCtx-&gt;hDeviceHandle);
        if (ret != SDR_OK) {
            LOG_ERROR("SDF_OpenDevice error, ret = %08x", ret);
            goto ERR;
        }
    }
    if (ctx-&gt;hSessionHandle != NULL &amp;&amp; newCtx-&gt;hDeviceHandle != NULL) {
        ret = SDF_OpenSession(newCtx-&gt;hDeviceHandle, &amp;newCtx-&gt;hSessionHandle);</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Hardcoded default password for private key access</div>
                <div class="issue-location">src/provider.h:9</div>
                <pre>#define DEFAULT_PASS "12345678"
#define DEFAULT_PASS_LEN strlen(DEFAULT_PASS)</pre>
                <div class="problem"><strong>Issue:</strong> `DEFAULT_PASS` is hardcoded as "12345678". This password is used to access private keys in the SDF device. Hardcoding such sensitive information is insecure and should be configurable or provided by the user/application at runtime.</div>
                <div class="fix-label">Fix:</div><pre>/* Remove hardcoded DEFAULT_PASS and implement a mechanism to pass the key password from the application through the provider context or control APIs. */</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">KeyIndex masquerading as private key data</div>
                <div class="issue-location">src/sm2_keymgmt.c:102</div>
                <pre>if (memcmp(prv.data, zero, prv.len - 1) == 0) {
        // data with leading 0x00, use it as KeyIndex
        ctx-&gt;KeyIndex = prv.data[prv.len - 1];
    }</pre>
                <div class="problem"><strong>Issue:</strong> If the provided private key data consists of zeros except for the last byte, it is interpreted as a `KeyIndex`. When exporting this key back, `CRYPT_SM2_GetPrvKeyEx` returns this "fake" private key. This can lead to security issues or interoperability failures if this key is imported into a system that expects real private key bytes.</div>
                <div class="fix-label">Fix:</div><pre>/* Use a separate parameter type (e.g. CRYPT_PARAM_KEY_INDEX) to specify hardware key indices instead of overloading the private key buffer. */</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Use of thread-unsafe localtime function</div>
                <div class="issue-location">src/log.c:24</div>
                <pre>time(&amp;timep);
    p = localtime(&amp;timep);</pre>
                <div class="problem"><strong>Issue:</strong> `localtime` returns a pointer to a static structure which is shared among all threads. In a multi-threaded environment, this can lead to race conditions where the timestamp in the log is corrupted.</div>
                <div class="fix-label">Fix:</div><pre>struct tm tm_res;
    time(&amp;timep);
    p = localtime_r(&amp;timep, &amp;tm_res);</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Missing NULL checks for SDF handles in FreeCtx</div>
                <div class="issue-location">src/rsa_keymgmt.c:472</div>
                <pre>BSL_SAL_Free(ctx-&gt;e);
    BSL_SAL_Free(ctx-&gt;label.data);
    SDF_CloseSession(ctx-&gt;hSessionHandle);
    SDF_CloseDevice(ctx-&gt;hDeviceHandle);
    BSL_SAL_Free(ctx);</pre>
                <div class="problem"><strong>Issue:</strong> `SDF_CloseSession` and `SDF_CloseDevice` are called without checking if the handles are valid (non-NULL). Depending on the SDF library implementation, passing a NULL handle might cause a crash.</div>
                <div class="fix-label">Fix:</div><pre>BSL_SAL_Free(ctx-&gt;e);
    BSL_SAL_Free(ctx-&gt;label.data);
    if (ctx-&gt;hSessionHandle != NULL) {
        SDF_CloseSession(ctx-&gt;hSessionHandle);
    }
    if (ctx-&gt;hDeviceHandle != NULL) {
        SDF_CloseDevice(ctx-&gt;hDeviceHandle);
    }
    BSL_SAL_Free(ctx);</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Inefficient random number generation for RSA padding</div>
                <div class="issue-location">src/rsa_padding.c:686</div>
                <pre>do {
            // no zero
            ret = SDF_GenerateRandom(ctx-&gt;hSessionHandle, 1, ps + i);
            if (ret != SDR_OK) {
                LOG_ERROR("SDF_GenerateRandom error, ret = %08x", ret);
                return CRYPT_EAL_ERR_RAND_NO_WORKING;
            }
        } while (*(ps + i) == 0);</pre>
                <div class="problem"><strong>Issue:</strong> In `CRYPT_RSA_SetPkcsV15Type2_ex`, if a byte generated by `SDF_GenerateRandom` is zero, it enters a `do-while` loop that calls `SDF_GenerateRandom` again for just 1 byte. Frequent small calls to hardware random number generators are typically inefficient.</div>
                <div class="fix-label">Fix:</div><pre>/* It is more efficient to generate a larger block of random bytes and filter out zeros, or use a local PRNG seeded by the hardware RNG. */</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
</div></body></html>