<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/openhitls#1004</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/openhitls - PR #1004</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">12</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">1</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">3</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">5</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">3</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title critical">Critical</div>
<div class="issue">
                <div class="issue-title">Use-after-free in RegisterFd when event allocation fails</div>
                <div class="issue-location">bsl/async/src/async_notify.c:146-162</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>newFd-&gt;next = ctx-&gt;fds;
ctx-&gt;fds = newFd;

if (ctx-&gt;fdChangeList != NULL) {
    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));
    if (event == NULL) {
        BSL_SAL_FREE(newFd);  // ctx-&gt;fds still points to freed newFd
        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);
        return BSL_MALLOC_FAIL;
    }
    event-&gt;fd = fd;
    event-&gt;type = ASYNC_EVENT_ADD;
    if (BSL_LIST_AddElement(ctx-&gt;fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {
        BSL_SAL_FREE(event);
        BSL_SAL_FREE(newFd);  // ctx-&gt;fds still points to freed newFd
        return BSL_ASYNC_ERR;
    }
}</pre>
                <div class="problem"><strong>Issue:</strong> The newFd node is linked into ctx->fds (lines 146-147) before attempting to create and add the change event. If event allocation (line 150) or BSL_LIST_AddElement (line 158) fails, newFd is freed (lines 152, 160) but ctx->fds still points to the freed memory. This leaves a dangling pointer in the linked list, causing use-after-free or corruption on subsequent list traversals.</div>
                <div class="fix-label">Fix:</div><pre>if (ctx-&gt;fdChangeList != NULL) {
    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));
    if (event == NULL) {
        BSL_SAL_FREE(newFd);
        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);
        return BSL_MALLOC_FAIL;
    }
    event-&gt;fd = fd;
    event-&gt;type = ASYNC_EVENT_ADD;
    if (BSL_LIST_AddElement(ctx-&gt;fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {
        BSL_SAL_FREE(event);
        BSL_SAL_FREE(newFd);
        return BSL_ASYNC_ERR;
    }
}

// Only insert into list after all allocations succeed
newFd-&gt;next = ctx-&gt;fds;
ctx-&gt;fds = newFd;</pre>
            </div>
</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Race condition in BSL_ASYNC_ScheduleNew due to local lock</div>
                <div class="issue-location">bsl/async/src/async.c:483-489</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>BSL_SAL_ThreadLockHandle scheduleNewLock = NULL;
int32_t ret = BSL_SAL_ThreadLockNew(&amp;scheduleNewLock);
if (ret != BSL_SUCCESS) {
    UnlockAndFree(scheduleNewLock);
    scheduleNewLock = NULL;
    return ret;
}</pre>
                <div class="problem"><strong>Issue:</strong> BSL_ASYNC_ScheduleNew creates a new local lock on each call (line 484), then acquires it (line 494). Since each thread creates its own local lock instance, multiple threads calling this function concurrently will each hold different locks, providing no synchronization. This can lead to multiple scheduler initializations, memory leaks, and race conditions on the global g_schedule. Additionally, if BSL_SAL_ThreadLockNew fails, it calls UnlockAndFree on an undefined lock handle.</div>
                <div class="fix-label">Fix:</div><pre>// Use a static lock for proper synchronization across threads
static BSL_SAL_ThreadLockHandle g_scheduleInitLock = NULL;
static bool g_lockInitialized = false;

int32_t BSL_ASYNC_ScheduleNew(const struct ScheduleAttr *scheAttr)
{
    if (ScheduleGet() != NULL) {
        return BSL_SUCCESS;
    }

    // Initialize the global lock once (could use pthread_once or similar)
    if (!g_lockInitialized) {
        int32_t ret = BSL_SAL_ThreadLockNew(&amp;g_scheduleInitLock);
        if (ret != BSL_SUCCESS) {
            return ret;
        }
        g_lockInitialized = true;
    }

    BSL_SAL_ThreadWriteLock(g_scheduleInitLock);
    
    // Re-check after acquiring lock
    if (ScheduleGet() != NULL) {
        BSL_SAL_ThreadUnlock(g_scheduleInitLock);
        return BSL_SUCCESS;
    }
    
    // ... rest of initialization</pre>
            </div>
<div class="issue">
                <div class="issue-title">Struct copy overwrites caller's job pointer contents</div>
                <div class="issue-location">bsl/async/src/async.c:658</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>if (status == ASYNC_JOB_PAUSING) {
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start job enter the [pausing] branch.", 0, 0, 0, 0);
    *job = *ctx-&gt;currjob;
    ctx-&gt;currjob-&gt;status = ASYNC_JOB_PAUSED;
    ctx-&gt;currjob = NULL;
    return BSL_ASYNC_PAUSE;
}</pre>
                <div class="problem"><strong>Issue:</strong> In BSL_ASYNC_Start, when status is ASYNC_JOB_PAUSING (line 655), the code performs `*job = *ctx->currjob` which copies the entire Coroutine struct by value to the caller's pointer location. This overwrites the caller's job struct. If the caller later calls BSL_ASYNC_Free on the job, it may double-free resources or corrupt memory since both the original and the copy have pointers to the same resources (stack, args, notifyctx).</div>
                <div class="fix-label">Fix:</div><pre>if (status == ASYNC_JOB_PAUSING) {
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start job enter the [pausing] branch.", 0, 0, 0, 0);
    ctx-&gt;currjob-&gt;status = ASYNC_JOB_PAUSED;
    ctx-&gt;currjob = NULL;
    return BSL_ASYNC_PAUSE;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">BSL_ASYNC_Free destroys thread-local context breaking other coroutines</div>
                <div class="issue-location">bsl/async/src/async.c:704-706</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>void BSL_ASYNC_Free(HITLS_Coroutine *job)
{
    AsyncCtxFree();
    if (job == NULL) {
        return;
    }
    AsyncReleaseJob(job);
}</pre>
                <div class="problem"><strong>Issue:</strong> BSL_ASYNC_Free unconditionally calls AsyncCtxFree(), which frees the thread-local AsyncCtx (g_coroutineCtxKey). If called while other coroutines are active on the same thread, this destroys the shared dispatcher context, causing subsequent coroutine switches to crash or fail. The thread-local context should only be freed when the thread exits or via explicit cleanup.</div>
                <div class="fix-label">Fix:</div><pre>void BSL_ASYNC_Free(HITLS_Coroutine *job)
{
    // Do not free the thread-local context here.
    // It should be freed only when the thread exits or via explicit cleanup API.
    // AsyncCtxFree();
    if (job == NULL) {
        return;
    }
    AsyncReleaseJob(job);
}</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Missing status handling causes infinite loop</div>
                <div class="issue-location">bsl/async/src/async.c:637-670</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>while (true) {
    int status = ctx-&gt;currjob-&gt;status;
    if (status == ASYNC_JOB_STOPPING) { ... return BSL_ASYNC_FINISH; }
    if (status == ASYNC_JOB_READY) { ... continue; }
    if (status == ASYNC_JOB_PAUSING) { ... return BSL_ASYNC_PAUSE; }
    if (status == ASYNC_JOB_PAUSED) { ... continue; }
}
// Unreachable code
AsyncReleaseJob(ctx-&gt;currjob);
ctx-&gt;currjob = NULL;
return BSL_ASYNC_ERR;</pre>
                <div class="problem"><strong>Issue:</strong> The while(true) loop in BSL_ASYNC_Start handles ASYNC_JOB_STOPPING, ASYNC_JOB_READY, ASYNC_JOB_PAUSING, and ASYNC_JOB_PAUSED states. If status is ASYNC_JOB_RUNNING or any unexpected value, no branch is taken, the loop never exits, and the code spins forever. The unreachable code after the loop (lines 672-674) also indicates this logic error.</div>
                <div class="fix-label">Fix:</div><pre>while (true) {
    int status = ctx-&gt;currjob-&gt;status;
    if (status == ASYNC_JOB_STOPPING) {
        *ret = ctx-&gt;currjob-&gt;coError;
        ctx-&gt;currjob = NULL;
        return BSL_ASYNC_FINISH;
    }
    if (status == ASYNC_JOB_READY) {
        ctx-&gt;currjob-&gt;status = ASYNC_JOB_RUNNING;
        AsyncSwapcontext(&amp;ctx-&gt;dispatcher, &amp;ctx-&gt;currjob-&gt;ctx);
        continue;
    }
    if (status == ASYNC_JOB_PAUSING) {
        ctx-&gt;currjob-&gt;status = ASYNC_JOB_PAUSED;
        ctx-&gt;currjob = NULL;
        return BSL_ASYNC_PAUSE;
    }
    if (status == ASYNC_JOB_PAUSED) {
        ctx-&gt;currjob = job;
        AsyncSwapcontext(&amp;ctx-&gt;dispatcher, &amp;ctx-&gt;currjob-&gt;ctx);
        continue;
    }
    // Handle unexpected status - prevents infinite loop
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_ERR);
    AsyncReleaseJob(ctx-&gt;currjob);
    ctx-&gt;currjob = NULL;
    return BSL_ASYNC_ERR;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Coroutine ID generation never updates the shared counter</div>
                <div class="issue-location">bsl/async/src/async.c:108-122</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>static int32_t CoroutineNewid(void)
{
    int32_t ref = 0;
    int32_t ret = 0;
    BSL_SAL_RefCount threadStartNum = {
        .count = ScheduleGet()-&gt;idGen
    };
    ret = BSL_SAL_AtomicUpReferences(&amp;threadStartNum, &amp;ref);
    if (ret != BSL_SUCCESS) {
        BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05101, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                              "croutine new id in atomic mode faile.", 0, 0, 0, 0);
    }
    return ref;
}</pre>
                <div class="problem"><strong>Issue:</strong> CoroutineNewid() creates a local BSL_SAL_RefCount struct initialized with a copy of ScheduleGet()->idGen (line 113-115). The atomic increment operates on this local copy, not the actual idGen field in the scheduler. This means the shared counter is never updated, and all coroutines will get duplicate IDs. Additionally, this is not thread-safe.</div>
                <div class="fix-label">Fix:</div><pre>// In async_local.h, change idGen to BSL_SAL_RefCount type:
struct AsyncSchedule {
    int32_t state;
    BSL_SAL_RefCount idGen;  // Changed from int32_t
    // ...
};

// In async.c, update ScheduleAlloc:
static struct AsyncSchedule *ScheduleAlloc(void)
{
    struct AsyncSchedule *schedule = (struct AsyncSchedule *)BSL_SAL_Calloc(1, sizeof(struct AsyncSchedule));
    if (schedule == NULL) { ... }
    (void)BSL_SAL_ReferencesInit(&amp;schedule-&gt;idGen);
    schedule-&gt;state = SCHEDULE_INIT;
    return schedule;
}

// Fix CoroutineNewid to use the actual scheduler's idGen:
static int32_t CoroutineNewid(void)
{
    int32_t ref = 0;
    struct AsyncSchedule *schedule = ScheduleGet();
    if (schedule == NULL) {
        return 0;
    }
    (void)BSL_SAL_AtomicUpReferences(&amp;schedule-&gt;idGen, &amp;ref);
    return ref;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Swapcontext failure check is inverted</div>
                <div class="issue-location">bsl/async/src/async.c:555</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>job-&gt;status = ASYNC_JOB_STOPPING;
if (AsyncSwapcontext(&amp;job-&gt;ctx, &amp;ctx-&gt;dispatcher) == 0) {
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_UCONTEXT_SWAP_FAIL);
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05103, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start run func swap context fail.", 0, 0, 0, 0);
}</pre>
                <div class="problem"><strong>Issue:</strong> In AsyncStartRunFunc, AsyncSwapcontext returns 0 (BSL_SUCCESS) on success. However, the code logs an error when the return value is 0 (success case) and ignores actual failures (non-zero returns). This means real swap failures go unhandled.</div>
                <div class="fix-label">Fix:</div><pre>job-&gt;status = ASYNC_JOB_STOPPING;
int32_t swapRet = AsyncSwapcontext(&amp;job-&gt;ctx, &amp;ctx-&gt;dispatcher);
if (swapRet != 0) {
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_UCONTEXT_SWAP_FAIL);
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05103, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start run func swap context fail.", 0, 0, 0, 0);
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">LookupFd and CollectAllFds return deleted FDs</div>
                <div class="issue-location">bsl/async/src/async_notify.c:174-184</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, CODEX</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>HITLS_ASYNC_NotifyFd *curr = ctx-&gt;fds;
while (curr != NULL) {
    if (curr-&gt;key == key) {  // No check for curr-&gt;del
        *fd = curr-&gt;fd;
        if (customData != NULL) {
            *customData = curr-&gt;customData;
        }
        return BSL_SUCCESS;
    }
    curr = curr-&gt;next;
}</pre>
                <div class="problem"><strong>Issue:</strong> BSL_NOTIFY_CTX_LookupFd does not check the `del` flag when searching for FDs by key. It may return an FD that has been marked for deletion (curr->del == true), which leads to the caller using a stale/invalid file descriptor. Similarly, BSL_NOTIFY_CTX_CollectAllFds counts and copies all FDs including deleted ones.</div>
                <div class="fix-label">Fix:</div><pre>HITLS_ASYNC_NotifyFd *curr = ctx-&gt;fds;
while (curr != NULL) {
    if (curr-&gt;key == key &amp;&amp; !curr-&gt;del) {
        *fd = curr-&gt;fd;
        if (customData != NULL) {
            *customData = curr-&gt;customData;
        }
        return BSL_SUCCESS;
    }
    curr = curr-&gt;next;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">PollFdChanges never consumes the change list</div>
                <div class="issue-location">bsl/async/src/async_notify.c:218-260</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>*addedCount = addTotal;
*removedCount = delTotal;

return BSL_SUCCESS;
// Missing: cleanup of consumed events</pre>
                <div class="problem"><strong>Issue:</strong> BSL_NOTIFY_CTX_PollFdChanges iterates through fdChangeList and reports added/removed FDs, but never removes events from the list. This means the same events are returned on every poll call, and the list grows unbounded. The function should consume (clear) the events after reporting them, similar to how AsyncCleanupFdChanges works during yield.</div>
                <div class="fix-label">Fix:</div><pre>*addedCount = addTotal;
*removedCount = delTotal;

// Consume the change list after reporting
if (addedFds != NULL || removedFds != NULL) {
    AsyncCleanupFdChanges(ctx);
}

return BSL_SUCCESS;</pre>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Static variable g_pageSize declared in header creates per-TU copies</div>
                <div class="issue-location">bsl/async/include/async_local.h:110-118</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>static size_t g_pageSize;

static inline size_t GetPageSize(void)
{
    if (g_pageSize == 0) {
        g_pageSize = (size_t)SAL_GetPageSize();
    }
    return g_pageSize;
}</pre>
                <div class="problem"><strong>Issue:</strong> The g_pageSize static variable is declared with file-scope static storage in a header file. When this header is included in multiple translation units, each unit gets its own separate copy of g_pageSize. This is wasteful and could lead to redundant SAL_GetPageSize calls. Additionally, GetPageSize() has a race condition where multiple threads could simultaneously see g_pageSize as 0.</div>
                <div class="fix-label">Fix:</div><pre>// In async_local.h - declare extern
extern size_t g_pageSize;

static inline size_t GetPageSize(void)
{
    if (g_pageSize == 0) {
        g_pageSize = (size_t)SAL_GetPageSize();
    }
    return g_pageSize;
}

// In async.c - define the variable
size_t g_pageSize = 0;</pre>
            </div>
<div class="issue">
                <div class="issue-title">RemoveFd path skips cleanup callback for newly-added FDs</div>
                <div class="issue-location">bsl/async/src/async_notify.c:314-319</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>static bool NotifyCtxDetachFdNode(HITLS_NOTIFY_Ctx *ctx, HITLS_ASYNC_NotifyFd *target)
{
    // ...
    if (*pp == target) {
        *pp = target-&gt;next;
        BSL_SAL_FREE(target);  // Cleanup callback not called
        return true;
    }
    // ...
}</pre>
                <div class="problem"><strong>Issue:</strong> When a newly-added FD is removed before being polled, NotifyCtxDetachFdNode is called which frees the node directly without invoking the cleanup callback. This could leak resources (e.g., file descriptors) that the cleanup callback was meant to release.</div>
                <div class="fix-label">Fix:</div><pre>static bool NotifyCtxDetachFdNode(HITLS_NOTIFY_Ctx *ctx, HITLS_ASYNC_NotifyFd *target)
{
    if (ctx == NULL || target == NULL) {
        return false;
    }

    HITLS_ASYNC_NotifyFd **pp = &amp;ctx-&gt;fds;
    while (*pp != NULL) {
        if (*pp == target) {
            if (target-&gt;cleanup != NULL) {
                target-&gt;cleanup(ctx, target-&gt;fd);
            }
            *pp = target-&gt;next;
            BSL_SAL_FREE(target);
            return true;
        }
        pp = &amp;(*pp)-&gt;next;
    }

    return false;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Test assertion is logically inconsistent</div>
                <div class="issue-location">testcode/sdv/testcase/bsl/async/test_suite_sdv_async_notify_ctx.c:530-532</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ASSERT_EQ(addedCount, 0);
ASSERT_EQ(removedCount, 0);
ASSERT_EQ(removedFds[0], fd);  // fd is 10, but removedFds[0] is 0</pre>
                <div class="problem"><strong>Issue:</strong> The test UT_BSL_NOTIFY_CTX_POLL_REMOVED_FD_TC001 expects removedCount to be 0 (line 531), but then asserts that removedFds[0] equals fd (line 532). If removedCount is 0, checking removedFds[0] is meaningless - the array was zero-initialized, so removedFds[0] is 0, not fd (10). This test is logically inconsistent.</div>
                <div class="fix-label">Fix:</div><pre>ASSERT_EQ(addedCount, 0);
// Either expect removedCount to be 1 and check removedFds[0]:
ASSERT_EQ(removedCount, 1);
ASSERT_EQ(removedFds[0], fd);
// Or remove the removedFds[0] check if removedCount should be 0</pre>
            </div>
</div>
</div></body></html>