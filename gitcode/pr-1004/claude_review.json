[
  {
    "source": "claude",
    "file": "bsl/async/src/async.c",
    "line": "658",
    "severity": "high",
    "title": "Struct copy overwrites caller's job pointer contents",
    "problem": "In BSL_ASYNC_Start, when status is ASYNC_JOB_PAUSING, the code performs `*job = *ctx->currjob` which copies the entire Coroutine struct by value to the caller's pointer location. This is problematic because: 1) The caller passes a pointer to their job struct, and this overwrites their entire struct with a copy; 2) If the caller later calls BSL_ASYNC_Free on the job, it may double-free resources or corrupt memory since both the original and the copy may have pointers to the same resources (stack, args, notifyctx).",
    "code": "if (status == ASYNC_JOB_PAUSING) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,\n                          \"async start job enter the [pausing] branch.\", 0, 0, 0, 0);\n    *job = *ctx->currjob;\n    ctx->currjob->status = ASYNC_JOB_PAUSED;\n    ctx->currjob = NULL;\n    return BSL_ASYNC_PAUSE;\n}",
    "fix": "if (status == ASYNC_JOB_PAUSING) {\n    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,\n                          \"async start job enter the [pausing] branch.\", 0, 0, 0, 0);\n    ctx->currjob->status = ASYNC_JOB_PAUSED;\n    ctx->currjob = NULL;\n    return BSL_ASYNC_PAUSE;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async.c",
    "line": "550-553",
    "severity": "high",
    "title": "Null pointer dereference in AsyncStartRunFunc",
    "problem": "In AsyncStartRunFunc, ctx is retrieved from AsyncGetCtx() without a null check. Then ctx->currjob is accessed without validation. If ctx is NULL or ctx->currjob is NULL, this will cause a crash. This function is called as the entry point for coroutines, so if the context is not properly set up, it will dereference null pointers.",
    "code": "void AsyncStartRunFunc(void)\n{\n    HITLS_Coroutine *job = NULL;\n    AsyncCtx *ctx = AsyncGetCtx();\n    while (true) {\n        job = ctx->currjob;\n        job->coError = job->func(job->args);",
    "fix": "void AsyncStartRunFunc(void)\n{\n    HITLS_Coroutine *job = NULL;\n    AsyncCtx *ctx = AsyncGetCtx();\n    if (ctx == NULL) {\n        BSL_ERR_PUSH_ERROR(BSL_ASYNC_JOB_NOT_EXIST);\n        return;\n    }\n    while (true) {\n        job = ctx->currjob;\n        if (job == NULL) {\n            BSL_ERR_PUSH_ERROR(BSL_ASYNC_JOB_NOT_EXIST);\n            return;\n        }\n        job->coError = job->func(job->args);"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async.c",
    "line": "672-674",
    "severity": "medium",
    "title": "Unreachable code after infinite while loop",
    "problem": "The code after the `while (true)` loop (lines 672-674) is unreachable. The loop only exits via return statements in the status checks. This dead code could indicate a logic error where certain status values are not handled, leading to an infinite loop instead of proper cleanup and return.",
    "code": "while (true) {\n    int status = ctx->currjob->status;\n    if (status == ASYNC_JOB_STOPPING) {\n        // ... returns\n    }\n    if (status == ASYNC_JOB_READY) {\n        // ... continues\n    }\n    if (status == ASYNC_JOB_PAUSING) {\n        // ... returns\n    }\n    if (status == ASYNC_JOB_PAUSED) {\n        // ... continues\n    }\n}\n\nAsyncReleaseJob(ctx->currjob);  // Unreachable\nctx->currjob = NULL;\nreturn BSL_ASYNC_ERR;",
    "fix": "while (true) {\n    int status = ctx->currjob->status;\n    if (status == ASYNC_JOB_STOPPING) {\n        *ret = ctx->currjob->coError;\n        ctx->currjob = NULL;\n        return BSL_ASYNC_FINISH;\n    }\n\n    if (status == ASYNC_JOB_READY) {\n        ctx->currjob->status = ASYNC_JOB_RUNNING;\n        AsyncSwapcontext(&ctx->dispatcher, &ctx->currjob->ctx);\n        continue;\n    }\n\n    if (status == ASYNC_JOB_PAUSING) {\n        ctx->currjob->status = ASYNC_JOB_PAUSED;\n        ctx->currjob = NULL;\n        return BSL_ASYNC_PAUSE;\n    }\n\n    if (status == ASYNC_JOB_PAUSED) {\n        ctx->currjob = job;\n        AsyncSwapcontext(&ctx->dispatcher, &ctx->currjob->ctx);\n        continue;\n    }\n\n    // Handle unexpected status - prevents infinite loop\n    BSL_ERR_PUSH_ERROR(BSL_ASYNC_ERR);\n    AsyncReleaseJob(ctx->currjob);\n    ctx->currjob = NULL;\n    return BSL_ASYNC_ERR;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async_notify.c",
    "line": "146-161",
    "severity": "medium",
    "title": "FD list corrupted when event allocation fails after node insertion",
    "problem": "In BSL_NOTIFY_CTX_RegisterFd, the newFd node is inserted into the ctx->fds linked list before attempting to allocate and add the event to fdChangeList. If the event allocation or list add fails, the newFd is freed but it has already been inserted into ctx->fds. This leaves ctx->fds pointing to freed memory, causing use-after-free on subsequent list traversals.",
    "code": "newFd->next = ctx->fds;\nctx->fds = newFd;\n\nif (ctx->fdChangeList != NULL) {\n    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));\n    if (event == NULL) {\n        BSL_SAL_FREE(newFd);  // ctx->fds still points to freed newFd\n        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);\n        return BSL_MALLOC_FAIL;\n    }\n    event->fd = fd;\n    event->type = ASYNC_EVENT_ADD;\n    if (BSL_LIST_AddElement(ctx->fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {\n        BSL_SAL_FREE(event);\n        BSL_SAL_FREE(newFd);  // ctx->fds still points to freed newFd\n        return BSL_ASYNC_ERR;\n    }\n}",
    "fix": "if (ctx->fdChangeList != NULL) {\n    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));\n    if (event == NULL) {\n        BSL_SAL_FREE(newFd);\n        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);\n        return BSL_MALLOC_FAIL;\n    }\n    event->fd = fd;\n    event->type = ASYNC_EVENT_ADD;\n    if (BSL_LIST_AddElement(ctx->fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {\n        BSL_SAL_FREE(event);\n        BSL_SAL_FREE(newFd);\n        return BSL_ASYNC_ERR;\n    }\n}\n\n// Only insert into list after all allocations succeed\nnewFd->next = ctx->fds;\nctx->fds = newFd;"
  },
  {
    "source": "claude",
    "file": "bsl/async/include/async_local.h",
    "line": "107-113",
    "severity": "medium",
    "title": "Static variable g_pageSize may have inconsistent values in multi-threaded context",
    "problem": "The g_pageSize static variable is declared with file-scope static storage in a header file. When this header is included in multiple translation units, each unit gets its own separate copy of g_pageSize. Additionally, the GetPageSize() function has a race condition: multiple threads could simultaneously read g_pageSize as 0 and call SAL_GetPageSize(), leading to redundant calls. While not a correctness bug, declaring static variables in headers is poor practice.",
    "code": "static size_t g_pageSize;\n\nstatic inline size_t GetPageSize(void)\n{\n    if (g_pageSize == 0) {\n        g_pageSize = (size_t)SAL_GetPageSize();\n    }\n    return g_pageSize;\n}",
    "fix": "// In async_local.h - declare extern\nextern size_t g_pageSize;\n\nstatic inline size_t GetPageSize(void)\n{\n    if (g_pageSize == 0) {\n        g_pageSize = (size_t)SAL_GetPageSize();\n    }\n    return g_pageSize;\n}\n\n// In async.c - define the variable\nsize_t g_pageSize = 0;"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async.c",
    "line": "475-490",
    "severity": "medium",
    "title": "Race condition in BSL_ASYNC_ScheduleNew with double-check pattern",
    "problem": "BSL_ASYNC_ScheduleNew checks if ScheduleGet() != NULL at line 475 without holding a lock. Then it creates a new lock at line 480 and acquires it at line 491. However, another thread could have completed the same function between the initial check and the lock acquisition, resulting in double initialization. The lock created on each call doesn't protect against concurrent calls from different threads.",
    "code": "int32_t BSL_ASYNC_ScheduleNew(const struct ScheduleAttr *scheAttr)\n{\n    if (ScheduleGet() != NULL) {\n        BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05099, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,\n                              \"schedule new previously.\", 0, 0, 0, 0);\n        return BSL_SUCCESS;\n    }\n\n    BSL_SAL_ThreadLockHandle scheduleNewLock = NULL;\n    int32_t ret = BSL_SAL_ThreadLockNew(&scheduleNewLock);\n    if (ret != BSL_SUCCESS) {\n        UnlockAndFree(scheduleNewLock);\n        scheduleNewLock = NULL;\n        return ret;\n    }\n\n    int32_t err = BSL_SUCCESS;\n    struct AsyncSchedule *schedule = NULL;\n    do {\n        BSL_SAL_ThreadWriteLock(scheduleNewLock);",
    "fix": "static BSL_SAL_ThreadLockHandle g_scheduleInitLock = NULL;\n\nint32_t BSL_ASYNC_ScheduleNew(const struct ScheduleAttr *scheAttr)\n{\n    // Double-checked locking with a global lock\n    if (ScheduleGet() != NULL) {\n        return BSL_SUCCESS;\n    }\n\n    // Use a static/global lock for thread-safe initialization\n    if (g_scheduleInitLock == NULL) {\n        int32_t ret = BSL_SAL_ThreadLockNew(&g_scheduleInitLock);\n        if (ret != BSL_SUCCESS) {\n            return ret;\n        }\n    }\n\n    BSL_SAL_ThreadWriteLock(g_scheduleInitLock);\n    \n    // Re-check after acquiring lock\n    if (ScheduleGet() != NULL) {\n        BSL_SAL_ThreadUnlock(g_scheduleInitLock);\n        return BSL_SUCCESS;\n    }\n    \n    // ... rest of initialization"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async_notify.c",
    "line": "118-133",
    "severity": "medium",
    "title": "Key update in BSL_NOTIFY_CTX_RegisterFd skips event tracking",
    "problem": "When updating an existing FD entry by key, the function updates the fd value but does not add an event to fdChangeList. This means callers using BSL_NOTIFY_CTX_PollFdChanges won't be notified that the FD was changed, potentially causing them to poll on an old file descriptor.",
    "code": "HITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    if (curr->key == key) {\n        if (curr->cleanup != NULL) {\n            curr->cleanup(ctx, curr->fd);\n        }\n        curr->fd = fd;\n        curr->customData = customData;\n        curr->cleanup = cleanup;\n        return BSL_SUCCESS;  // No event added for the change\n    }\n    curr = curr->next;\n}",
    "fix": "HITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    if (curr->key == key) {\n        int oldFd = curr->fd;\n        if (curr->cleanup != NULL) {\n            curr->cleanup(ctx, curr->fd);\n        }\n        curr->fd = fd;\n        curr->customData = customData;\n        curr->cleanup = cleanup;\n        \n        // Track the FD change if FD value changed\n        if (ctx->fdChangeList != NULL && oldFd != fd) {\n            // Add DEL event for old FD\n            struct AsyncFdEvent *delEvent = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));\n            if (delEvent != NULL) {\n                delEvent->fd = oldFd;\n                delEvent->type = ASYNC_EVENT_DEL;\n                (void)BSL_LIST_AddElement(ctx->fdChangeList, delEvent, BSL_LIST_POS_END);\n            }\n            // Add ADD event for new FD\n            struct AsyncFdEvent *addEvent = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));\n            if (addEvent != NULL) {\n                addEvent->fd = fd;\n                addEvent->type = ASYNC_EVENT_ADD;\n                (void)BSL_LIST_AddElement(ctx->fdChangeList, addEvent, BSL_LIST_POS_END);\n            }\n        }\n        return BSL_SUCCESS;\n    }\n    curr = curr->next;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async_notify.c",
    "line": "174-183",
    "severity": "low",
    "title": "BSL_NOTIFY_CTX_LookupFd returns marked-for-deletion entries",
    "problem": "The BSL_NOTIFY_CTX_LookupFd function searches for an FD by key but does not check the `del` flag. It may return an FD that has been marked for deletion (curr->del == true), which could lead to the caller using a stale/invalid file descriptor.",
    "code": "HITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    if (curr->key == key) {\n        *fd = curr->fd;\n        if (customData != NULL) {\n            *customData = curr->customData;\n        }\n        return BSL_SUCCESS;\n    }\n    curr = curr->next;\n}",
    "fix": "HITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    if (curr->key == key && !curr->del) {\n        *fd = curr->fd;\n        if (customData != NULL) {\n            *customData = curr->customData;\n        }\n        return BSL_SUCCESS;\n    }\n    curr = curr->next;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async.c",
    "line": "487-489",
    "severity": "low",
    "title": "UnlockAndFree called on potentially uninitialized lock on failure",
    "problem": "If BSL_SAL_ThreadLockNew fails, it may leave scheduleNewLock in an undefined state (not necessarily NULL). The code then calls UnlockAndFree on it, which calls BSL_SAL_ThreadUnlock on a potentially invalid handle. This could cause undefined behavior.",
    "code": "int32_t ret = BSL_SAL_ThreadLockNew(&scheduleNewLock);\nif (ret != BSL_SUCCESS) {\n    UnlockAndFree(scheduleNewLock);\n    scheduleNewLock = NULL;\n    return ret;\n}",
    "fix": "int32_t ret = BSL_SAL_ThreadLockNew(&scheduleNewLock);\nif (ret != BSL_SUCCESS) {\n    // On failure, scheduleNewLock is undefined - don't try to unlock/free\n    return ret;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/sal/src/posix/posix_mem.c",
    "line": "79-83",
    "severity": "low",
    "title": "CheckProt does not allow PROT_READ | PROT_EXEC or other valid combinations",
    "problem": "The CheckProt function only allows specific combinations: PROT_READ, PROT_WRITE, PROT_NONE, and PROT_READ|PROT_WRITE. However, PROT_READ|PROT_EXEC is a valid and commonly used combination for executable memory. The current implementation would reject valid protection flags.",
    "code": "static bool CheckProt(int val)\n{\n    if (val == PROT_READ || val == PROT_WRITE || val == PROT_NONE) {\n        return true;\n    }\n    \n    if (val == (PROT_READ | PROT_WRITE)) {\n        return true;\n    }\n    return false;\n}",
    "fix": "static bool CheckProt(int val)\n{\n    // Allow combinations of PROT_READ, PROT_WRITE, and PROT_EXEC, or PROT_NONE\n    if (val == PROT_NONE) {\n        return true;\n    }\n    \n    // Check that only valid protection bits are set\n    int validBits = PROT_READ | PROT_WRITE | PROT_EXEC;\n    if ((val & ~validBits) != 0) {\n        return false;\n    }\n    \n    // At least one protection bit should be set\n    return (val & validBits) != 0;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async_notify.c",
    "line": "196-200",
    "severity": "low",
    "title": "BSL_NOTIFY_CTX_CollectAllFds counts deleted FDs",
    "problem": "The BSL_NOTIFY_CTX_CollectAllFds function counts all FD nodes including those marked for deletion (del == true). This could return an incorrect count to the caller, who may allocate insufficient buffer space if they expect only active FDs.",
    "code": "uint32_t fdCount = 0;\nHITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    fdCount++;\n    curr = curr->next;\n}",
    "fix": "uint32_t fdCount = 0;\nHITLS_ASYNC_NotifyFd *curr = ctx->fds;\nwhile (curr != NULL) {\n    if (!curr->del) {\n        fdCount++;\n    }\n    curr = curr->next;\n}"
  },
  {
    "source": "claude",
    "file": "bsl/async/src/async_notify.c",
    "line": "207-212",
    "severity": "low",
    "title": "BSL_NOTIFY_CTX_CollectAllFds copies deleted FDs",
    "problem": "When copying FDs to the output array, the function copies all FDs including those marked for deletion. This could expose stale/invalid file descriptors to callers.",
    "code": "uint32_t idx = 0;\ncurr = ctx->fds;\nwhile (curr != NULL && idx < *count) {\n    fds[idx++] = curr->fd;\n    curr = curr->next;\n}",
    "fix": "uint32_t idx = 0;\ncurr = ctx->fds;\nwhile (curr != NULL && idx < *count) {\n    if (!curr->del) {\n        fds[idx++] = curr->fd;\n    }\n    curr = curr->next;\n}"
  }
]