Now I have verified all the issues in the code. Let me consolidate the findings:

===ISSUE===
FILE: bsl/async/src/async_notify.c
LINE: 146-162
SEVERITY: critical
TITLE: Use-after-free in RegisterFd when event allocation fails
REVIEWERS: CLAUDE, GEMINI, CODEX
CONFIDENCE: trusted
PROBLEM: The newFd node is linked into ctx->fds (lines 146-147) before attempting to create and add the change event. If event allocation (line 150) or BSL_LIST_AddElement (line 158) fails, newFd is freed (lines 152, 160) but ctx->fds still points to the freed memory. This leaves a dangling pointer in the linked list, causing use-after-free or corruption on subsequent list traversals.
CODE:
```c
newFd->next = ctx->fds;
ctx->fds = newFd;

if (ctx->fdChangeList != NULL) {
    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));
    if (event == NULL) {
        BSL_SAL_FREE(newFd);  // ctx->fds still points to freed newFd
        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);
        return BSL_MALLOC_FAIL;
    }
    event->fd = fd;
    event->type = ASYNC_EVENT_ADD;
    if (BSL_LIST_AddElement(ctx->fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {
        BSL_SAL_FREE(event);
        BSL_SAL_FREE(newFd);  // ctx->fds still points to freed newFd
        return BSL_ASYNC_ERR;
    }
}
```
FIX:
```c
if (ctx->fdChangeList != NULL) {
    struct AsyncFdEvent *event = (struct AsyncFdEvent *)BSL_SAL_Calloc(1, sizeof(struct AsyncFdEvent));
    if (event == NULL) {
        BSL_SAL_FREE(newFd);
        BSL_ERR_PUSH_ERROR(BSL_MALLOC_FAIL);
        return BSL_MALLOC_FAIL;
    }
    event->fd = fd;
    event->type = ASYNC_EVENT_ADD;
    if (BSL_LIST_AddElement(ctx->fdChangeList, event, BSL_LIST_POS_END) != BSL_SUCCESS) {
        BSL_SAL_FREE(event);
        BSL_SAL_FREE(newFd);
        return BSL_ASYNC_ERR;
    }
}

// Only insert into list after all allocations succeed
newFd->next = ctx->fds;
ctx->fds = newFd;
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 483-489
SEVERITY: high
TITLE: Race condition in BSL_ASYNC_ScheduleNew due to local lock
REVIEWERS: CLAUDE, GEMINI
CONFIDENCE: trusted
PROBLEM: BSL_ASYNC_ScheduleNew creates a new local lock on each call (line 484), then acquires it (line 494). Since each thread creates its own local lock instance, multiple threads calling this function concurrently will each hold different locks, providing no synchronization. This can lead to multiple scheduler initializations, memory leaks, and race conditions on the global g_schedule. Additionally, if BSL_SAL_ThreadLockNew fails, it calls UnlockAndFree on an undefined lock handle.
CODE:
```c
BSL_SAL_ThreadLockHandle scheduleNewLock = NULL;
int32_t ret = BSL_SAL_ThreadLockNew(&scheduleNewLock);
if (ret != BSL_SUCCESS) {
    UnlockAndFree(scheduleNewLock);
    scheduleNewLock = NULL;
    return ret;
}
```
FIX:
```c
// Use a static lock for proper synchronization across threads
static BSL_SAL_ThreadLockHandle g_scheduleInitLock = NULL;
static bool g_lockInitialized = false;

int32_t BSL_ASYNC_ScheduleNew(const struct ScheduleAttr *scheAttr)
{
    if (ScheduleGet() != NULL) {
        return BSL_SUCCESS;
    }

    // Initialize the global lock once (could use pthread_once or similar)
    if (!g_lockInitialized) {
        int32_t ret = BSL_SAL_ThreadLockNew(&g_scheduleInitLock);
        if (ret != BSL_SUCCESS) {
            return ret;
        }
        g_lockInitialized = true;
    }

    BSL_SAL_ThreadWriteLock(g_scheduleInitLock);
    
    // Re-check after acquiring lock
    if (ScheduleGet() != NULL) {
        BSL_SAL_ThreadUnlock(g_scheduleInitLock);
        return BSL_SUCCESS;
    }
    
    // ... rest of initialization
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 658
SEVERITY: high
TITLE: Struct copy overwrites caller's job pointer contents
REVIEWERS: CLAUDE
CONFIDENCE: likely
PROBLEM: In BSL_ASYNC_Start, when status is ASYNC_JOB_PAUSING (line 655), the code performs `*job = *ctx->currjob` which copies the entire Coroutine struct by value to the caller's pointer location. This overwrites the caller's job struct. If the caller later calls BSL_ASYNC_Free on the job, it may double-free resources or corrupt memory since both the original and the copy have pointers to the same resources (stack, args, notifyctx).
CODE:
```c
if (status == ASYNC_JOB_PAUSING) {
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start job enter the [pausing] branch.", 0, 0, 0, 0);
    *job = *ctx->currjob;
    ctx->currjob->status = ASYNC_JOB_PAUSED;
    ctx->currjob = NULL;
    return BSL_ASYNC_PAUSE;
}
```
FIX:
```c
if (status == ASYNC_JOB_PAUSING) {
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05093, BSL_LOG_LEVEL_DEBUG, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start job enter the [pausing] branch.", 0, 0, 0, 0);
    ctx->currjob->status = ASYNC_JOB_PAUSED;
    ctx->currjob = NULL;
    return BSL_ASYNC_PAUSE;
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 704-706
SEVERITY: high
TITLE: BSL_ASYNC_Free destroys thread-local context breaking other coroutines
REVIEWERS: GEMINI
CONFIDENCE: likely
PROBLEM: BSL_ASYNC_Free unconditionally calls AsyncCtxFree(), which frees the thread-local AsyncCtx (g_coroutineCtxKey). If called while other coroutines are active on the same thread, this destroys the shared dispatcher context, causing subsequent coroutine switches to crash or fail. The thread-local context should only be freed when the thread exits or via explicit cleanup.
CODE:
```c
void BSL_ASYNC_Free(HITLS_Coroutine *job)
{
    AsyncCtxFree();
    if (job == NULL) {
        return;
    }
    AsyncReleaseJob(job);
}
```
FIX:
```c
void BSL_ASYNC_Free(HITLS_Coroutine *job)
{
    // Do not free the thread-local context here.
    // It should be freed only when the thread exits or via explicit cleanup API.
    // AsyncCtxFree();
    if (job == NULL) {
        return;
    }
    AsyncReleaseJob(job);
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 637-670
SEVERITY: medium
TITLE: Missing status handling causes infinite loop
REVIEWERS: CLAUDE, CODEX
CONFIDENCE: trusted
PROBLEM: The while(true) loop in BSL_ASYNC_Start handles ASYNC_JOB_STOPPING, ASYNC_JOB_READY, ASYNC_JOB_PAUSING, and ASYNC_JOB_PAUSED states. If status is ASYNC_JOB_RUNNING or any unexpected value, no branch is taken, the loop never exits, and the code spins forever. The unreachable code after the loop (lines 672-674) also indicates this logic error.
CODE:
```c
while (true) {
    int status = ctx->currjob->status;
    if (status == ASYNC_JOB_STOPPING) { ... return BSL_ASYNC_FINISH; }
    if (status == ASYNC_JOB_READY) { ... continue; }
    if (status == ASYNC_JOB_PAUSING) { ... return BSL_ASYNC_PAUSE; }
    if (status == ASYNC_JOB_PAUSED) { ... continue; }
}
// Unreachable code
AsyncReleaseJob(ctx->currjob);
ctx->currjob = NULL;
return BSL_ASYNC_ERR;
```
FIX:
```c
while (true) {
    int status = ctx->currjob->status;
    if (status == ASYNC_JOB_STOPPING) {
        *ret = ctx->currjob->coError;
        ctx->currjob = NULL;
        return BSL_ASYNC_FINISH;
    }
    if (status == ASYNC_JOB_READY) {
        ctx->currjob->status = ASYNC_JOB_RUNNING;
        AsyncSwapcontext(&ctx->dispatcher, &ctx->currjob->ctx);
        continue;
    }
    if (status == ASYNC_JOB_PAUSING) {
        ctx->currjob->status = ASYNC_JOB_PAUSED;
        ctx->currjob = NULL;
        return BSL_ASYNC_PAUSE;
    }
    if (status == ASYNC_JOB_PAUSED) {
        ctx->currjob = job;
        AsyncSwapcontext(&ctx->dispatcher, &ctx->currjob->ctx);
        continue;
    }
    // Handle unexpected status - prevents infinite loop
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_ERR);
    AsyncReleaseJob(ctx->currjob);
    ctx->currjob = NULL;
    return BSL_ASYNC_ERR;
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 108-122
SEVERITY: medium
TITLE: Coroutine ID generation never updates the shared counter
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: CoroutineNewid() creates a local BSL_SAL_RefCount struct initialized with a copy of ScheduleGet()->idGen (line 113-115). The atomic increment operates on this local copy, not the actual idGen field in the scheduler. This means the shared counter is never updated, and all coroutines will get duplicate IDs. Additionally, this is not thread-safe.
CODE:
```c
static int32_t CoroutineNewid(void)
{
    int32_t ref = 0;
    int32_t ret = 0;
    BSL_SAL_RefCount threadStartNum = {
        .count = ScheduleGet()->idGen
    };
    ret = BSL_SAL_AtomicUpReferences(&threadStartNum, &ref);
    if (ret != BSL_SUCCESS) {
        BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05101, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                              "croutine new id in atomic mode faile.", 0, 0, 0, 0);
    }
    return ref;
}
```
FIX:
```c
// In async_local.h, change idGen to BSL_SAL_RefCount type:
struct AsyncSchedule {
    int32_t state;
    BSL_SAL_RefCount idGen;  // Changed from int32_t
    // ...
};

// In async.c, update ScheduleAlloc:
static struct AsyncSchedule *ScheduleAlloc(void)
{
    struct AsyncSchedule *schedule = (struct AsyncSchedule *)BSL_SAL_Calloc(1, sizeof(struct AsyncSchedule));
    if (schedule == NULL) { ... }
    (void)BSL_SAL_ReferencesInit(&schedule->idGen);
    schedule->state = SCHEDULE_INIT;
    return schedule;
}

// Fix CoroutineNewid to use the actual scheduler's idGen:
static int32_t CoroutineNewid(void)
{
    int32_t ref = 0;
    struct AsyncSchedule *schedule = ScheduleGet();
    if (schedule == NULL) {
        return 0;
    }
    (void)BSL_SAL_AtomicUpReferences(&schedule->idGen, &ref);
    return ref;
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async.c
LINE: 555
SEVERITY: medium
TITLE: Swapcontext failure check is inverted
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: In AsyncStartRunFunc, AsyncSwapcontext returns 0 (BSL_SUCCESS) on success. However, the code logs an error when the return value is 0 (success case) and ignores actual failures (non-zero returns). This means real swap failures go unhandled.
CODE:
```c
job->status = ASYNC_JOB_STOPPING;
if (AsyncSwapcontext(&job->ctx, &ctx->dispatcher) == 0) {
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_UCONTEXT_SWAP_FAIL);
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05103, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start run func swap context fail.", 0, 0, 0, 0);
}
```
FIX:
```c
job->status = ASYNC_JOB_STOPPING;
int32_t swapRet = AsyncSwapcontext(&job->ctx, &ctx->dispatcher);
if (swapRet != 0) {
    BSL_ERR_PUSH_ERROR(BSL_ASYNC_UCONTEXT_SWAP_FAIL);
    BSL_LOG_BINLOG_FIXLEN(BINLOG_ID05103, BSL_LOG_LEVEL_ERR, BSL_LOG_BINLOG_TYPE_RUN,
                          "async start run func swap context fail.", 0, 0, 0, 0);
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async_notify.c
LINE: 174-184
SEVERITY: medium
TITLE: LookupFd and CollectAllFds return deleted FDs
REVIEWERS: CLAUDE, CODEX
CONFIDENCE: trusted
PROBLEM: BSL_NOTIFY_CTX_LookupFd does not check the `del` flag when searching for FDs by key. It may return an FD that has been marked for deletion (curr->del == true), which leads to the caller using a stale/invalid file descriptor. Similarly, BSL_NOTIFY_CTX_CollectAllFds counts and copies all FDs including deleted ones.
CODE:
```c
HITLS_ASYNC_NotifyFd *curr = ctx->fds;
while (curr != NULL) {
    if (curr->key == key) {  // No check for curr->del
        *fd = curr->fd;
        if (customData != NULL) {
            *customData = curr->customData;
        }
        return BSL_SUCCESS;
    }
    curr = curr->next;
}
```
FIX:
```c
HITLS_ASYNC_NotifyFd *curr = ctx->fds;
while (curr != NULL) {
    if (curr->key == key && !curr->del) {
        *fd = curr->fd;
        if (customData != NULL) {
            *customData = curr->customData;
        }
        return BSL_SUCCESS;
    }
    curr = curr->next;
}
```
===END===

===ISSUE===
FILE: bsl/async/src/async_notify.c
LINE: 218-260
SEVERITY: medium
TITLE: PollFdChanges never consumes the change list
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: BSL_NOTIFY_CTX_PollFdChanges iterates through fdChangeList and reports added/removed FDs, but never removes events from the list. This means the same events are returned on every poll call, and the list grows unbounded. The function should consume (clear) the events after reporting them, similar to how AsyncCleanupFdChanges works during yield.
CODE:
```c
*addedCount = addTotal;
*removedCount = delTotal;

return BSL_SUCCESS;
// Missing: cleanup of consumed events
```
FIX:
```c
*addedCount = addTotal;
*removedCount = delTotal;

// Consume the change list after reporting
if (addedFds != NULL || removedFds != NULL) {
    AsyncCleanupFdChanges(ctx);
}

return BSL_SUCCESS;
```
===END===

===ISSUE===
FILE: bsl/async/include/async_local.h
LINE: 110-118
SEVERITY: low
TITLE: Static variable g_pageSize declared in header creates per-TU copies
REVIEWERS: CLAUDE
CONFIDENCE: likely
PROBLEM: The g_pageSize static variable is declared with file-scope static storage in a header file. When this header is included in multiple translation units, each unit gets its own separate copy of g_pageSize. This is wasteful and could lead to redundant SAL_GetPageSize calls. Additionally, GetPageSize() has a race condition where multiple threads could simultaneously see g_pageSize as 0.
CODE:
```c
static size_t g_pageSize;

static inline size_t GetPageSize(void)
{
    if (g_pageSize == 0) {
        g_pageSize = (size_t)SAL_GetPageSize();
    }
    return g_pageSize;
}
```
FIX:
```c
// In async_local.h - declare extern
extern size_t g_pageSize;

static inline size_t GetPageSize(void)
{
    if (g_pageSize == 0) {
        g_pageSize = (size_t)SAL_GetPageSize();
    }
    return g_pageSize;
}

// In async.c - define the variable
size_t g_pageSize = 0;
```
===END===

===ISSUE===
FILE: bsl/async/src/async_notify.c
LINE: 314-319
SEVERITY: low
TITLE: RemoveFd path skips cleanup callback for newly-added FDs
REVIEWERS: CODEX
CONFIDENCE: likely
PROBLEM: When a newly-added FD is removed before being polled, NotifyCtxDetachFdNode is called which frees the node directly without invoking the cleanup callback. This could leak resources (e.g., file descriptors) that the cleanup callback was meant to release.
CODE:
```c
static bool NotifyCtxDetachFdNode(HITLS_NOTIFY_Ctx *ctx, HITLS_ASYNC_NotifyFd *target)
{
    // ...
    if (*pp == target) {
        *pp = target->next;
        BSL_SAL_FREE(target);  // Cleanup callback not called
        return true;
    }
    // ...
}
```
FIX:
```c
static bool NotifyCtxDetachFdNode(HITLS_NOTIFY_Ctx *ctx, HITLS_ASYNC_NotifyFd *target)
{
    if (ctx == NULL || target == NULL) {
        return false;
    }

    HITLS_ASYNC_NotifyFd **pp = &ctx->fds;
    while (*pp != NULL) {
        if (*pp == target) {
            if (target->cleanup != NULL) {
                target->cleanup(ctx, target->fd);
            }
            *pp = target->next;
            BSL_SAL_FREE(target);
            return true;
        }
        pp = &(*pp)->next;
    }

    return false;
}
```
===END===

===ISSUE===
FILE: testcode/sdv/testcase/bsl/async/test_suite_sdv_async_notify_ctx.c
LINE: 530-532
SEVERITY: low
TITLE: Test assertion is logically inconsistent
REVIEWERS: GEMINI
CONFIDENCE: likely
PROBLEM: The test UT_BSL_NOTIFY_CTX_POLL_REMOVED_FD_TC001 expects removedCount to be 0 (line 531), but then asserts that removedFds[0] equals fd (line 532). If removedCount is 0, checking removedFds[0] is meaningless - the array was zero-initialized, so removedFds[0] is 0, not fd (10). This test is logically inconsistent.
CODE:
```c
ASSERT_EQ(addedCount, 0);
ASSERT_EQ(removedCount, 0);
ASSERT_EQ(removedFds[0], fd);  // fd is 10, but removedFds[0] is 0
```
FIX:
```c
ASSERT_EQ(addedCount, 0);
// Either expect removedCount to be 1 and check removedFds[0]:
ASSERT_EQ(removedCount, 1);
ASSERT_EQ(removedFds[0], fd);
// Or remove the removedFds[0] check if removedCount should be 0
```
===END===