<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/sdfp#8 - CLAUDE</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/sdfp#8 - CLAUDE</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title critical">Critical</div>
<div class="issue">
                <div class="issue-title">Undefined control command macros causing compilation failure</div>
                <div class="issue-location">demo/sm4_cbc.c:131</div>
                <pre>if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SM4_SET_KEK_ID, &amp;kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {</pre>
                <div class="problem"><strong>Issue:</strong> The demo uses CRYPT_CTRL_SM4_SET_KEK_ID and CRYPT_CTRL_SM4_GEN_DEK_WITH_KEK which are not defined in provider.h. The actual macros are CRYPT_CTRL_SET_KEK_ID (110) and CRYPT_CTRL_GEN_DEK_WITH_KEK (111) without the SM4_ prefix.</div>
                <div class="fix-label">Fix:</div><pre>if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SET_KEK_ID, &amp;kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
<div class="issue">
                <div class="issue-title">KEK handle destroyed before use causing NULL key handle</div>
                <div class="issue-location">src/sm4_cipher.c:128-151</div>
                <pre>if (ctx-&gt;hKeyHandle != NULL) {
    (void)SDF_DL_DestroyKey(ctx-&gt;hSessionHandle, ctx-&gt;hKeyHandle);
    ctx-&gt;hKeyHandle = NULL;
}

int ret = SDR_OK;
if (ctx-&gt;keySource == KEY_SRC_RAW) {
    ret = SDF_DL_ImportKey(...);
} else if (key != NULL &amp;&amp; keyLen &gt; 0) {
    ret = SDF_DL_ImportKeyWithKEK(...);
}
/* If keySource==KEY_SRC_KEK, key==NULL, hKeyHandle was just destroyed, but not recreated */</pre>
                <div class="problem"><strong>Issue:</strong> When using KEK mode with a pre-generated key handle (via CRYPT_CTRL_GEN_DEK_WITH_KEK), calling InitCtx with NULL/0 key parameters destroys the existing hKeyHandle at lines 128-131, but then doesn't recreate it because key==NULL. This causes hKeyHandle to be NULL when EncryptInit/DecryptInit is called at lines 154-160. The test_kek_handle() function in demo/sm4_cbc.c relies on reusing the key handle after GEN_DEK_WITH_KEK.</div>
                <div class="fix-label">Fix:</div><pre>if (ctx-&gt;keySource == KEY_SRC_KEK &amp;&amp; key == NULL &amp;&amp; ctx-&gt;hKeyHandle == NULL) {
    return CRYPT_NULL_INPUT;  /* No key handle available */
}
/* Only destroy if we're going to create a new one */
if ((ctx-&gt;keySource == KEY_SRC_RAW) || (key != NULL &amp;&amp; keyLen &gt; 0)) {
    if (ctx-&gt;hKeyHandle != NULL) {
        (void)SDF_DL_DestroyKey(ctx-&gt;hSessionHandle, ctx-&gt;hKeyHandle);
        ctx-&gt;hKeyHandle = NULL;
    }
}</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
<div class="issue">
                <div class="issue-title">KEK handle destroyed before use causing NULL key handle</div>
                <div class="issue-location">src/sm4_gcm.c:136-149</div>
                <pre>if (ctx-&gt;hKeyHandle != NULL) {
    (void)SDF_DL_DestroyKey(ctx-&gt;hSessionHandle, ctx-&gt;hKeyHandle);
    ctx-&gt;hKeyHandle = NULL;
}
...
} else if (key != NULL &amp;&amp; keyLen &gt; 0) {
    ret = SDF_DL_ImportKeyWithKEK(...);
}
/* else: hKeyHandle is already set by GEN_KEY ctrl, use it directly */
/* But it was just destroyed above! */</pre>
                <div class="problem"><strong>Issue:</strong> Same issue as sm4_cipher.c. When using KEK mode with a pre-generated key handle, calling InitCtx with NULL/0 key destroys the existing hKeyHandle at lines 136-139, but doesn't recreate it for the KEY_SRC_KEK + key==NULL case.</div>
                <div class="fix-label">Fix:</div><pre>/* Only destroy if we're going to create a new one */
if ((ctx-&gt;keySource == GCM_KEY_SRC_RAW) || (key != NULL &amp;&amp; keyLen &gt; 0)) {
    if (ctx-&gt;hKeyHandle != NULL) {
        (void)SDF_DL_DestroyKey(ctx-&gt;hSessionHandle, ctx-&gt;hKeyHandle);
        ctx-&gt;hKeyHandle = NULL;
    }
}</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Stack buffer with wrapped key not cleansed before return</div>
                <div class="issue-location">src/sm4_cipher.c:247-264</div>
                <pre>unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
...
int ret = SDF_DL_GenerateKeyWithKEK(ctx-&gt;hSessionHandle, 128, SGD_SM4_ECB,
    ctx-&gt;kekIndex, wrapBuf, &amp;wrapLen, &amp;ctx-&gt;hKeyHandle);
/* tmpBuf now contains wrapped key but is not cleansed */
return CRYPT_SUCCESS;</pre>
                <div class="problem"><strong>Issue:</strong> When val==NULL, tmpBuf[64] on the stack holds the wrapped key material after SDF_DL_GenerateKeyWithKEK. This sensitive data is not cleared with BSL_SAL_CleanseData before the function returns, potentially leaking wrapped key material on the stack.</div>
                <div class="fix-label">Fix:</div><pre>unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
...
int ret = SDF_DL_GenerateKeyWithKEK(ctx-&gt;hSessionHandle, 128, SGD_SM4_ECB,
    ctx-&gt;kekIndex, wrapBuf, &amp;wrapLen, &amp;ctx-&gt;hKeyHandle);
if (ret == SDR_OK &amp;&amp; wrapBuf == tmpBuf) {
    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));
}
return CRYPT_SUCCESS;</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
<div class="issue">
                <div class="issue-title">Stack buffer with wrapped key not cleansed before return</div>
                <div class="issue-location">src/sm4_gcm.c:327-336</div>
                <pre>unsigned char tmpBuf[64];
unsigned int  wrapLen = (val != NULL &amp;&amp; valLen &gt; 0) ? valLen : sizeof(tmpBuf);
unsigned char *wrapBuf = (val != NULL &amp;&amp; valLen &gt; 0) ? (unsigned char *)val : tmpBuf;
int ret = SDF_DL_GenerateKeyWithKEK(ctx-&gt;hSessionHandle, 128, SGD_SM4_GCM,
    ctx-&gt;kekIndex, wrapBuf, &amp;wrapLen, &amp;ctx-&gt;hKeyHandle);
/* tmpBuf contains wrapped key material but is not cleansed */</pre>
                <div class="problem"><strong>Issue:</strong> Same issue as sm4_cipher.c. When val==NULL, tmpBuf[64] holds wrapped key material but is not cleared with BSL_SAL_CleanseData before returning.</div>
                <div class="fix-label">Fix:</div><pre>unsigned char tmpBuf[64];
unsigned int  wrapLen = (val != NULL &amp;&amp; valLen &gt; 0) ? valLen : sizeof(tmpBuf);
unsigned char *wrapBuf = (val != NULL &amp;&amp; valLen &gt; 0) ? (unsigned char *)val : tmpBuf;
int ret = SDF_DL_GenerateKeyWithKEK(ctx-&gt;hSessionHandle, 128, SGD_SM4_GCM,
    ctx-&gt;kekIndex, wrapBuf, &amp;wrapLen, &amp;ctx-&gt;hKeyHandle);
if (ret == SDR_OK &amp;&amp; wrapBuf == tmpBuf) {
    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));
}
return CRYPT_SUCCESS;</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Inconsistent library format macro usage</div>
                <div class="issue-location">demo/sm4_gcm.c:56</div>
                <pre>int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_SO, "SDFProv", provParams, NULL);</pre>
                <div class="problem"><strong>Issue:</strong> sm4_gcm.c uses BSL_SAL_LIB_FMT_SO while all other demo files (sm3_hash.c, sm4_cbc.c, sm4_ecb.c, sm2_sign.c, etc.) use BSL_SAL_LIB_FMT_LIBSO. Inconsistency may cause compilation issues if only one macro is defined.</div>
                <div class="fix-label">Fix:</div><pre>int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_LIBSO, "SDFProv", provParams, NULL);</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
<div class="issue">
                <div class="issue-title">Wrapped key output not retrievable when val is NULL</div>
                <div class="issue-location">src/sm4_cipher.c:247-264</div>
                <pre>unsigned int wrapLen = valLen;  /* Input: size of caller's buffer */
unsigned char *wrapBuf = (unsigned char *)val;
unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
/* After GenerateKeyWithKEK, wrapLen contains actual size but caller can't access it */
return CRYPT_SUCCESS;  /* Caller has no way to get the wrapped key data or its size */</pre>
                <div class="problem"><strong>Issue:</strong> When val==NULL, the wrapped key is written to tmpBuf but there's no way for the caller to retrieve it. The wrappedLen (actual wrapped key size) is not returned to the caller via valLen or any output parameter. This makes the function unusable for getting wrapped key output when passing NULL val.</div>
                <div class="fix-label">Fix:</div><pre>/* Document that val must not be NULL when output is needed */
/* OR: Add output mechanism for wrapped key size */</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Duplicate stdio.h include</div>
                <div class="issue-location">demo/sm4_cbc.c:1-2</div>
                <pre>#include &lt;stdio.h&gt;
#include &lt;stdio.h&gt;</pre>
                <div class="problem"><strong>Issue:</strong> Line 1 and line 2 both include <stdio.h>, which is redundant.</div>
                <div class="fix-label">Fix:</div><pre>#include &lt;stdio.h&gt;</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
<div class="issue">
                <div class="issue-title">Missing validation in CRYPT_CTRL_SET_AAD for NULL val with zero valLen</div>
                <div class="issue-location">src/sm4_gcm.c:267-279</div>
                <pre>if (val == NULL &amp;&amp; valLen != 0) {
    return CRYPT_INVALID_ARG;
}
if (valLen &gt; SM4_GCM_AAD_MAX) {
    return CRYPT_INVALID_ARG;
}
if (val != NULL &amp;&amp; valLen &gt; 0) {
    memcpy(ctx-&gt;aad, val, valLen);
}
ctx-&gt;aadLen = valLen;  /* Sets aadLen to 0, clearing AAD - this is intentional */</pre>
                <div class="problem"><strong>Issue:</strong> The check `if (val == NULL && valLen != 0)` returns error only when val is NULL AND valLen is non-zero. This allows val=NULL with valLen=0 to proceed, which would cause memcpy(NULL, ...) to be called. The condition at line 275 `if (val != NULL && valLen > 0)` prevents the memcpy, but the logic is confusing.</div>
                <div class="fix-label">Fix:</div><pre>/* The current logic is actually correct - it allows clearing AAD by passing val=NULL, valLen=0 */
/* But the condition could be clearer: */
if (valLen &gt; SM4_GCM_AAD_MAX) {
    return CRYPT_INVALID_ARG;
}
if (val != NULL) {
    if (valLen == 0) {
        return CRYPT_INVALID_ARG;  /* val non-NULL but valLen is 0 */
    }
    memcpy(ctx-&gt;aad, val, valLen);
}
ctx-&gt;aadLen = valLen;</pre>
                <div class="issue-source">Reviewer: claude</div>
            </div>
</div>
</div></body></html>