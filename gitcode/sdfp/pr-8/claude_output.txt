The SGD_SM3 and SGD_SM4 constants seem to come from the external SDF SDK (sdf.h), not defined locally. This is expected since the code depends on the SDF device SDK.

Now let me compile all the issues and output them:

===ISSUE===
FILE: demo/sm4_cbc.c
LINE: 1-2
SEVERITY: low
TITLE: Duplicate stdio.h include
PROBLEM: Line 1 and line 2 both include <stdio.h>, which is redundant.
CODE:
```
#include <stdio.h>
#include <stdio.h>
```
FIX:
```
#include <stdio.h>
```
===END===

===ISSUE===
FILE: demo/sm4_cbc.c
LINE: 131, 136, 197, 202, 215, 242
SEVERITY: critical
TITLE: Undefined control command macros causing compilation failure
PROBLEM: The demo uses CRYPT_CTRL_SM4_SET_KEK_ID and CRYPT_CTRL_SM4_GEN_DEK_WITH_KEK which are not defined in provider.h. The actual macros are CRYPT_CTRL_SET_KEK_ID (110) and CRYPT_CTRL_GEN_DEK_WITH_KEK (111) without the SM4_ prefix.
CODE:
```
if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SM4_SET_KEK_ID, &kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {
```
FIX:
```
if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SET_KEK_ID, &kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {
```
===END===

===ISSUE===
FILE: demo/sm4_gcm.c
LINE: 56
SEVERITY: medium
TITLE: Inconsistent library format macro usage
PROBLEM: sm4_gcm.c uses BSL_SAL_LIB_FMT_SO while all other demo files (sm3_hash.c, sm4_cbc.c, sm4_ecb.c, sm2_sign.c, etc.) use BSL_SAL_LIB_FMT_LIBSO. Inconsistency may cause compilation issues if only one macro is defined.
CODE:
```
int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_SO, "SDFProv", provParams, NULL);
```
FIX:
```
int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_LIBSO, "SDFProv", provParams, NULL);
```
===END===

===ISSUE===
FILE: src/sm4_cipher.c
LINE: 128-151
SEVERITY: critical
TITLE: KEK handle destroyed before use causing NULL key handle
PROBLEM: When using KEK mode with a pre-generated key handle (via CRYPT_CTRL_GEN_DEK_WITH_KEK), calling InitCtx with NULL/0 key parameters destroys the existing hKeyHandle at lines 128-131, but then doesn't recreate it because key==NULL. This causes hKeyHandle to be NULL when EncryptInit/DecryptInit is called at lines 154-160. The test_kek_handle() function in demo/sm4_cbc.c relies on reusing the key handle after GEN_DEK_WITH_KEK.
CODE:
```
if (ctx->hKeyHandle != NULL) {
    (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);
    ctx->hKeyHandle = NULL;
}

int ret = SDR_OK;
if (ctx->keySource == KEY_SRC_RAW) {
    ret = SDF_DL_ImportKey(...);
} else if (key != NULL && keyLen > 0) {
    ret = SDF_DL_ImportKeyWithKEK(...);
}
/* If keySource==KEY_SRC_KEK, key==NULL, hKeyHandle was just destroyed, but not recreated */
```
FIX:
```
if (ctx->keySource == KEY_SRC_KEK && key == NULL && ctx->hKeyHandle == NULL) {
    return CRYPT_NULL_INPUT;  /* No key handle available */
}
/* Only destroy if we're going to create a new one */
if ((ctx->keySource == KEY_SRC_RAW) || (key != NULL && keyLen > 0)) {
    if (ctx->hKeyHandle != NULL) {
        (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);
        ctx->hKeyHandle = NULL;
    }
}
```
===END===

===ISSUE===
FILE: src/sm4_gcm.c
LINE: 136-149
SEVERITY: critical
TITLE: KEK handle destroyed before use causing NULL key handle
PROBLEM: Same issue as sm4_cipher.c. When using KEK mode with a pre-generated key handle, calling InitCtx with NULL/0 key destroys the existing hKeyHandle at lines 136-139, but doesn't recreate it for the KEY_SRC_KEK + key==NULL case.
CODE:
```
if (ctx->hKeyHandle != NULL) {
    (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);
    ctx->hKeyHandle = NULL;
}
...
} else if (key != NULL && keyLen > 0) {
    ret = SDF_DL_ImportKeyWithKEK(...);
}
/* else: hKeyHandle is already set by GEN_KEY ctrl, use it directly */
/* But it was just destroyed above! */
```
FIX:
```
/* Only destroy if we're going to create a new one */
if ((ctx->keySource == GCM_KEY_SRC_RAW) || (key != NULL && keyLen > 0)) {
    if (ctx->hKeyHandle != NULL) {
        (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);
        ctx->hKeyHandle = NULL;
    }
}
```
===END===

===ISSUE===
FILE: src/sm4_cipher.c
LINE: 247-264
SEVERITY: high
TITLE: Stack buffer with wrapped key not cleansed before return
PROBLEM: When val==NULL, tmpBuf[64] on the stack holds the wrapped key material after SDF_DL_GenerateKeyWithKEK. This sensitive data is not cleared with BSL_SAL_CleanseData before the function returns, potentially leaking wrapped key material on the stack.
CODE:
```
unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
...
int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_ECB,
    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);
/* tmpBuf now contains wrapped key but is not cleansed */
return CRYPT_SUCCESS;
```
FIX:
```
unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
...
int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_ECB,
    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);
if (ret == SDR_OK && wrapBuf == tmpBuf) {
    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));
}
return CRYPT_SUCCESS;
```
===END===

===ISSUE===
FILE: src/sm4_gcm.c
LINE: 327-336
SEVERITY: high
TITLE: Stack buffer with wrapped key not cleansed before return
PROBLEM: Same issue as sm4_cipher.c. When val==NULL, tmpBuf[64] holds wrapped key material but is not cleared with BSL_SAL_CleanseData before returning.
CODE:
```
unsigned char tmpBuf[64];
unsigned int  wrapLen = (val != NULL && valLen > 0) ? valLen : sizeof(tmpBuf);
unsigned char *wrapBuf = (val != NULL && valLen > 0) ? (unsigned char *)val : tmpBuf;
int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_GCM,
    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);
/* tmpBuf contains wrapped key material but is not cleansed */
```
FIX:
```
unsigned char tmpBuf[64];
unsigned int  wrapLen = (val != NULL && valLen > 0) ? valLen : sizeof(tmpBuf);
unsigned char *wrapBuf = (val != NULL && valLen > 0) ? (unsigned char *)val : tmpBuf;
int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_GCM,
    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);
if (ret == SDR_OK && wrapBuf == tmpBuf) {
    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));
}
return CRYPT_SUCCESS;
```
===END===

===ISSUE===
FILE: src/sm4_cipher.c
LINE: 247-264
SEVERITY: medium
TITLE: Wrapped key output not retrievable when val is NULL
PROBLEM: When val==NULL, the wrapped key is written to tmpBuf but there's no way for the caller to retrieve it. The wrappedLen (actual wrapped key size) is not returned to the caller via valLen or any output parameter. This makes the function unusable for getting wrapped key output when passing NULL val.
CODE:
```
unsigned int wrapLen = valLen;  /* Input: size of caller's buffer */
unsigned char *wrapBuf = (unsigned char *)val;
unsigned char tmpBuf[64];
if (wrapBuf == NULL || wrapLen == 0) {
    wrapBuf = tmpBuf;
    wrapLen = sizeof(tmpBuf);
}
/* After GenerateKeyWithKEK, wrapLen contains actual size but caller can't access it */
return CRYPT_SUCCESS;  /* Caller has no way to get the wrapped key data or its size */
```
FIX:
```
/* Document that val must not be NULL when output is needed */
/* OR: Add output mechanism for wrapped key size */
```
===END===

===ISSUE===
FILE: src/sm4_gcm.c
LINE: 267-279
SEVERITY: low
TITLE: Missing validation in CRYPT_CTRL_SET_AAD for NULL val with zero valLen
PROBLEM: The check `if (val == NULL && valLen != 0)` returns error only when val is NULL AND valLen is non-zero. This allows val=NULL with valLen=0 to proceed, which would cause memcpy(NULL, ...) to be called. The condition at line 275 `if (val != NULL && valLen > 0)` prevents the memcpy, but the logic is confusing.
CODE:
```
if (val == NULL && valLen != 0) {
    return CRYPT_INVALID_ARG;
}
if (valLen > SM4_GCM_AAD_MAX) {
    return CRYPT_INVALID_ARG;
}
if (val != NULL && valLen > 0) {
    memcpy(ctx->aad, val, valLen);
}
ctx->aadLen = valLen;  /* Sets aadLen to 0, clearing AAD - this is intentional */
```
FIX:
```
/* The current logic is actually correct - it allows clearing AAD by passing val=NULL, valLen=0 */
/* But the condition could be clearer: */
if (valLen > SM4_GCM_AAD_MAX) {
    return CRYPT_INVALID_ARG;
}
if (val != NULL) {
    if (valLen == 0) {
        return CRYPT_INVALID_ARG;  /* val non-NULL but valLen is 0 */
    }
    memcpy(ctx->aad, val, valLen);
}
ctx->aadLen = valLen;
```
===END===