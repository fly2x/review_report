{
  "context": {
    "owner": "openHiTLS",
    "repo": "sdfp",
    "pr_id": "8",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 15,
    "critical": 3,
    "high": 5,
    "medium": 4,
    "low": 3
  },
  "issues": [
    {
      "file": "demo/sm4_cbc.c",
      "line": "131",
      "severity": "critical",
      "title": "Undefined control command macros causing compilation failure",
      "reviewers": "CLAUDE, GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "The demo uses CRYPT_CTRL_SM4_SET_KEK_ID and CRYPT_CTRL_SM4_GEN_DEK_WITH_KEK which are not defined in provider.h. The actual macros are CRYPT_CTRL_SET_KEK_ID (110) and CRYPT_CTRL_GEN_DEK_WITH_KEK (111) without the SM4_ prefix. This will cause compilation to fail.",
      "code": "if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SM4_SET_KEK_ID, &kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {\n    printf(\"[kek-handle] SET_KEK_ID failed\\n\");\n    ...\n}\nint32_t ret = CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SM4_GEN_DEK_WITH_KEK, wrapped, wrappedLen);",
      "fix": "if (CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_SET_KEK_ID, &kekIndex, sizeof(kekIndex)) != CRYPT_SUCCESS) {\n    printf(\"[kek-handle] SET_KEK_ID failed\\n\");\n    ...\n}\nint32_t ret = CRYPT_EAL_CipherCtrl(ctx, CRYPT_CTRL_GEN_DEK_WITH_KEK, wrapped, wrappedLen);"
    },
    {
      "file": "src/sm4_cipher.c",
      "line": "128-151",
      "severity": "critical",
      "title": "KEK handle destroyed before use causing NULL key handle",
      "reviewers": "CLAUDE, GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "When using KEK mode with a pre-generated key handle (via CRYPT_CTRL_GEN_DEK_WITH_KEK), calling InitCtx with NULL/0 key parameters destroys the existing hKeyHandle at lines 128-131, but then doesn't recreate it because key==NULL. This causes hKeyHandle to be NULL when EncryptInit/DecryptInit is called at lines 154-160. The test_kek_handle() function in demo/sm4_cbc.c relies on reusing the key handle after GEN_DEK_WITH_KEK.",
      "code": "if (ctx->hKeyHandle != NULL) {\n    (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);\n    ctx->hKeyHandle = NULL;\n}\n\nint ret = SDR_OK;\nif (ctx->keySource == KEY_SRC_RAW) {\n    ret = SDF_DL_ImportKey(...);\n} else if (key != NULL && keyLen > 0) {\n    ret = SDF_DL_ImportKeyWithKEK(...);\n}\n/* If keySource==KEY_SRC_KEK, key==NULL, hKeyHandle was just destroyed, but not recreated */",
      "fix": "/* Only destroy if we're going to create a new one */\nif ((ctx->keySource == KEY_SRC_RAW) || (key != NULL && keyLen > 0)) {\n    if (ctx->hKeyHandle != NULL) {\n        (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);\n        ctx->hKeyHandle = NULL;\n    }\n}\n\nint ret = SDR_OK;\nif (ctx->keySource == KEY_SRC_RAW) {\n    ret = SDF_DL_ImportKey(ctx->hSessionHandle, (unsigned char *)key, keyLen, &ctx->hKeyHandle);\n    if (ret != SDR_OK) { BSL_ERR_PUSH_ERROR(ret); return SDFP_ERR_ENCRYPT; }\n} else if (key != NULL && keyLen > 0) {\n    ret = SDF_DL_ImportKeyWithKEK(ctx->hSessionHandle, ctx->sdfAlgId, ctx->kekIndex,\n        (unsigned char *)key, keyLen, &ctx->hKeyHandle);\n    if (ret != SDR_OK) { BSL_ERR_PUSH_ERROR(ret); return SDFP_ERR_ENCRYPT; }\n}"
    },
    {
      "file": "src/sm4_gcm.c",
      "line": "136-149",
      "severity": "critical",
      "title": "KEK handle destroyed before use in GCM mode",
      "reviewers": "CLAUDE, GEMINI, CODEX",
      "confidence": "trusted",
      "problem": "Same issue as sm4_cipher.c. When using KEK mode with a pre-generated key handle, calling InitCtx with NULL/0 key destroys the existing hKeyHandle at lines 136-139, but doesn't recreate it for the KEY_SRC_KEK + key==NULL case.",
      "code": "/* Destroy old key handle if re-initialising */\nif (ctx->hKeyHandle != NULL) {\n    (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);\n    ctx->hKeyHandle = NULL;\n}\n\nint ret = SDR_OK;\nif (ctx->keySource == GCM_KEY_SRC_RAW) {\n    ret = SDF_DL_ImportKey(...);\n} else if (key != NULL && keyLen > 0) {\n    ret = SDF_DL_ImportKeyWithKEK(...);\n}\n/* else: hKeyHandle is already set by GEN_KEY ctrl, use it directly */\n/* But it was just destroyed above! */",
      "fix": "/* Destroy old key handle only if a new key is provided for re-initialising */\nif ((ctx->keySource == GCM_KEY_SRC_RAW) || (key != NULL && keyLen > 0)) {\n    if (ctx->hKeyHandle != NULL) {\n        (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);\n        ctx->hKeyHandle = NULL;\n    }\n}\n\nint ret = SDR_OK;\nif (ctx->keySource == GCM_KEY_SRC_RAW) {\n    ret = SDF_DL_ImportKey(ctx->hSessionHandle, (unsigned char *)key, keyLen, &ctx->hKeyHandle);\n    if (ret != SDR_OK) { BSL_ERR_PUSH_ERROR(ret); return SDFP_ERR_ENCRYPT; }\n} else if (key != NULL && keyLen > 0) {\n    ret = SDF_DL_ImportKeyWithKEK(ctx->hSessionHandle, ctx->sdfAlgId, ctx->kekIndex,\n        (unsigned char *)key, keyLen, &ctx->hKeyHandle);\n    if (ret != SDR_OK) { BSL_ERR_PUSH_ERROR(ret); return SDFP_ERR_ENCRYPT; }\n}"
    },
    {
      "file": "src/sm4_cipher.c",
      "line": "249-264",
      "severity": "high",
      "title": "Stack buffer with wrapped key not cleansed before return",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "When val==NULL, tmpBuf[64] on the stack holds the wrapped key material after SDF_DL_GenerateKeyWithKEK. This sensitive data is not cleared with BSL_SAL_CleanseData before the function returns, potentially leaking wrapped key material on the stack.",
      "code": "unsigned char tmpBuf[64];\nif (wrapBuf == NULL || wrapLen == 0) {\n    wrapBuf = tmpBuf;\n    wrapLen = sizeof(tmpBuf);\n}\n...\nint ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_ECB,\n    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);\n/* tmpBuf now contains wrapped key but is not cleansed */\nreturn CRYPT_SUCCESS;",
      "fix": "unsigned char tmpBuf[64];\nif (wrapBuf == NULL || wrapLen == 0) {\n    wrapBuf = tmpBuf;\n    wrapLen = sizeof(tmpBuf);\n}\n...\nint ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, ctx->sdfAlgId,\n    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);\nif (ret == SDR_OK && wrapBuf == tmpBuf) {\n    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));\n}\nreturn CRYPT_SUCCESS;"
    },
    {
      "file": "src/sm4_gcm.c",
      "line": "327-336",
      "severity": "high",
      "title": "Stack buffer with wrapped key not cleansed before return in GCM",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "Same issue as sm4_cipher.c. When val==NULL, tmpBuf[64] holds wrapped key material but is not cleared with BSL_SAL_CleanseData before returning.",
      "code": "unsigned char tmpBuf[64];\nunsigned int  wrapLen = (val != NULL && valLen > 0) ? valLen : sizeof(tmpBuf);\nunsigned char *wrapBuf = (val != NULL && valLen > 0) ? (unsigned char *)val : tmpBuf;\nint ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_GCM,\n    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);\n/* tmpBuf contains wrapped key material but is not cleansed */",
      "fix": "unsigned char tmpBuf[64];\nunsigned int  wrapLen = (val != NULL && valLen > 0) ? valLen : sizeof(tmpBuf);\nunsigned char *wrapBuf = (val != NULL && valLen > 0) ? (unsigned char *)val : tmpBuf;\nint ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_GCM,\n    ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);\nif (ret == SDR_OK && wrapBuf == tmpBuf) {\n    BSL_SAL_CleanseData(tmpBuf, sizeof(tmpBuf));\n}\nreturn CRYPT_SUCCESS;"
    },
    {
      "file": "src/sm3_md.c",
      "line": "104-109",
      "severity": "high",
      "title": "SM3 context becomes unusable after DeInit",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "CRYPT_SM3_DeInit calls SDFP_SM3_CleanCtx(ctx) which closes hSessionHandle. If the provider attempts to reuse the context after DeInit (which is standard behavior for openHiTLS hash contexts), CRYPT_SM3_InitCtx will reject it with CRYPT_NULL_INPUT because ctx->hSessionHandle is NULL.",
      "code": "static int32_t CRYPT_SM3_DeInit(void *c)\n{\n    SDFP_SM3_Ctx *ctx = (SDFP_SM3_Ctx *)c;\n    SDFP_SM3_CleanCtx(ctx);\n    return CRYPT_SUCCESS;\n}",
      "fix": "static int32_t CRYPT_SM3_DeInit(void *c)\n{\n    (void)c;\n    return CRYPT_SUCCESS;\n}"
    },
    {
      "file": "src/sm4_cipher.c",
      "line": "216-221",
      "severity": "high",
      "title": "SM4 context becomes unusable after DeinitCtx",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "CRYPT_SM4_DeinitCtx calls SDFP_SM4_Clean(ctx), which completely closes hSessionHandle. Because InitCtx checks ctx->hSessionHandle == NULL, any attempt to reuse the context after DeinitCtx (e.g., to re-init with new parameters) will fail with CRYPT_NULL_INPUT.",
      "code": "static int32_t CRYPT_SM4_DeinitCtx(void *c)\n{\n    SDFP_SM4_Ctx *ctx = (SDFP_SM4_Ctx *)c;\n    SDFP_SM4_Clean(ctx);\n    return CRYPT_SUCCESS;\n}",
      "fix": "static int32_t CRYPT_SM4_DeinitCtx(void *c)\n{\n    SDFP_SM4_Ctx *ctx = (SDFP_SM4_Ctx *)c;\n    if (ctx == NULL) {\n        return CRYPT_SUCCESS;\n    }\n    if (ctx->hKeyHandle != NULL && ctx->hSessionHandle != NULL) {\n        (void)SDF_DL_DestroyKey(ctx->hSessionHandle, ctx->hKeyHandle);\n        ctx->hKeyHandle = NULL;\n    }\n    BSL_SAL_CleanseData(ctx->iv, sizeof(ctx->iv));\n    ctx->ivLen = 0;\n    ctx->keySource = KEY_SRC_RAW;\n    ctx->kekIndex = 0;\n    return CRYPT_SUCCESS;\n}"
    },
    {
      "file": "src/sdf_dl.c",
      "line": "202-209",
      "severity": "high",
      "title": "SM4/GCM symbol loading failures cause provider load to fail",
      "reviewers": "CODEX",
      "confidence": "evaluate",
      "problem": "New SM4/AEAD symbols (SDF_GenerateKeyWithKEK, SDF_ImportKeyWithKEK, SDF_AuthEncInit/Update/Final, SDF_AuthDecInit/Update/Final) are loaded with LOAD_SYM (required). If a device SDK lacks one of these APIs, SDF_DL_Load fails and the whole provider cannot load, regressing existing SM2/RSA functionality.",
      "code": "LOAD_SYM(genKeyWithKek,           SDF_GenerateKeyWithKEK);\nLOAD_SYM(importKeyWithKek,        SDF_ImportKeyWithKEK);\nLOAD_SYM(authEncInit,             SDF_AuthEncInit);\nLOAD_SYM(authEncUpdate,           SDF_AuthEncUpdate);\nLOAD_SYM(authEncFinal,            SDF_AuthEncFinal);\nLOAD_SYM(authDecInit,             SDF_AuthDecInit);\nLOAD_SYM(authDecUpdate,           SDF_AuthDecUpdate);\nLOAD_SYM(authDecFinal,            SDF_AuthDecFinal);",
      "fix": "#define LOAD_SYM_OPTIONAL(field, sdfName) \\\n    do { g_sdfFunc.field = (typeof(g_sdfFunc.field))dlsym(g_sdfLibHandle, #sdfName); } while (0)\n\n/* Keep provider load compatible when optional SM4/GCM APIs are absent */\nLOAD_SYM_OPTIONAL(genKeyWithKek,    SDF_GenerateKeyWithKEK);\nLOAD_SYM_OPTIONAL(importKeyWithKek, SDF_ImportKeyWithKEK);\nLOAD_SYM_OPTIONAL(authEncInit,      SDF_AuthEncInit);\nLOAD_SYM_OPTIONAL(authEncUpdate,    SDF_AuthEncUpdate);\nLOAD_SYM_OPTIONAL(authEncFinal,     SDF_AuthEncFinal);\nLOAD_SYM_OPTIONAL(authDecInit,      SDF_AuthDecInit);\nLOAD_SYM_OPTIONAL(authDecUpdate,    SDF_AuthDecUpdate);\nLOAD_SYM_OPTIONAL(authDecFinal,     SDF_AuthDecFinal);"
    },
    {
      "file": "src/sm4_cipher.c",
      "line": "145",
      "severity": "medium",
      "title": "Hardcoded ECB algorithm ID for KEK import",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "The imported key's intended algorithm is ctx->sdfAlgId (which might be SGD_SM4_CBC), but SGD_SM4_ECB is hardcoded. Strict SDF hardware implementations will reject using an ECB key for CBC operations.",
      "code": "ret = SDF_DL_ImportKeyWithKEK(ctx->hSessionHandle, SGD_SM4_ECB, ctx->kekIndex,\n            (unsigned char *)key, keyLen, &ctx->hKeyHandle);",
      "fix": "ret = SDF_DL_ImportKeyWithKEK(ctx->hSessionHandle, ctx->sdfAlgId, ctx->kekIndex,\n            (unsigned char *)key, keyLen, &ctx->hKeyHandle);"
    },
    {
      "file": "src/sm4_cipher.c",
      "line": "258",
      "severity": "medium",
      "title": "Hardcoded ECB algorithm ID for KEK generation",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "When generating a key wrapped with KEK, its intended usage algorithm is hardcoded to SGD_SM4_ECB instead of the actual ctx->sdfAlgId (e.g., SGD_SM4_CBC). This limits the generated key from being used with CBC on strict devices.",
      "code": "int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, SGD_SM4_ECB,\n                ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);",
      "fix": "int ret = SDF_DL_GenerateKeyWithKEK(ctx->hSessionHandle, 128, ctx->sdfAlgId,\n                ctx->kekIndex, wrapBuf, &wrapLen, &ctx->hKeyHandle);"
    },
    {
      "file": "src/sm4_gcm.c",
      "line": "215-219",
      "severity": "medium",
      "title": "CRYPT_CTRL_SET_TAGLEN is ignored during encryption final",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "The ctrl handler stores requested tag length in ctx->tagLen, but GCM_Final always passes SM4_GCM_TAG_MAX to SDF_DL_AuthEncFinal, so caller-requested tag length is not honored.",
      "code": "unsigned int tagOutLen = SM4_GCM_TAG_MAX;\nret = SDF_DL_AuthEncFinal(ctx->hSessionHandle, out, &tmpLen, ctx->tag, &tagOutLen);\nif (ret == SDR_OK) {\n    ctx->tagLen = tagOutLen;\n}",
      "fix": "unsigned int tagOutLen = ctx->tagLen;\nret = SDF_DL_AuthEncFinal(ctx->hSessionHandle, out, &tmpLen, ctx->tag, &tagOutLen);\nif (ret == SDR_OK) {\n    if (tagOutLen == 0 || tagOutLen > SM4_GCM_TAG_MAX) {\n        return CRYPT_INVALID_ARG;\n    }\n    ctx->tagLen = tagOutLen;\n}"
    },
    {
      "file": "demo/sm4_gcm.c",
      "line": "91-93",
      "severity": "medium",
      "title": "Demo can return success even when encryption/decryption fails",
      "reviewers": "CODEX",
      "confidence": "trusted",
      "problem": "Several failure branches jump to cleanup without setting ret, and plaintext mismatch only prints [FAIL] but keeps ret==0. The final return ret can report success to CTest even on failure.",
      "code": "if (encCtx == NULL) {\n    fprintf(stderr, \"CipherNewCtx (enc) failed\\n\");\n    goto cleanup;\n}\n...\nif (decLen == ptLen && memcmp(decrypted, plaintext, ptLen) == 0) {\n    printf(\"\\n[PASS] Plaintext matches!\\n\");\n} else {\n    printf(\"\\n[FAIL] Plaintext mismatch!\\n\");\n}\n...\nreturn ret;",
      "fix": "if (encCtx == NULL) {\n    fprintf(stderr, \"CipherNewCtx (enc) failed\\n\");\n    ret = 1;\n    goto cleanup;\n}\n...\nif (decCtx == NULL) {\n    fprintf(stderr, \"CipherNewCtx (dec) failed\\n\");\n    ret = 1;\n    goto cleanup;\n}\n...\nif (decLen == ptLen && memcmp(decrypted, plaintext, ptLen) == 0) {\n    printf(\"\\n[PASS] Plaintext matches!\\n\");\n} else {\n    printf(\"\\n[FAIL] Plaintext mismatch!\\n\");\n    ret = 1;\n}\n...\nreturn (ret == 0) ? 0 : 1;"
    },
    {
      "file": "demo/sm4_cbc.c",
      "line": "1-2",
      "severity": "low",
      "title": "Duplicate stdio.h include",
      "reviewers": "CLAUDE, GEMINI",
      "confidence": "trusted",
      "problem": "Lines 1 and 2 both include <stdio.h>, which is redundant and creates a duplicate include.",
      "code": "#include <stdio.h>\n#include <stdio.h>",
      "fix": "#include <stdio.h>"
    },
    {
      "file": "demo/sm4_gcm.c",
      "line": "56",
      "severity": "low",
      "title": "Inconsistent library format macro usage",
      "reviewers": "CLAUDE",
      "confidence": "trusted",
      "problem": "sm4_gcm.c uses BSL_SAL_LIB_FMT_SO while all other demo files (sm3_hash.c, sm4_cbc.c, sm4_ecb.c, sm2_sign.c, etc.) use BSL_SAL_LIB_FMT_LIBSO. Inconsistency may cause compilation issues if only one macro is defined.",
      "code": "int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_SO, \"SDFProv\", provParams, NULL);",
      "fix": "int ret = CRYPT_EAL_ProviderLoad(libCtx, BSL_SAL_LIB_FMT_LIBSO, \"SDFProv\", provParams, NULL);"
    },
    {
      "file": "src/sm3_md.c",
      "line": "111-130",
      "severity": "low",
      "title": "Dead code - unused CRYPT_SM3_DupCtx function",
      "reviewers": "GEMINI",
      "confidence": "trusted",
      "problem": "CRYPT_SM3_DupCtx is defined as a static function but is never added to the g_EalMdSm3 function array, resulting in a compiler warning for unused static function. The implementation returns a fresh, uninitialized session state instead of a true clone, which is misleading.",
      "code": "static void *CRYPT_SM3_DupCtx(const void *c)\n{\n    const SDFP_SM3_Ctx *src = (const SDFP_SM3_Ctx *)c;\n    if (src == NULL || src->hSessionHandle == NULL) {\n        return NULL;\n    }\n    /* Duplicate by opening a fresh session; hash state is not cloned */\n    SDFP_SM3_Ctx *dst = (SDFP_SM3_Ctx *)BSL_SAL_Calloc(1u, sizeof(SDFP_SM3_Ctx));\n    if (dst == NULL) {\n        return NULL;\n    }\n    int ret = SDF_DL_OpenSession(src->hDeviceHandle, &dst->hSessionHandle);\n    if (ret != SDR_OK) {\n        BSL_ERR_PUSH_ERROR(ret);\n        BSL_SAL_Free(dst);\n        return NULL;\n    }\n    dst->hDeviceHandle = src->hDeviceHandle;\n    return dst;\n}",
      "fix": "/* Removed CRYPT_SM3_DupCtx as SDF hash state cannot be cloned and it's unused */"
    }
  ]
}