<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/pqcp#33 - CODEX</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/pqcp#33 - CODEX</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Partial initialization left behind on allocation failure</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:190-199</div>
                <pre>ctx-&gt;pqcMethod = pqcMethod;
ctx-&gt;tradMethod = tradMethod;
ctx-&gt;pqcCtx = pqcMethod-&gt;newCtx();
RETURN_RET_IF((ctx-&gt;pqcCtx == NULL), CRYPT_MEM_ALLOC_FAIL);
ctx-&gt;tradCtx = tradMethod-&gt;newCtx();
if (ctx-&gt;tradCtx == NULL) {
    pqcMethod-&gt;freeCtx(ctx-&gt;pqcCtx);
    ctx-&gt;pqcCtx = NULL;
    return CRYPT_MEM_ALLOC_FAIL;
}</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_CompositeSetAlgInfo` sets `ctx->info` and method pointers before allocating subcontexts. If `newCtx()` fails, the function returns with `ctx->info` still set and `ctx->pqcCtx`/`ctx->tradCtx` null. This makes the context unrecoverable (`SET_PARA_BY_ID` returns “already set”) and can later hit null subcontext paths.</div>
                <div class="fix-label">Fix:</div><pre>const COMPOSITE_ALG_INFO *info = CRYPT_COMPOSITE_GetInfo(*(int32_t *)val);
if (info == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_INVALID_ARG);
    return CRYPT_INVALID_ARG;
}

const EAL_PkeyMethod *pqcMethod = CRYPT_EAL_PkeyFindMethod(info-&gt;pqcAlg);
const EAL_PkeyMethod *tradMethod = CRYPT_EAL_PkeyFindMethod(info-&gt;tradAlg);
RETURN_RET_IF((pqcMethod == NULL || tradMethod == NULL), CRYPT_NOT_SUPPORT);

void *pqcCtx = pqcMethod-&gt;newCtx();
RETURN_RET_IF(pqcCtx == NULL, CRYPT_MEM_ALLOC_FAIL);

void *tradCtx = tradMethod-&gt;newCtx();
if (tradCtx == NULL) {
    pqcMethod-&gt;freeCtx(pqcCtx);
    return CRYPT_MEM_ALLOC_FAIL;
}

ctx-&gt;info = info;
ctx-&gt;pqcMethod = pqcMethod;
ctx-&gt;tradMethod = tradMethod;
ctx-&gt;pqcCtx = pqcCtx;
ctx-&gt;tradCtx = tradCtx;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">Public PolarLAC control IDs no longer handled</div>
                <div class="issue-location">src/polarlac/src/polarlac.c:263-290</div>
                <pre>switch (cmd) {
    case CRYPT_CTRL_SET_PARA_BY_ID:
        return PolarLacSetAlgInfo(ctx, val, valLen);
    case CRYPT_CTRL_GET_CIPHERTEXT_LEN:
        ...
    case CRYPT_CTRL_GET_PRVKEY_LEN:
        ...
    case CRYPT_CTRL_GET_PUBKEY_LEN:
        ...</pre>
                <div class="problem"><strong>Issue:</strong> The control switch now accepts only generic `CRYPT_CTRL_*` IDs, but `include/pqcp_types.h` still exposes `PQCP_POLAR_LAC_*` IDs and existing callers use them. This is a runtime compatibility break (`PQCP_INVALID_ARG`) for existing API users.</div>
                <div class="fix-label">Fix:</div><pre>switch (cmd) {
    case PQCP_POLAR_LAC_SET_PARAMS_BY_ID:
    case CRYPT_CTRL_SET_PARA_BY_ID:
        return PolarLacSetAlgInfo(ctx, val, valLen);

    case PQCP_POLAR_LAC_GET_CIPHER_LEN:
    case CRYPT_CTRL_GET_CIPHERTEXT_LEN:
        ...

    case PQCP_POLAR_LAC_GET_PRVKEY_LEN:
    case CRYPT_CTRL_GET_PRVKEY_LEN:
        ...

    case PQCP_POLAR_LAC_GET_PUBKEY_LEN:
    case CRYPT_CTRL_GET_PUBKEY_LEN:
        ...</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">DupCtx does not copy signing context info</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:125-137</div>
                <pre>newCtx-&gt;info = ctx-&gt;info;
...
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;
newCtx-&gt;libCtx = ctx-&gt;libCtx;
return newCtx;</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_COMPOSITE_DupCtx` duplicates keys/methods but drops `ctxInfo`/`ctxLen`. Any context string set via `CRYPT_CTRL_SET_CTX_INFO` is lost in the duplicate, so signatures from original and duplicate can diverge unexpectedly.</div>
                <div class="fix-label">Fix:</div><pre>newCtx-&gt;info = ctx-&gt;info;
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;
newCtx-&gt;libCtx = ctx-&gt;libCtx;

if (ctx-&gt;ctxLen &gt; 0) {
    newCtx-&gt;ctxInfo = BSL_SAL_Dump(ctx-&gt;ctxInfo, ctx-&gt;ctxLen);
    if (newCtx-&gt;ctxInfo == NULL) {
        BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
        goto ERR;
    }
    newCtx-&gt;ctxLen = ctx-&gt;ctxLen;
}
return newCtx;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">SetCtxInfo rejects valid clear operation and misclassifies null input</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:212-227</div>
                <pre>if (len &gt; COMPOSITE_MAX_CTX_BYTES) {
    ...
}
if (ctx-&gt;ctxInfo != NULL) {
    BSL_SAL_FREE(ctx-&gt;ctxInfo);
    ctx-&gt;ctxLen = 0;
}
ctx-&gt;ctxInfo = BSL_SAL_Dump((uint8_t *)val, len);
if (ctx-&gt;ctxInfo == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
    return CRYPT_MEM_ALLOC_FAIL;
}
ctx-&gt;ctxLen = len;</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_CompositeSetctxInfo` always calls `BSL_SAL_Dump(val, len)`. With `len == 0`, `BSL_SAL_Dump` returns null and this path returns `CRYPT_MEM_ALLOC_FAIL`, so callers cannot clear context info. Also `val == NULL && len > 0` is treated as allocation failure instead of null input.</div>
                <div class="fix-label">Fix:</div><pre>if (len &gt; COMPOSITE_MAX_CTX_BYTES) {
    BSL_ERR_PUSH_ERROR(PQCP_COMPOSITE_KEYLEN_ERROR);
    return PQCP_COMPOSITE_KEYLEN_ERROR;
}

if (len == 0) {
    BSL_SAL_FREE(ctx-&gt;ctxInfo);
    ctx-&gt;ctxInfo = NULL;
    ctx-&gt;ctxLen = 0;
    return CRYPT_SUCCESS;
}

if (val == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_NULL_INPUT);
    return CRYPT_NULL_INPUT;
}

BSL_SAL_FREE(ctx-&gt;ctxInfo);
ctx-&gt;ctxInfo = BSL_SAL_Dump(val, len);
if (ctx-&gt;ctxInfo == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
    return CRYPT_MEM_ALLOC_FAIL;
}
ctx-&gt;ctxLen = len;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Uninitialized context pointers freed on error path</div>
                <div class="issue-location">test/demo/composite_sign_demo.c:22-23</div>
                <pre>CRYPT_EAL_PkeyCtx *signCtx;
CRYPT_EAL_PkeyCtx *verifyCtx;
...
EXIT:
    CRYPT_EAL_PkeyFreeCtx(signCtx);
    CRYPT_EAL_PkeyFreeCtx(verifyCtx);</pre>
                <div class="problem"><strong>Issue:</strong> `signCtx` and `verifyCtx` are uninitialized. If context creation fails and execution jumps to `EXIT`, `CRYPT_EAL_PkeyFreeCtx` may be called on garbage pointers.</div>
                <div class="fix-label">Fix:</div><pre>CRYPT_EAL_PkeyCtx *signCtx = NULL;
CRYPT_EAL_PkeyCtx *verifyCtx = NULL;
...
EXIT:
    CRYPT_EAL_PkeyFreeCtx(signCtx);
    CRYPT_EAL_PkeyFreeCtx(verifyCtx);</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
</div></body></html>