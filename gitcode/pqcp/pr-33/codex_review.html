<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/pqcp#33 - CODEX</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/pqcp#33 - CODEX</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Hybrid length controls can dereference NULL `val`</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:29-42</div>
                <pre>#define CHECK_UINT32_LEN_AND_INFO(ctx, len)                      \
    do                                                           \
    {                                                            \
        if (len != sizeof(uint32_t))                             \
        {                                                        \
            BSL_ERR_PUSH_ERROR(CRYPT_INVALID_ARG);               \
            return CRYPT_INVALID_ARG;                            \
        }                                                        \
        if (ctx-&gt;info == NULL)                                   \
        {                                                        \
            BSL_ERR_PUSH_ERROR(PQCP_COMPOSITE_KEYINFO_NOT_SET); \
            return PQCP_COMPOSITE_KEYINFO_NOT_SET;              \
        }                                                        \
    } while (0)

case PQCP_CTRL_HYBRID_GET_PQC_PRVKEY_LEN:
    CHECK_UINT32_LEN_AND_INFO(ctx, len);
    *(uint32_t *)val = MLDSA_SEED_LEN;
    return CRYPT_SUCCESS;</pre>
                <div class="problem"><strong>Issue:</strong> `CHECK_UINT32_LEN_AND_INFO` validates `len` and `ctx->info` but never validates `val`. In `PQCP_CTRL_HYBRID_GET_PQC_PRVKEY_LEN`, `val` is dereferenced unconditionally, which can crash on `CRYPT_COMPOSITE_Ctrl(ctx, ..., NULL, sizeof(uint32_t))`.</div>
                <div class="fix-label">Fix:</div><pre>#define CHECK_UINT32_LEN_AND_INFO(ctx, val, len)                        \
    do                                                                   \
    {                                                                    \
        if ((val) == NULL || (len) != sizeof(uint32_t))                 \
        {                                                                \
            BSL_ERR_PUSH_ERROR(CRYPT_INVALID_ARG);                       \
            return CRYPT_INVALID_ARG;                                    \
        }                                                                \
        if ((ctx)-&gt;info == NULL || (ctx)-&gt;pqcCtx == NULL || (ctx)-&gt;tradCtx == NULL) \
        {                                                                \
            BSL_ERR_PUSH_ERROR(PQCP_COMPOSITE_KEYINFO_NOT_SET);         \
            return PQCP_COMPOSITE_KEYINFO_NOT_SET;                      \
        }                                                                \
    } while (0)

case PQCP_CTRL_HYBRID_GET_PQC_PRVKEY_LEN:
    CHECK_UINT32_LEN_AND_INFO(ctx, val, len);
    *(uint32_t *)val = MLDSA_SEED_LEN;
    return CRYPT_SUCCESS;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Failed `SET_PARA_BY_ID` leaves context in partially initialized state</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:190-199</div>
                <pre>ctx-&gt;pqcMethod = pqcMethod;
ctx-&gt;tradMethod = tradMethod;
ctx-&gt;pqcCtx = pqcMethod-&gt;newCtx();
RETURN_RET_IF((ctx-&gt;pqcCtx == NULL), CRYPT_MEM_ALLOC_FAIL);
ctx-&gt;tradCtx = tradMethod-&gt;newCtx();
if (ctx-&gt;tradCtx == NULL) {
    pqcMethod-&gt;freeCtx(ctx-&gt;pqcCtx);
    ctx-&gt;pqcCtx = NULL;
    return CRYPT_MEM_ALLOC_FAIL;
}</pre>
                <div class="problem"><strong>Issue:</strong> On `pqcMethod->newCtx()` or `tradMethod->newCtx()` failure, the function returns early after already setting `ctx->info`, `ctx->pqcMethod`, and `ctx->tradMethod`. This leaves the context unusable (`KEY_INFO_ALREADY_SET` on retry) and inconsistent.</div>
                <div class="fix-label">Fix:</div><pre>void *pqcCtx = pqcMethod-&gt;newCtx();
if (pqcCtx == NULL) {
    return CRYPT_MEM_ALLOC_FAIL;
}
void *tradCtx = tradMethod-&gt;newCtx();
if (tradCtx == NULL) {
    pqcMethod-&gt;freeCtx(pqcCtx);
    return CRYPT_MEM_ALLOC_FAIL;
}
int32_t pqcParam = info-&gt;pqcParam;
ret = pqcMethod-&gt;ctrl(pqcCtx, CRYPT_CTRL_SET_PARA_BY_ID, &amp;pqcParam, sizeof(pqcParam));
if (ret != CRYPT_SUCCESS) {
    pqcMethod-&gt;freeCtx(pqcCtx);
    tradMethod-&gt;freeCtx(tradCtx);
    return ret;
}

ctx-&gt;info = info;
ctx-&gt;pqcMethod = pqcMethod;
ctx-&gt;tradMethod = tradMethod;
ctx-&gt;pqcCtx = pqcCtx;
ctx-&gt;tradCtx = tradCtx;</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">`DupCtx` leaks duplicated sub-context on partial failure</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:125-139</div>
                <pre>newCtx-&gt;info = ctx-&gt;info;
if (ctx-&gt;pqcMethod != NULL &amp;&amp; ctx-&gt;tradMethod != NULL) {
    newCtx-&gt;pqcCtx = ctx-&gt;pqcMethod-&gt;dupCtx(ctx-&gt;pqcCtx);
    newCtx-&gt;tradCtx = ctx-&gt;tradMethod-&gt;dupCtx(ctx-&gt;tradCtx);
    if (newCtx-&gt;pqcCtx == NULL || newCtx-&gt;tradCtx == NULL) {
        BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
        goto ERR;
    }
}
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;</pre>
                <div class="problem"><strong>Issue:</strong> `newCtx->pqcMethod`/`tradMethod` are assigned only after duplication. If one duplication succeeds and the other fails, `CRYPT_COMPOSITE_FreeCtx(newCtx)` cannot free the already duplicated sub-context because method pointers are still NULL.</div>
                <div class="fix-label">Fix:</div><pre>newCtx-&gt;info = ctx-&gt;info;
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;

if (newCtx-&gt;pqcMethod != NULL &amp;&amp; newCtx-&gt;tradMethod != NULL) {
    newCtx-&gt;pqcCtx = newCtx-&gt;pqcMethod-&gt;dupCtx(ctx-&gt;pqcCtx);
    newCtx-&gt;tradCtx = newCtx-&gt;tradMethod-&gt;dupCtx(ctx-&gt;tradCtx);
    if (newCtx-&gt;pqcCtx == NULL || newCtx-&gt;tradCtx == NULL) {
        if (newCtx-&gt;pqcCtx != NULL) {
            newCtx-&gt;pqcMethod-&gt;freeCtx(newCtx-&gt;pqcCtx);
            newCtx-&gt;pqcCtx = NULL;
        }
        if (newCtx-&gt;tradCtx != NULL) {
            newCtx-&gt;tradMethod-&gt;freeCtx(newCtx-&gt;tradCtx);
            newCtx-&gt;tradCtx = NULL;
        }
        BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
        goto ERR;
    }
}</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">`DupCtx` does not copy context-binding data (`ctxInfo`)</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:125-137</div>
                <pre>newCtx-&gt;info = ctx-&gt;info;
...
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;
newCtx-&gt;libCtx = ctx-&gt;libCtx;
return newCtx;</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_COMPOSITE_DupCtx` copies key contexts but not `ctxInfo`/`ctxLen`. Sign/verify encoding uses `ctxInfo`, so duplicated contexts can produce different signatures from the original when context info is set.</div>
                <div class="fix-label">Fix:</div><pre>newCtx-&gt;info = ctx-&gt;info;
newCtx-&gt;pqcMethod = ctx-&gt;pqcMethod;
newCtx-&gt;tradMethod = ctx-&gt;tradMethod;
newCtx-&gt;libCtx = ctx-&gt;libCtx;
newCtx-&gt;ctxLen = ctx-&gt;ctxLen;

if (ctx-&gt;ctxLen &gt; 0) {
    newCtx-&gt;ctxInfo = BSL_SAL_Dump(ctx-&gt;ctxInfo, ctx-&gt;ctxLen);
    if (newCtx-&gt;ctxInfo == NULL) {
        BSL_ERR_PUSH_ERROR(CRYPT_MEM_ALLOC_FAIL);
        goto ERR;
    }
}</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
<div class="issue">
                <div class="issue-title">Control command compatibility regression for PolarLAC</div>
                <div class="issue-location">src/polarlac/src/polarlac.c:263-284</div>
                <pre>switch (cmd) {
    case CRYPT_CTRL_SET_PARA_BY_ID:
        return PolarLacSetAlgInfo(ctx, val, valLen);
    case CRYPT_CTRL_GET_CIPHERTEXT_LEN:
        ...
    case CRYPT_CTRL_GET_PRVKEY_LEN:
        ...
    case CRYPT_CTRL_GET_PUBKEY_LEN:
        ...
    default:
        return PQCP_INVALID_ARG;
}</pre>
                <div class="problem"><strong>Issue:</strong> The control switch dropped support for existing `PQCP_POLAR_LAC_*` command IDs and only accepts `CRYPT_CTRL_*`. Existing callers using documented PQCP command IDs now get `PQCP_INVALID_ARG`.</div>
                <div class="fix-label">Fix:</div><pre>switch (cmd) {
    case CRYPT_CTRL_SET_PARA_BY_ID:
    case PQCP_POLAR_LAC_SET_PARAMS_BY_ID:
        return PolarLacSetAlgInfo(ctx, val, valLen);

    case CRYPT_CTRL_GET_CIPHERTEXT_LEN:
    case PQCP_POLAR_LAC_GET_CIPHER_LEN:
        ...

    case CRYPT_CTRL_GET_PRVKEY_LEN:
    case PQCP_POLAR_LAC_GET_PRVKEY_LEN:
        ...

    case CRYPT_CTRL_GET_PUBKEY_LEN:
    case PQCP_POLAR_LAC_GET_PUBKEY_LEN:
        ...
}</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Uninitialized pointer may be freed on early error path</div>
                <div class="issue-location">test/demo/composite_sign_demo.c:22-23</div>
                <pre>int32_t ret = -1;
CRYPT_EAL_PkeyCtx *signCtx;
CRYPT_EAL_PkeyCtx *verifyCtx;
...
EXIT:
    CRYPT_EAL_PkeyFreeCtx(signCtx);
    CRYPT_EAL_PkeyFreeCtx(verifyCtx);</pre>
                <div class="problem"><strong>Issue:</strong> `verifyCtx` is not initialized before possible `goto EXIT`, but `CRYPT_EAL_PkeyFreeCtx(verifyCtx)` is always called in `EXIT`. If `signCtx` creation fails, `verifyCtx` is indeterminate and freeing it is undefined behavior.</div>
                <div class="fix-label">Fix:</div><pre>int32_t ret = -1;
CRYPT_EAL_PkeyCtx *signCtx = NULL;
CRYPT_EAL_PkeyCtx *verifyCtx = NULL;
...
EXIT:
    CRYPT_EAL_PkeyFreeCtx(signCtx);
    CRYPT_EAL_PkeyFreeCtx(verifyCtx);</pre>
                <div class="issue-source">Reviewer: codex</div>
            </div>
</div>
</div></body></html>