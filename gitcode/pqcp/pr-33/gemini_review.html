<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review: openHiTLS/pqcp#33 - GEMINI</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem; }
        .issue-source { font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Review: openHiTLS/pqcp#33 - GEMINI</h1>
        <div class="subtitle"></div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Missing NULL Check for Input Parameter</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:228</div>
                <pre>static int32_t CRYPT_CompositeSetctxInfo(CRYPT_CompositeCtx *ctx, void *val, uint32_t len)
{
    if (len &gt; COMPOSITE_MAX_CTX_BYTES) {
        BSL_ERR_PUSH_ERROR(PQCP_COMPOSITE_KEYLEN_ERROR);
        return PQCP_COMPOSITE_KEYLEN_ERROR;
    }
    if (ctx-&gt;ctxInfo != NULL) {</pre>
                <div class="problem"><strong>Issue:</strong> The function `CRYPT_CompositeSetctxInfo` does not check if `val` is NULL before passing it to `BSL_SAL_Dump` (which presumably copies from it). If `len > 0` but `val` is NULL, this will likely cause a segmentation fault.</div>
                <div class="fix-label">Fix:</div><pre>static int32_t CRYPT_CompositeSetctxInfo(CRYPT_CompositeCtx *ctx, void *val, uint32_t len)
{
    if (len &gt; COMPOSITE_MAX_CTX_BYTES) {
        BSL_ERR_PUSH_ERROR(PQCP_COMPOSITE_KEYLEN_ERROR);
        return PQCP_COMPOSITE_KEYLEN_ERROR;
    }
    if (val == NULL &amp;&amp; len &gt; 0) {
        BSL_ERR_PUSH_ERROR(CRYPT_NULL_INPUT);
        return CRYPT_NULL_INPUT;
    }
    if (ctx-&gt;ctxInfo != NULL) {</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Ignored Return Value of Secure Memory Copy</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:541-546</div>
                <pre>(void)memcpy_s(ptr, msg-&gt;len, PREFIX, prefixLen);
    ptr += prefixLen;
    (void)memcpy_s(ptr, msg-&gt;len - prefixLen, label, labelLen);
    ptr += labelLen;
    *ptr = ctx-&gt;ctxLen;
    ptr++;
    if (ctx-&gt;ctxInfo != NULL &amp;&amp; ctx-&gt;ctxLen &gt; 0) {
        (void)memcpy_s(ptr, msg-&gt;len - (prefixLen + labelLen + 1), ctx-&gt;ctxInfo, ctx-&gt;ctxLen);
        ptr += ctx-&gt;ctxLen;
    }</pre>
                <div class="problem"><strong>Issue:</strong> The return value of `memcpy_s` is explicitly ignored (`(void)memcpy_s(...)`) in `CompositeMsgEncode`. If `memcpy_s` fails (e.g., due to invalid overlap or size parameters), the destination buffer `msg->data` will contain uninitialized or partial data. The function then returns `CRYPT_SUCCESS`, causing the caller to sign/verify this invalid data.</div>
                <div class="fix-label">Fix:</div><pre>if (memcpy_s(ptr, msg-&gt;len, PREFIX, prefixLen) != EOK) {
        BSL_SAL_FREE(msg-&gt;data);
        return CRYPT_MEM_CPY_FAIL;
    }
    ptr += prefixLen;
    if (memcpy_s(ptr, msg-&gt;len - prefixLen, label, labelLen) != EOK) {
        BSL_SAL_FREE(msg-&gt;data);
        return CRYPT_MEM_CPY_FAIL;
    }
    ptr += labelLen;
    *ptr = ctx-&gt;ctxLen;
    ptr++;
    if (ctx-&gt;ctxInfo != NULL &amp;&amp; ctx-&gt;ctxLen &gt; 0) {
        if (memcpy_s(ptr, msg-&gt;len - (prefixLen + labelLen + 1), ctx-&gt;ctxInfo, ctx-&gt;ctxLen) != EOK) {
            BSL_SAL_FREE(msg-&gt;data);
            return CRYPT_MEM_CPY_FAIL;
        }
        ptr += ctx-&gt;ctxLen;
    }</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Breaking API Change in Parameter IDs</div>
                <div class="issue-location">include/pqcp_types.h:22-42</div>
                <pre>#define PQCP_PARAM_BASE 5000
#define PQCP_PARAM_SCLOUDPLUS_BASE (PQCP_PARAM_BASE + 100)
// ...
#define PQCP_PARAM_FRODOKEM_BASE (PQCP_PARAM_BASE + 200)</pre>
                <div class="problem"><strong>Issue:</strong> The parameter ID base values have changed significantly (e.g., `CRYPT_PARAM_SCLOUDPLUS_BASE` 900 -> `PQCP_PARAM_SCLOUDPLUS_BASE` 5100). This is a binary and source incompatibility for any external application relying on the old values. While the rename suggests an API refactor, changing the underlying integer values breaks ABI with existing compiled code.</div>
                <div class="fix-label">Fix:</div><pre>/* Ensure these values align with external expectations or version the API explicitly. 
   If backward compatibility is required, restore original values: */
#define PQCP_PARAM_BASE 900 // Adjusted base if necessary
// Or map specific bases back to 900, 1000, 1100, 1200 as before.</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">Incomplete Public Key Length Validation</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:366</div>
                <pre>RETURN_RET_IF(pub-&gt;len &lt;= ctx-&gt;info-&gt;pqcPubkeyLen, PQCP_COMPOSITE_KEYLEN_ERROR);

    BSL_Buffer pqcPub = {pub-&gt;data, ctx-&gt;info-&gt;pqcPubkeyLen};
    BSL_Buffer tradPub = {pub-&gt;data + ctx-&gt;info-&gt;pqcPubkeyLen, pub-&gt;len - ctx-&gt;info-&gt;pqcPubkeyLen};</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_COMPOSITE_SetPubKey` checks if `pub->len` is greater than `pqcPubkeyLen`, but it does not check if `pub->len` exactly matches the expected composite public key length (`ctx->info->compPubKeyLen`). Excessively large `pub->len` will result in a larger-than-expected `tradPub` buffer being passed to the traditional method, relying on that method's validation which may be insufficient.</div>
                <div class="fix-label">Fix:</div><pre>RETURN_RET_IF(pub-&gt;len != ctx-&gt;info-&gt;compPubKeyLen, PQCP_COMPOSITE_KEYLEN_ERROR);

    BSL_Buffer pqcPub = {pub-&gt;data, ctx-&gt;info-&gt;pqcPubkeyLen};
    BSL_Buffer tradPub = {pub-&gt;data + ctx-&gt;info-&gt;pqcPubkeyLen, pub-&gt;len - ctx-&gt;info-&gt;pqcPubkeyLen};</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
<div class="issue">
                <div class="issue-title">Incomplete Private Key Length Validation</div>
                <div class="issue-location">src/composite_sign/src/crypt_composite_sign.c:351</div>
                <pre>RETURN_RET_IF(prv-&gt;len &lt;= ctx-&gt;info-&gt;pqcPrvkeyLen, PQCP_COMPOSITE_KEYLEN_ERROR);
    BSL_Buffer pqcPrv = {prv-&gt;data, ctx-&gt;info-&gt;pqcPrvkeyLen};
    BSL_Buffer tradPrv = {prv-&gt;data + ctx-&gt;info-&gt;pqcPrvkeyLen, prv-&gt;len - ctx-&gt;info-&gt;pqcPrvkeyLen};</pre>
                <div class="problem"><strong>Issue:</strong> `CRYPT_COMPOSITE_SetPrvKey` checks if `prv->len` is greater than `pqcPrvkeyLen`, but does not enforce that `prv->len` matches `ctx->info->compPrvKeyLen`. This allows passing arbitrarily large buffers as the private key, potentially causing issues in the underlying traditional key setter.</div>
                <div class="fix-label">Fix:</div><pre>RETURN_RET_IF(prv-&gt;len != ctx-&gt;info-&gt;compPrvKeyLen, PQCP_COMPOSITE_KEYLEN_ERROR);
    BSL_Buffer pqcPrv = {prv-&gt;data, ctx-&gt;info-&gt;pqcPrvkeyLen};
    BSL_Buffer tradPrv = {prv-&gt;data + ctx-&gt;info-&gt;pqcPrvkeyLen, prv-&gt;len - ctx-&gt;info-&gt;pqcPrvkeyLen};</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Commented Out Error Handling</div>
                <div class="issue-location">src/provider/pqcp_pkey.c:51</div>
                <pre>if (pkeyCtx == NULL) {
        // BSL_ERR_PUSH_ERROR(CRYPT_PROVIDER_NOT_SUPPORT);
        return NULL;
    }</pre>
                <div class="problem"><strong>Issue:</strong> The error reporting macro `BSL_ERR_PUSH_ERROR` is commented out. If context creation fails (e.g., unsupported algorithm), the function returns NULL without pushing an error code to the stack, making diagnostics difficult.</div>
                <div class="fix-label">Fix:</div><pre>if (pkeyCtx == NULL) {
        BSL_ERR_PUSH_ERROR(CRYPT_PROVIDER_NOT_SUPPORT);
        return NULL;
    }</pre>
                <div class="issue-source">Reviewer: gemini</div>
            </div>
</div>
</div></body></html>