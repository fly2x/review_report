===ISSUE===
FILE: src/provider/pqcp_pkey.c
LINE: 145
SEVERITY: high
TITLE: Duplicate const qualifier breaks build
PROBLEM: The declaration uses `const const`, which is invalid C and will not compile.
CODE:
```
const const CRYPT_EAL_Func g_pqcpKeyMgmtCompositeSign[] = {
```
FIX:
```
const CRYPT_EAL_Func g_pqcpKeyMgmtCompositeSign[] = {
```
===END===

===ISSUE===
FILE: src/composite_sign/src/crypt_composite_sign.c
LINE: 386-388
SEVERITY: high
TITLE: Traditional private key slice uses wrong buffer pointer
PROBLEM: The SM2 private key buffer is initialized from the start of the composite key (and with an extra initializer), so the PQC seed is reused as the TRAD key. This corrupts key imports and can cause invalid keys or failures.
CODE:
```
BSL_Buffer pqcPrv = {prv->data, ctx->info->pqcPrvkeyLen};
BSL_Buffer tradPrv = {prv->data, + ctx->info->pqcPrvkeyLen, prv->len - ctx->info->pqcPrvkeyLen};
```
FIX:
```
BSL_Buffer pqcPrv = {prv->data, ctx->info->pqcPrvkeyLen};
BSL_Buffer tradPrv = {prv->data + ctx->info->pqcPrvkeyLen,
                      prv->len - ctx->info->pqcPrvkeyLen};
```
===END===

===ISSUE===
FILE: src/composite_sign/src/crypt_composite_sign.c
LINE: 385-399
SEVERITY: medium
TITLE: Composite key setters accept truncated keys
PROBLEM: The length checks only ensure the buffer is larger than the PQC part, so a too-short TRAD component can be accepted, resulting in malformed keys and undefined behavior in downstream algorithms.
CODE:
```
RETURN_RET_IF(prv->len <= ctx->info->pqcPrvkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);
...
RETURN_RET_IF(pub->len <= ctx->info->pqcPubkeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);
```
FIX:
```
RETURN_RET_IF(prv->len != ctx->info->compPrvKeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);
...
RETURN_RET_IF(pub->len != ctx->info->compPubKeyLen, CRYPT_COMPOSITE_KEYLEN_ERROR);
```
===END===

===ISSUE===
FILE: src/composite_sign/src/crypt_composite_sign.c
LINE: 214-225
SEVERITY: medium
TITLE: CRYPT_CTRL_SET_CTX_INFO allows NULL input with non-zero length
PROBLEM: `val` is not validated before being copied. If the caller passes `len > 0` with `val == NULL`, `BSL_SAL_Dump` will dereference NULL and crash.
CODE:
```
if (len > COMPOSITE_MAX_CTX_BYTES) {
    BSL_ERR_PUSH_ERROR(CRYPT_COMPOSITE_KEYLEN_ERROR);
    return CRYPT_COMPOSITE_KEYLEN_ERROR;
}
...
ctx->ctxInfo = BSL_SAL_Dump((uint8_t *)val, len);
```
FIX:
```
if (len > COMPOSITE_MAX_CTX_BYTES) {
    BSL_ERR_PUSH_ERROR(CRYPT_COMPOSITE_KEYLEN_ERROR);
    return CRYPT_COMPOSITE_KEYLEN_ERROR;
}
if (val == NULL && len > 0) {
    BSL_ERR_PUSH_ERROR(CRYPT_NULL_INPUT);
    return CRYPT_NULL_INPUT;
}
ctx->ctxInfo = BSL_SAL_Dump((uint8_t *)val, len);
```
===END===

===ISSUE===
FILE: src/composite_sign/src/crypt_composite_sign.c
LINE: 414-435
SEVERITY: medium
TITLE: Missing NULL checks for GetParamValue results in Get*KeyEx
PROBLEM: If the requested param is absent, `GetParamValue` can return NULL and `paramPrv/paramPub` are dereferenced, causing a crash instead of returning an error.
CODE:
```
BSL_Param *paramPrv = GetParamValue(para, CRYPT_PARAM_COMPOSITE_PRVKEY, &prv.data, &(prv.len));
int32_t ret = CRYPT_COMPOSITE_GetPrvKey(ctx, &prv);
if (ret != CRYPT_SUCCESS) {
    return ret;
}
paramPrv->useLen = prv.len;

BSL_Param *paramPub = GetParamValue(para, CRYPT_PARAM_COMPOSITE_PUBKEY, &pub.data, &(pub.len));
int32_t ret = CRYPT_COMPOSITE_GetPubKey(ctx, &pub);
if (ret != CRYPT_SUCCESS) {
    return ret;
}
paramPub->useLen = pub.len;
```
FIX:
```
BSL_Param *paramPrv = GetParamValue(para, CRYPT_PARAM_COMPOSITE_PRVKEY, &prv.data, &(prv.len));
if (paramPrv == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_INVALID_ARG);
    return CRYPT_INVALID_ARG;
}
int32_t ret = CRYPT_COMPOSITE_GetPrvKey(ctx, &prv);
if (ret != CRYPT_SUCCESS) {
    return ret;
}
paramPrv->useLen = prv.len;

BSL_Param *paramPub = GetParamValue(para, CRYPT_PARAM_COMPOSITE_PUBKEY, &pub.data, &(pub.len));
if (paramPub == NULL) {
    BSL_ERR_PUSH_ERROR(CRYPT_INVALID_ARG);
    return CRYPT_INVALID_ARG;
}
int32_t ret = CRYPT_COMPOSITE_GetPubKey(ctx, &pub);
if (ret != CRYPT_SUCCESS) {
    return ret;
}
paramPub->useLen = pub.len;
```
===END===

===ISSUE===
FILE: src/composite_sign/src/crypt_composite_sign.c
LINE: 54-58
SEVERITY: medium
TITLE: Composite algorithm labels mismatched for MLDSA65/87
PROBLEM: The MLDSA65 and MLDSA87 entries use the MLDSA44 label, so the domain-separation label in the signed message is incorrect for those variants. This can break interoperability and produce non-spec signatures.
CODE:
```
{CRYPT_COMPOSITE_MLDSA65_SM2, "COMPSIG-MLDSA44-SM2", CRYPT_PKEY_ML_DSA, CRYPT_MLDSA_TYPE_MLDSA_65,
    CRYPT_PKEY_SM2, 0, CRYPT_MD_SM3, CRYPT_MD_SM3, 0, 2017, 64, 1952, 32, 3309,
},
{CRYPT_COMPOSITE_MLDSA87_SM2, "COMPSIG-MLDSA44-SM2", CRYPT_PKEY_ML_DSA, CRYPT_MLDSA_TYPE_MLDSA_87,
    CRYPT_PKEY_SM2, 0, CRYPT_MD_SM3, CRYPT_MD_SM3, 0, 2657, 64, 2592, 32, 4627,
},
```
FIX:
```
{CRYPT_COMPOSITE_MLDSA65_SM2, "COMPSIG-MLDSA65-SM2", CRYPT_PKEY_ML_DSA, CRYPT_MLDSA_TYPE_MLDSA_65,
    CRYPT_PKEY_SM2, 0, CRYPT_MD_SM3, CRYPT_MD_SM3, 0, 2017, 64, 1952, 32, 3309,
},
{CRYPT_COMPOSITE_MLDSA87_SM2, "COMPSIG-MLDSA87-SM2", CRYPT_PKEY_ML_DSA, CRYPT_MLDSA_TYPE_MLDSA_87,
    CRYPT_PKEY_SM2, 0, CRYPT_MD_SM3, CRYPT_MD_SM3, 0, 2657, 64, 2592, 32, 4627,
},
```
===END===