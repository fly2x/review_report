<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Report: openHiTLS/openhitls#993</title>
    <style>
        :root { --critical: #dc2626; --high: #ea580c; --medium: #ca8a04; --low: #65a30d;
                 --trusted: #059669; --likely: #0284c7; --evaluate: #7c3aed; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #f8fafc; color: #1e293b; padding: 2rem; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        .subtitle { color: #64748b; margin-bottom: 1rem; }
        .stats { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .stat { background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; min-width: 100px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.875rem; color: #64748b; }
        .stat.critical .stat-value { color: var(--critical); }
        .stat.high .stat-value { color: var(--high); }
        .stat.medium .stat-value { color: var(--medium); }
        .stat.low .stat-value { color: var(--low); }
        .reviewers { background: #e0e7ff; color: #3730a3; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 2rem; }
        .section { margin-bottom: 2rem; }
        .section-title { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; color: white; }
        .section-title.critical { background: var(--critical); }
        .section-title.high { background: var(--high); }
        .section-title.medium { background: var(--medium); }
        .section-title.low { background: var(--low); }
        .issue { background: white; border: 1px solid #e2e8f0; border-top: none; padding: 1rem; }
        .issue:last-child { border-radius: 0 0 0.5rem 0.5rem; }
        .issue-title { font-weight: 600; margin-bottom: 0.25rem; }
        .issue-location { font-family: monospace; font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
        .issue-meta { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; gap: 0.75rem; align-items: center; }
        .issue-meta .reviewers { background: #f1f5f9; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin: 0; }
        .confidence-badge { padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 500; }
        .confidence-badge.trusted { background: #d1fae5; color: #065f46; }
        .confidence-badge.likely { background: #dbeafe; color: #1e40af; }
        .confidence-badge.evaluate { background: #ede9fe; color: #5b21b6; }
        pre { background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; font-size: 0.875rem; margin: 0.5rem 0; }
        .problem { margin: 0.75rem 0; }
        .fix-label { font-weight: 600; margin-top: 0.75rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Code Review Report</h1>
        <div class="subtitle">openHiTLS/openhitls - PR #993</div>
        <p style="margin-bottom: 1rem;"></p>

        <div class="stats">
            <div class="stat"><div class="stat-value">7</div><div class="stat-label">Total</div></div>
            <div class="stat critical"><div class="stat-value">0</div><div class="stat-label">Critical</div></div>
            <div class="stat high"><div class="stat-value">2</div><div class="stat-label">High</div></div>
            <div class="stat medium"><div class="stat-value">4</div><div class="stat-label">Medium</div></div>
            <div class="stat low"><div class="stat-value">1</div><div class="stat-label">Low</div></div>
        </div>

        <div class="reviewers">Reviewers: claude, gemini, codex</div>
<div class="section"><div class="section-title high">High</div>
<div class="issue">
                <div class="issue-title">Thread safety violation in static variable initialization</div>
                <div class="issue-location">crypto/xmss/src/xmss_tree.c:519-522</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE, GEMINI</span>
                    <span class="confidence-badge trusted">置信度: 可信</span>
                </div>
                <pre>/* Initialize address operations */
static CryptAdrsOps g_xmssCryptAdrsOps = {0};
const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();
XmssAdrsOps_ToCryptAdrsOps(&amp;g_xmssCryptAdrsOps, xmssOps);
treeCtx-&gt;adrsOps = &amp;g_xmssCryptAdrsOps;</pre>
                <div class="problem"><strong>Issue:</strong> The function XmssTree_InitCtx initializes a static local variable `g_xmssCryptAdrsOps` and calls XmssAdrsOps_ToCryptAdrsOps on it every time the function is invoked. Since the static variable is shared across all threads and modified in every call, concurrent calls from multiple threads can cause data races - one thread may overwrite the function pointers while another thread is using them through treeCtx->adrsOps.</div>
                <div class="fix-label">Fix:</div><pre>/* Initialize address operations */
/* Store adrsOpsStorage in TreeCtx (needs to be added to TreeCtx struct) */
/* In crypto/xmss/src/xmss_tree.h: typedef struct { ... CryptAdrsOps adrsOpsStorage; } TreeCtx; */

const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();
XmssAdrsOps_ToCryptAdrsOps(&amp;treeCtx-&gt;adrsOpsStorage, xmssOps);
treeCtx-&gt;adrsOps = &amp;treeCtx-&gt;adrsOpsStorage;</pre>
            </div>
<div class="issue">
                <div class="issue-title">XmssAdrs_SetType leaves stale fields in address</div>
                <div class="issue-location">crypto/xmss/src/xmss_address.c:34-37</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge evaluate">置信度: 需评估</span>
                </div>
                <pre>void XmssAdrs_SetType(XmssAdrs *adrs, uint32_t type)
{
    PUT_UINT32_BE(type, adrs-&gt;fields.type, 0);
}</pre>
                <div class="problem"><strong>Issue:</strong> XmssAdrs_SetType only writes the type field and does not clear the type-specific portion (bytes 16–31). RFC 8391 specifies that when the address type changes, the type-specific fields should be reset. Leaving stale keyPair/chain/hash/keyAndMask values when switching address types breaks domain separation and could produce incorrect hashes/signatures/verification results. Note: The old code in the diff shows XAdrsSetType did clear the padding field. This new implementation may have regressed.</div>
                <div class="fix-label">Fix:</div><pre>void XmssAdrs_SetType(XmssAdrs *adrs, uint32_t type)
{
    PUT_UINT32_BE(type, adrs-&gt;fields.type, 0);
    (void)memset_s(adrs-&gt;fields.keyPairAddr, sizeof(adrs-&gt;fields.keyPairAddr), 0,
                   sizeof(adrs-&gt;fields.keyPairAddr));
    (void)memset_s(adrs-&gt;fields.chainAddr, sizeof(adrs-&gt;fields.chainAddr), 0,
                   sizeof(adrs-&gt;fields.chainAddr));
    (void)memset_s(adrs-&gt;fields.hashAddr, sizeof(adrs-&gt;fields.hashAddr), 0,
                   sizeof(adrs-&gt;fields.hashAddr));
    (void)memset_s(adrs-&gt;fields.keyAndMask, sizeof(adrs-&gt;fields.keyAndMask), 0,
                   sizeof(adrs-&gt;fields.keyAndMask));
}</pre>
            </div>
</div>
<div class="section"><div class="section-title medium">Medium</div>
<div class="issue">
                <div class="issue-title">sigLen set on error path in XmssWots_Sign</div>
                <div class="issue-location">crypto/xmss/src/xmss_wots.c:223-226</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>ERR:
    BSL_SAL_Free(msgw);
    *sigLen = len * n;
    return ret;
}</pre>
                <div class="problem"><strong>Issue:</strong> In XmssWots_Sign, the `*sigLen = len * n` assignment is executed unconditionally after the ERR label, meaning it runs even when an error occurs. This sets the output sigLen to the expected length even on failure, which could mislead callers about the actual state of the signature buffer.</div>
                <div class="fix-label">Fix:</div><pre>*sigLen = len * n;
    BSL_SAL_Free(msgw);
    return CRYPT_SUCCESS;

ERR:
    BSL_SAL_Free(msgw);
    return ret;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Potential buffer overflow in XmssWots_Sign memcpy_s</div>
                <div class="issue-location">crypto/xmss/src/xmss_wots.c:195-198</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: GEMINI</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>uint32_t adrsLen3 = ctx-&gt;adrsOps-&gt;getAdrsLen();
uint8_t skAdrsBuffer[32] = {0};  // Max address size
void *skAdrs = skAdrsBuffer;
(void)memcpy_s(skAdrs, adrsLen3, adrs, adrsLen3);</pre>
                <div class="problem"><strong>Issue:</strong> The memcpy_s call uses `adrsLen3` (returned by `getAdrsLen()`) as the destination size limit (`destMax`). However, `skAdrsBuffer` has a fixed size of 32 bytes. If `adrsLen3` is ever larger than 32 bytes (which is the maximum for XMSS addresses), the destMax argument would be incorrect. The second argument to memcpy_s should be the size of the destination buffer.</div>
                <div class="fix-label">Fix:</div><pre>uint32_t adrsLen3 = ctx-&gt;adrsOps-&gt;getAdrsLen();
uint8_t skAdrsBuffer[32] = {0};  // Max address size
void *skAdrs = skAdrsBuffer;
(void)memcpy_s(skAdrs, sizeof(skAdrsBuffer), adrs, adrsLen3);</pre>
            </div>
<div class="issue">
                <div class="issue-title">Partial key cleanup on CRYPT_RandEx or XmssTree_ComputeNode failure</div>
                <div class="issue-location">crypto/xmss/src/xmss_core.c:68-93</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>/* Generate random private seed */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.seed, n);
if (ret != CRYPT_SUCCESS) {
    return ret;
}

/* Generate random PRF key */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.prf, n);
if (ret != CRYPT_SUCCESS) {
    return ret;
}

/* Generate random public seed */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.pubSeed, n);
if (ret != CRYPT_SUCCESS) {
    return ret;
}
...
ret = XmssTree_ComputeNode(node, 0, hp, &amp;adrs, &amp;treeCtx, NULL, 0);
if (ret != CRYPT_SUCCESS) {
    BSL_ERR_PUSH_ERROR(ret);
    return ret;
}</pre>
                <div class="problem"><strong>Issue:</strong> In CRYPT_XMSS_KeyGenInternal, if CRYPT_RandEx fails for prf or pubSeed, the previously generated secrets (seed) remain in ctx->key without being cleaned up. Similarly, if XmssTree_ComputeNode fails after all random seeds have been generated, sensitive key material (seed, prf, pubSeed) is left in memory.</div>
                <div class="fix-label">Fix:</div><pre>/* Generate random private seed */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.seed, n);
if (ret != CRYPT_SUCCESS) {
    return ret;
}

/* Generate random PRF key */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.prf, n);
if (ret != CRYPT_SUCCESS) {
    BSL_SAL_CleanseData(ctx-&gt;key.seed, sizeof(ctx-&gt;key.seed));
    return ret;
}

/* Generate random public seed */
ret = CRYPT_RandEx(ctx-&gt;libCtx, ctx-&gt;key.pubSeed, n);
if (ret != CRYPT_SUCCESS) {
    BSL_SAL_CleanseData(ctx-&gt;key.seed, sizeof(ctx-&gt;key.seed));
    BSL_SAL_CleanseData(ctx-&gt;key.prf, sizeof(ctx-&gt;key.prf));
    return ret;
}
...
ret = XmssTree_ComputeNode(node, 0, hp, &amp;adrs, &amp;treeCtx, NULL, 0);
if (ret != CRYPT_SUCCESS) {
    BSL_SAL_CleanseData(ctx-&gt;key.seed, sizeof(ctx-&gt;key.seed));
    BSL_SAL_CleanseData(ctx-&gt;key.prf, sizeof(ctx-&gt;key.prf));
    BSL_SAL_CleanseData(ctx-&gt;key.pubSeed, sizeof(ctx-&gt;key.pubSeed));
    BSL_ERR_PUSH_ERROR(ret);
    return ret;
}</pre>
            </div>
<div class="issue">
                <div class="issue-title">Verification accepts oversized signatures</div>
                <div class="issue-location">crypto/xmss/src/xmss_core.c:179-182</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CODEX</span>
                    <span class="confidence-badge likely">置信度: 较可信</span>
                </div>
                <pre>if (sigLen &lt; ctx-&gt;params.sigBytes) {
    BSL_ERR_PUSH_ERROR(CRYPT_XMSS_ERR_INVALID_SIG_LEN);
    return CRYPT_XMSS_ERR_INVALID_SIG_LEN;
}</pre>
                <div class="problem"><strong>Issue:</strong> Verification only rejects signatures shorter than the expected size (`sigLen < ctx->params.sigBytes`) and accepts longer buffers. This allows trailing garbage/malleability and deviates from the fixed-length XMSS signature format defined in RFC 8391.</div>
                <div class="fix-label">Fix:</div><pre>if (sigLen != ctx-&gt;params.sigBytes) {
    BSL_ERR_PUSH_ERROR(CRYPT_XMSS_ERR_INVALID_SIG_LEN);
    return CRYPT_XMSS_ERR_INVALID_SIG_LEN;
}</pre>
            </div>
</div>
<div class="section"><div class="section-title low">Low</div>
<div class="issue">
                <div class="issue-title">Potential truncation in leafIdx calculation for large hp values</div>
                <div class="issue-location">crypto/xmss/src/xmss_core.c:201</div>
                <div class="issue-meta">
                    <span class="reviewers">Reviewers: CLAUDE</span>
                    <span class="confidence-badge evaluate">置信度: 需评估</span>
                </div>
                <pre>uint32_t leafIdx = index &amp; ((1UL &lt;&lt; hp) - 1);</pre>
                <div class="problem"><strong>Issue:</strong> The leafIdx calculation uses `(1UL << hp)` which could behave differently on 32-bit vs 64-bit systems. While XMSS variants have hp up to 20 (safely within uint32_t range), the pattern is inconsistent with the SignInternal function at line 153 which correctly uses `(1ULL << hp)`. Using `1UL` (unsigned long) may be 32 bits on some systems.</div>
                <div class="fix-label">Fix:</div><pre>uint32_t leafIdx = (uint32_t)(index &amp; ((1ULL &lt;&lt; hp) - 1));</pre>
            </div>
</div>
</div></body></html>