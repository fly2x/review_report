So `CryptXmssCtx` has its own `CryptAdrsOps adrsOps;` member, but `XmssTree_InitCtx` ignores it and uses a static variable instead. This is definitely a bug/inconsistency. The correct approach would be to use `&ctx->adrsOps` instead.

Actually, looking more carefully at the code flow:

1. `CRYPT_XMSS_InitInternal` calls `XmssAdrsOps_ToCryptAdrsOps(&ctx->adrsOps, xmssOps)` to initialize `ctx->adrsOps`
2. `XmssTree_InitCtx` creates a static `g_xmssCryptAdrsOps` and points to that instead

This means the `ctx->adrsOps` that was initialized in step 1 is never actually used by `TreeCtx`. Instead, all `TreeCtx` instances share the same static variable.

The fix should be:
```c
treeCtx->adrsOps = &ctx->adrsOps;
```
instead of
```c
static CryptAdrsOps g_xmssCryptAdrsOps = {0};
const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();
XmssAdrsOps_ToCryptAdrsOps(&g_xmssCryptAdrsOps, xmssOps);
treeCtx->adrsOps = &g_xmssCryptAdrsOps;
```

Now let me summarize the issues I've found:

===ISSUE===
FILE: crypto/xmss/src/xmss_tree.c
LINE: 519-522
SEVERITY: high
TITLE: Static variable causes shared state and potential thread safety issue
PROBLEM:
The `XmssTree_InitCtx` function uses a static variable `g_xmssCryptAdrsOps` to store address operation function pointers. This causes multiple issues:

1. All `TreeCtx` instances share the same static variable, even though `CryptXmssCtx` has its own `adrsOps` member that was initialized in `CRYPT_XMSS_InitInternal`.

2. The static variable is re-initialized on every call to `XmssTree_InitCtx`, creating unnecessary work and a potential race condition in multi-threaded environments.

3. The `ctx->adrsOps` member in `CryptXmssCtx` is initialized but never used - the code always points to the static variable instead.

CODE:
```c
void XmssTree_InitCtx(TreeCtx *treeCtx, const CryptXmssCtx *ctx)
{
    ...
    /* Initialize address operations */
    static CryptAdrsOps g_xmssCryptAdrsOps = {0};
    const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();
    XmssAdrsOps_ToCryptAdrsOps(&g_xmssCryptAdrsOps, xmssOps);
    treeCtx->adrsOps = &g_xmssCryptAdrsOps;
    ...
}
```
FIX:
```c
void XmssTree_InitCtx(TreeCtx *treeCtx, const CryptXmssCtx *ctx)
{
    ...
    /* Initialize address operations - use ctx's adrsOps that was initialized in CRYPT_XMSS_InitInternal */
    treeCtx->adrsOps = &ctx->adrsOps;
    ...
}
```
===END===

===ISSUE===
FILE: crypto/xmss/src/xmss_tree.c
LINE: 494
SEVERITY: low
TITLE: Misleading variable name for XMSS hash function table
PROBLEM:
The static variable `g_slhdsaCryptHashFuncs` is named as if it belongs to SLH-DSA, but it's actually the hash function table for XMSS (in `xmss_tree.c`). This is confusing copy-paste residue.

CODE:
```c
/* Static CryptHashFuncs table for XMSS */
static const CryptHashFuncs g_slhdsaCryptHashFuncs = {
```
FIX:
```c
/* Static CryptHashFuncs table for XMSS */
static const CryptHashFuncs g_xmssCryptHashFuncs = {
```
Then update line 517:
```c
treeCtx->hashFuncs = &g_xmssCryptHashFuncs;
```
===END===

===ISSUE===
FILE: crypto/xmss/src/xmss_core.c
LINE: 201
SEVERITY: medium
TITLE: Inconsistent shift operation (UL vs ULL)
PROBLEM:
Line 201 uses `1UL` for the shift operation, while line 153 uses `1ULL`. While the current implementation has `hp <= 20` (so no overflow), the inconsistency should be fixed for clarity and future-proofing.

CODE:
```c
// Line 153 in CRYPT_XMSS_SignInternal:
uint32_t leafIdx = (uint32_t)(index & ((1ULL << hp) - 1));

// Line 201 in CRYPT_XMSS_VerifyInternal:
uint32_t leafIdx = index & ((1UL << hp) - 1);
```
FIX:
```c
// Use consistent 1ULL for both:
uint32_t leafIdx = index & ((1ULL << hp) - 1);
```
===END===

===ISSUE===
FILE: crypto/xmss/src/xmss_tree.c
LINE: 380
SEVERITY: medium
TITLE: Inconsistent shift operation (UL vs ULL in HyperTree_Sign)
PROBLEM:
Line 380 uses `1UL` for the shift operation. While `hp <= 20`, this should be consistent with other uses.

CODE:
```c
leafIdxTmp = (uint32_t)(treeIdxTmp & ((1UL << hp) - 1));
```
FIX:
```c
leafIdxTmp = (uint32_t)(treeIdxTmp & ((1ULL << hp) - 1));
```
===END===

===ISSUE===
FILE: crypto/xmss/src/xmss_tree.c
LINE: 421
SEVERITY: low
TITLE: Inconsistent use of explicit uint64_t cast
PROBLEM:
Line 421 explicitly casts to `uint64_t`, but line 380 doesn't. This inconsistency should be fixed.

CODE:
```c
// Line 380:
leafIdxTmp = (uint32_t)(treeIdxTmp & ((1UL << hp) - 1));

// Line 421:
leafIdx = (uint32_t)(treeIdx & (((uint64_t)1 << hp) - 1));
```
FIX:
Both should use `1ULL` for consistency:
```c
// Line 380:
leafIdxTmp = (uint32_t)(treeIdxTmp & ((1ULL << hp) - 1));

// Line 421:
leafIdx = (uint32_t)(treeIdx & ((1ULL << hp) - 1));
```
===END===

===ISSUE===
FILE: crypto/slh_dsa/src/slh_dsa.c
LINE: 315
SEVERITY: low
TITLE: Unnecessary uintptr_t cast
PROBLEM:
The cast `(void *)(uintptr_t)ctx` is unnecessary. A direct cast from `const CryptSlhDsaCtx *` to `void *` would work fine.

CODE:
```c
treeCtx->originalCtx = (void *)(uintptr_t)ctx;
```
FIX:
```c
treeCtx->originalCtx = (void *)ctx;
```
===END===

===ISSUE===
FILE: crypto/xmss/src/xmss_tree.c
LINE: 523
SEVERITY: low
TITLE: Unnecessary uintptr_t cast
PROBLEM:
Same as above - the cast through `uintptr_t` is unnecessary.

CODE:
```c
treeCtx->originalCtx = (void *)(uintptr_t)ctx;
```
FIX:
```c
treeCtx->originalCtx = (void *)ctx;
```
===END===