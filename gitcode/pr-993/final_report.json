{
  "context": {
    "owner": "openHiTLS",
    "repo": "openhitls",
    "pr_id": "993",
    "title": "",
    "reviewers": [
      "claude",
      "gemini",
      "codex"
    ]
  },
  "statistics": {
    "total": 7,
    "critical": 0,
    "high": 2,
    "medium": 4,
    "low": 1
  },
  "issues": [
    {
      "file": "crypto/xmss/src/xmss_tree.c",
      "line": "519-522",
      "severity": "high",
      "title": "Thread safety violation in static variable initialization",
      "reviewers": "CLAUDE, GEMINI",
      "confidence": "trusted",
      "problem": "The function XmssTree_InitCtx initializes a static local variable `g_xmssCryptAdrsOps` and calls XmssAdrsOps_ToCryptAdrsOps on it every time the function is invoked. Since the static variable is shared across all threads and modified in every call, concurrent calls from multiple threads can cause data races - one thread may overwrite the function pointers while another thread is using them through treeCtx->adrsOps.",
      "code": "/* Initialize address operations */\nstatic CryptAdrsOps g_xmssCryptAdrsOps = {0};\nconst XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();\nXmssAdrsOps_ToCryptAdrsOps(&g_xmssCryptAdrsOps, xmssOps);\ntreeCtx->adrsOps = &g_xmssCryptAdrsOps;",
      "fix": "/* Initialize address operations */\n/* Store adrsOpsStorage in TreeCtx (needs to be added to TreeCtx struct) */\n/* In crypto/xmss/src/xmss_tree.h: typedef struct { ... CryptAdrsOps adrsOpsStorage; } TreeCtx; */\n\nconst XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();\nXmssAdrsOps_ToCryptAdrsOps(&treeCtx->adrsOpsStorage, xmssOps);\ntreeCtx->adrsOps = &treeCtx->adrsOpsStorage;"
    },
    {
      "file": "crypto/xmss/src/xmss_address.c",
      "line": "34-37",
      "severity": "high",
      "title": "XmssAdrs_SetType leaves stale fields in address",
      "reviewers": "CODEX",
      "confidence": "evaluate",
      "problem": "XmssAdrs_SetType only writes the type field and does not clear the type-specific portion (bytes 16â€“31). RFC 8391 specifies that when the address type changes, the type-specific fields should be reset. Leaving stale keyPair/chain/hash/keyAndMask values when switching address types breaks domain separation and could produce incorrect hashes/signatures/verification results. Note: The old code in the diff shows XAdrsSetType did clear the padding field. This new implementation may have regressed.",
      "code": "void XmssAdrs_SetType(XmssAdrs *adrs, uint32_t type)\n{\n    PUT_UINT32_BE(type, adrs->fields.type, 0);\n}",
      "fix": "void XmssAdrs_SetType(XmssAdrs *adrs, uint32_t type)\n{\n    PUT_UINT32_BE(type, adrs->fields.type, 0);\n    (void)memset_s(adrs->fields.keyPairAddr, sizeof(adrs->fields.keyPairAddr), 0,\n                   sizeof(adrs->fields.keyPairAddr));\n    (void)memset_s(adrs->fields.chainAddr, sizeof(adrs->fields.chainAddr), 0,\n                   sizeof(adrs->fields.chainAddr));\n    (void)memset_s(adrs->fields.hashAddr, sizeof(adrs->fields.hashAddr), 0,\n                   sizeof(adrs->fields.hashAddr));\n    (void)memset_s(adrs->fields.keyAndMask, sizeof(adrs->fields.keyAndMask), 0,\n                   sizeof(adrs->fields.keyAndMask));\n}"
    },
    {
      "file": "crypto/xmss/src/xmss_wots.c",
      "line": "223-226",
      "severity": "medium",
      "title": "sigLen set on error path in XmssWots_Sign",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "In XmssWots_Sign, the `*sigLen = len * n` assignment is executed unconditionally after the ERR label, meaning it runs even when an error occurs. This sets the output sigLen to the expected length even on failure, which could mislead callers about the actual state of the signature buffer.",
      "code": "ERR:\n    BSL_SAL_Free(msgw);\n    *sigLen = len * n;\n    return ret;\n}",
      "fix": "*sigLen = len * n;\n    BSL_SAL_Free(msgw);\n    return CRYPT_SUCCESS;\n\nERR:\n    BSL_SAL_Free(msgw);\n    return ret;\n}"
    },
    {
      "file": "crypto/xmss/src/xmss_wots.c",
      "line": "195-198",
      "severity": "medium",
      "title": "Potential buffer overflow in XmssWots_Sign memcpy_s",
      "reviewers": "GEMINI",
      "confidence": "likely",
      "problem": "The memcpy_s call uses `adrsLen3` (returned by `getAdrsLen()`) as the destination size limit (`destMax`). However, `skAdrsBuffer` has a fixed size of 32 bytes. If `adrsLen3` is ever larger than 32 bytes (which is the maximum for XMSS addresses), the destMax argument would be incorrect. The second argument to memcpy_s should be the size of the destination buffer.",
      "code": "uint32_t adrsLen3 = ctx->adrsOps->getAdrsLen();\nuint8_t skAdrsBuffer[32] = {0};  // Max address size\nvoid *skAdrs = skAdrsBuffer;\n(void)memcpy_s(skAdrs, adrsLen3, adrs, adrsLen3);",
      "fix": "uint32_t adrsLen3 = ctx->adrsOps->getAdrsLen();\nuint8_t skAdrsBuffer[32] = {0};  // Max address size\nvoid *skAdrs = skAdrsBuffer;\n(void)memcpy_s(skAdrs, sizeof(skAdrsBuffer), adrs, adrsLen3);"
    },
    {
      "file": "crypto/xmss/src/xmss_core.c",
      "line": "68-93",
      "severity": "medium",
      "title": "Partial key cleanup on CRYPT_RandEx or XmssTree_ComputeNode failure",
      "reviewers": "CLAUDE",
      "confidence": "likely",
      "problem": "In CRYPT_XMSS_KeyGenInternal, if CRYPT_RandEx fails for prf or pubSeed, the previously generated secrets (seed) remain in ctx->key without being cleaned up. Similarly, if XmssTree_ComputeNode fails after all random seeds have been generated, sensitive key material (seed, prf, pubSeed) is left in memory.",
      "code": "/* Generate random private seed */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.seed, n);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\n/* Generate random PRF key */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.prf, n);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\n/* Generate random public seed */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.pubSeed, n);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n...\nret = XmssTree_ComputeNode(node, 0, hp, &adrs, &treeCtx, NULL, 0);\nif (ret != CRYPT_SUCCESS) {\n    BSL_ERR_PUSH_ERROR(ret);\n    return ret;\n}",
      "fix": "/* Generate random private seed */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.seed, n);\nif (ret != CRYPT_SUCCESS) {\n    return ret;\n}\n\n/* Generate random PRF key */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.prf, n);\nif (ret != CRYPT_SUCCESS) {\n    BSL_SAL_CleanseData(ctx->key.seed, sizeof(ctx->key.seed));\n    return ret;\n}\n\n/* Generate random public seed */\nret = CRYPT_RandEx(ctx->libCtx, ctx->key.pubSeed, n);\nif (ret != CRYPT_SUCCESS) {\n    BSL_SAL_CleanseData(ctx->key.seed, sizeof(ctx->key.seed));\n    BSL_SAL_CleanseData(ctx->key.prf, sizeof(ctx->key.prf));\n    return ret;\n}\n...\nret = XmssTree_ComputeNode(node, 0, hp, &adrs, &treeCtx, NULL, 0);\nif (ret != CRYPT_SUCCESS) {\n    BSL_SAL_CleanseData(ctx->key.seed, sizeof(ctx->key.seed));\n    BSL_SAL_CleanseData(ctx->key.prf, sizeof(ctx->key.prf));\n    BSL_SAL_CleanseData(ctx->key.pubSeed, sizeof(ctx->key.pubSeed));\n    BSL_ERR_PUSH_ERROR(ret);\n    return ret;\n}"
    },
    {
      "file": "crypto/xmss/src/xmss_core.c",
      "line": "179-182",
      "severity": "medium",
      "title": "Verification accepts oversized signatures",
      "reviewers": "CODEX",
      "confidence": "likely",
      "problem": "Verification only rejects signatures shorter than the expected size (`sigLen < ctx->params.sigBytes`) and accepts longer buffers. This allows trailing garbage/malleability and deviates from the fixed-length XMSS signature format defined in RFC 8391.",
      "code": "if (sigLen < ctx->params.sigBytes) {\n    BSL_ERR_PUSH_ERROR(CRYPT_XMSS_ERR_INVALID_SIG_LEN);\n    return CRYPT_XMSS_ERR_INVALID_SIG_LEN;\n}",
      "fix": "if (sigLen != ctx->params.sigBytes) {\n    BSL_ERR_PUSH_ERROR(CRYPT_XMSS_ERR_INVALID_SIG_LEN);\n    return CRYPT_XMSS_ERR_INVALID_SIG_LEN;\n}"
    },
    {
      "file": "crypto/xmss/src/xmss_core.c",
      "line": "201",
      "severity": "low",
      "title": "Potential truncation in leafIdx calculation for large hp values",
      "reviewers": "CLAUDE",
      "confidence": "evaluate",
      "problem": "The leafIdx calculation uses `(1UL << hp)` which could behave differently on 32-bit vs 64-bit systems. While XMSS variants have hp up to 20 (safely within uint32_t range), the pattern is inconsistent with the SignInternal function at line 153 which correctly uses `(1ULL << hp)`. Using `1UL` (unsigned long) may be 32 bits on some systems.",
      "code": "uint32_t leafIdx = index & ((1UL << hp) - 1);",
      "fix": "uint32_t leafIdx = (uint32_t)(index & ((1ULL << hp) - 1));"
    }
  ]
}