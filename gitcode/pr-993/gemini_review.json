[
  {
    "source": "gemini",
    "file": "crypto/xmss/src/xmss_tree.c",
    "line": "519",
    "severity": "critical",
    "title": "Thread safety violation in `XmssTree_InitCtx`",
    "problem": "The function uses a `static` local variable `g_xmssCryptAdrsOps` which is modified in every call via `XmssAdrsOps_ToCryptAdrsOps`. This creates a data race if multiple threads call `XmssTree_InitCtx` (e.g., during parallel signature verification), potentially corrupting the function pointers and causing crashes or undefined behavior.",
    "code": "/* Initialize address operations */\n    static CryptAdrsOps g_xmssCryptAdrsOps = {0};\n    const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();\n    XmssAdrsOps_ToCryptAdrsOps(&g_xmssCryptAdrsOps, xmssOps);\n    treeCtx->adrsOps = &g_xmssCryptAdrsOps;",
    "fix": "/* Initialize address operations */\n    /* Store adrsOpsStorage in TreeCtx (needs to be added to TreeCtx struct) */\n    /* In crypto/xmss/src/xmss_tree.h: typedef struct { ... CryptAdrsOps adrsOpsStorage; } TreeCtx; */\n    \n    const XmssAdrsOps *xmssOps = XmssAdrs_GetDefaultOps();\n    XmssAdrsOps_ToCryptAdrsOps(&treeCtx->adrsOpsStorage, xmssOps);\n    treeCtx->adrsOps = &treeCtx->adrsOpsStorage;"
  },
  {
    "source": "gemini",
    "file": "crypto/xmss/src/xmss_wots.c",
    "line": "199",
    "severity": "medium",
    "title": "Potential buffer overflow in `XmssWots_Sign`",
    "problem": "`memcpy_s` uses `adrsLen3` (which comes from `getAdrsLen()`) as the destination size limit (`destMax`). `skAdrsBuffer` has a fixed size of 32 bytes. If `adrsLen3` is ever larger than 32, this will cause a stack buffer overflow. The second argument to `memcpy_s` should be the size of the destination buffer.",
    "code": "uint32_t adrsLen3 = ctx->adrsOps->getAdrsLen();\n    uint8_t skAdrsBuffer[32] = {0};  // Max address size\n    void *skAdrs = skAdrsBuffer;\n    (void)memcpy_s(skAdrs, adrsLen3, adrs, adrsLen3);",
    "fix": "uint32_t adrsLen3 = ctx->adrsOps->getAdrsLen();\n    uint8_t skAdrsBuffer[32] = {0};  // Max address size\n    void *skAdrs = skAdrsBuffer;\n    (void)memcpy_s(skAdrs, sizeof(skAdrsBuffer), adrs, adrsLen3);"
  },
  {
    "source": "gemini",
    "file": "crypto/xmss/src/xmss_wots.c",
    "line": "133",
    "severity": "low",
    "title": "Potential out-of-bounds read in `XmssWots_GeneratePublicKey`",
    "problem": "`memcpy_s` reads `sizeof(skAdrsBuffer)` (32 bytes) from `adrs`. While `XMSS_ADRS_LEN` is currently 32, if `adrs` points to a smaller buffer (e.g., a compressed address of 22 bytes in SLH-DSA), this would read out of bounds. It is safer to use `ctx->adrsOps->getAdrsLen()` for the source size.",
    "code": "uint8_t skAdrsBuffer[32] = {0};  // Max address size\n    void *skAdrs = skAdrsBuffer;\n    (void)memcpy_s(skAdrs, sizeof(skAdrsBuffer), adrs, sizeof(skAdrsBuffer));",
    "fix": "uint8_t skAdrsBuffer[32] = {0};  // Max address size\n    void *skAdrs = skAdrsBuffer;\n    (void)memcpy_s(skAdrs, sizeof(skAdrsBuffer), adrs, ctx->adrsOps->getAdrsLen());"
  }
]