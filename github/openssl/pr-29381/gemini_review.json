[
  {
    "source": "gemini",
    "file": "providers/implementations/encode_decode/lms_codecs.c",
    "line": "117-136",
    "severity": "high",
    "title": "ossl_lms_i2d_pubkey violates i2d semantics and leaks memory",
    "problem": "The function `ossl_lms_i2d_pubkey` does not follow the standard OpenSSL `i2d` calling convention. \n1. It ignores the value of `*out` if `out` is not NULL, and always allocates a new buffer. If `*out` pointed to an existing buffer (as expected by many OpenSSL internal encoders), that pointer is overwritten, leading to a memory leak of the ignored buffer or incorrect writing behavior.\n2. It returns `0` on error, whereas `i2d` functions typically return a negative value on error, or `0` could be ambiguous. However, returning `0` for length is generally considered an error in this context.\n3. It does not support the mode where it writes to a user-provided buffer (incrementing the pointer).\n\nCalls from `encode_key2any.c` (via `lms_spki_pub_to_der`) might expect standard `i2d` behavior (allocation only if `*out` is NULL).",
    "code": "int ossl_lms_i2d_pubkey(const LMS_KEY *key, unsigned char **out)\n{\n    if (key->pub.encoded == NULL || key->pub.encodedlen == 0) {\n        ERR_raise_data(ERR_LIB_PROV, PROV_R_NOT_A_PUBLIC_KEY,\n            \"no %s public key data available\", \"LMS\");\n        return 0;\n    }\n    if (out != NULL) {\n        uint8_t *buf = OPENSSL_malloc(HSS_HEADER + key->pub.encodedlen);\n\n        if (buf == NULL)\n            return 0;\n        /* Output HSS format which has a 4 byte value (L = 1) */\n        memcpy(buf, hss_lms_32_spkifmt.header + sizeof(hss_lms_32_spkifmt.header) - HSS_HEADER, HSS_HEADER);\n        /* Output the LMS encoded public key */\n        memcpy(buf + HSS_HEADER, key->pub.encoded, key->pub.encodedlen);\n        *out = buf;\n    }\n    return (int)key->pub.encodedlen + HSS_HEADER;\n}",
    "fix": "int ossl_lms_i2d_pubkey(const LMS_KEY *key, unsigned char **out)\n{\n    int len;\n    unsigned char *p;\n\n    if (key->pub.encoded == NULL || key->pub.encodedlen == 0) {\n        ERR_raise_data(ERR_LIB_PROV, PROV_R_NOT_A_PUBLIC_KEY,\n            \"no %s public key data available\", \"LMS\");\n        return -1;\n    }\n    \n    len = (int)key->pub.encodedlen + HSS_HEADER;\n\n    if (out == NULL)\n        return len;\n\n    if (*out == NULL) {\n        if ((*out = OPENSSL_malloc(len)) == NULL)\n            return -1;\n        p = *out;\n    } else {\n        p = *out;\n    }\n\n    /* Output HSS format which has a 4 byte value (L = 1) */\n    memcpy(p, hss_lms_32_spkifmt.header + sizeof(hss_lms_32_spkifmt.header) - HSS_HEADER, HSS_HEADER);\n    /* Output the LMS encoded public key */\n    memcpy(p + HSS_HEADER, key->pub.encoded, key->pub.encodedlen);\n\n    if (*out != p) /* If we didn't allocate, advance the pointer */\n        *out += len;\n        \n    return len;\n}"
  },
  {
    "source": "gemini",
    "file": "providers/implementations/encode_decode/lms_codecs.c",
    "line": "81",
    "severity": "medium",
    "title": "Brittle manual parsing of SPKI header violates DER rules",
    "problem": "The function `find_spkifmt` (and thus `ossl_lms_d2i_PUBKEY`) uses `memcmp` to verify the SubjectPublicKeyInfo (SPKI) header against a hardcoded byte sequence. This rejects valid DER/BER encodings that use long-form length encoding (e.g., `81 4E` instead of `4E`) or other valid variations. It also relies on the exact byte match of the AlgorithmIdentifier OID and parameters, making it brittle. OpenSSL provides `d2i_X509_PUBKEY` for robust parsing of SPKI structures.",
    "code": "if (memcmp(pk, codecs[i].spkifmt->header, HSS_LMS_SPKI_OVERHEAD) == 0)\n            return codecs[i].spkifmt;",
    "fix": "/* Use d2i_X509_PUBKEY to parse the header robustly */\nLMS_KEY *\nossl_lms_d2i_PUBKEY(const uint8_t *pk, int pk_len, PROV_CTX *provctx)\n{\n    OSSL_LIB_CTX *libctx = PROV_LIBCTX_OF(provctx);\n    LMS_KEY *ret = NULL;\n    X509_PUBKEY *xpk = NULL;\n    const unsigned char *p = pk;\n    const unsigned char *pk_data;\n    int pk_data_len;\n    ASN1_OBJECT *oid;\n\n    /* robustly decode SPKI */\n    if ((xpk = d2i_X509_PUBKEY(NULL, &p, pk_len)) == NULL)\n        return NULL;\n\n    if (!X509_PUBKEY_get0_param(&oid, &pk_data, &pk_data_len, NULL, xpk))\n        goto err;\n\n    /* Verify OID is id-ad-hss-lms-hash-sig (1.2.840.113549.1.9.16.3.17) */\n    /* Implementation needs the OID object or NID check here */\n    /* For simplicity in this context, assuming we can check NID or data */\n    \n    if ((ret = ossl_lms_key_new(libctx)) == NULL)\n        goto err;\n\n    /* Skip the HSS L=1 header (4 bytes) contained in the BIT STRING if present */\n    /* The hardcoded check expected the BIT STRING content to start with 00 00 00 01 */\n    if (pk_data_len < 4) \n        goto err;\n    \n    /* Check HSS L=1 marker 00 00 00 01 */\n    /* Note: Previous code implied the input was SPKI, and extracted data after header */\n    \n    if (pk_data[3] != 1) { /* Simplified check, strictly should check 00 00 00 01 */\n         /* Handle error */\n    }\n\n    if (!ossl_lms_pubkey_decode(pk_data + 4, pk_data_len - 4, ret)) {\n        ERR_raise_data(ERR_LIB_PROV, PROV_R_BAD_ENCODING,\n            \"error parsing %s public key from input SPKI\", \"LMS\");\n        ossl_lms_key_free(ret);\n        ret = NULL;\n    }\n\nerr:\n    X509_PUBKEY_free(xpk);\n    return ret;\n}"
  },
  {
    "source": "gemini",
    "file": "providers/implementations/keymgmt/lms_kmgmt.c",
    "line": "184",
    "severity": "medium",
    "title": "OSSL_PKEY_PARAM_PUB_KEY returns incomplete HSS public key",
    "problem": "`lms_get_params` exports the raw LMS public key (without the HSS L=1 header) for the `OSSL_PKEY_PARAM_PUB_KEY` parameter. However, `EVP_PKEY_HSS_LMS` keys are expected to be HSS keys (NIST SP 800-208). The standard representation of an HSS public key includes the 4-byte header (L || public_key). Exporting it without the header creates an invalid key for external consumers expecting the HSS format.",
    "code": "if (p.pubkey != NULL) {\n        d = ossl_lms_key_get_pub(key);\n        if (d != NULL) {\n            len = ossl_lms_key_get_pub_len(key);\n            if (!OSSL_PARAM_set_octet_string(p.pubkey, d, len))\n                return 0;\n        }\n    }",
    "fix": "if (p.pubkey != NULL) {\n        d = ossl_lms_key_get_pub(key);\n        if (d != NULL) {\n            unsigned char buf[64]; /* Enough for HSS header + largest LMS key */\n            size_t lms_len = ossl_lms_key_get_pub_len(key);\n            \n            if (lms_len + 4 > sizeof(buf)) /* Should not happen with current params */\n                return 0;\n\n            /* Prepend HSS Header (L=1) */\n            memset(buf, 0, 3);\n            buf[3] = 1;\n            memcpy(buf + 4, d, lms_len);\n            \n            if (!OSSL_PARAM_set_octet_string(p.pubkey, buf, lms_len + 4))\n                return 0;\n        }\n    }"
  },
  {
    "source": "gemini",
    "file": "crypto/lms/lms_params.c",
    "line": "22-26",
    "severity": "medium",
    "title": "Incorrect security strength for SHAKE instances",
    "problem": "The bit strength for SHAKE-based LMS parameters is listed as 256 or 192 bits, which corresponds to the output length (N) * 8. However, the security strength of a signature scheme is typically defined by its collision resistance. For SHAKE256 with output length $d$, the collision resistance is $\\min(d/2, 256)$ (or 128 for $d=256$). Listing 256 bits for N=32 (256-bit output) overstates the collision resistance, which is 128 bits. Similarly for N=24, it should be 96 bits, not 192.",
    "code": "{ OSSL_LMS_TYPE_SHAKE_N32_H5, \"SHAKE-256\", 32, 5, 256 },\n    { OSSL_LMS_TYPE_SHAKE_N32_H10, \"SHAKE-256\", 32, 10, 256 },\n    ...\n    /* SHAKE-256/192 */\n    { OSSL_LMS_TYPE_SHAKE_N24_H5, \"SHAKE-256\", 24, 5, 192 },",
    "fix": "/* Collision resistance is n/2 for SHAKE with length n */\n    { OSSL_LMS_TYPE_SHAKE_N32_H5, \"SHAKE-256\", 32, 5, 128 },\n    { OSSL_LMS_TYPE_SHAKE_N32_H10, \"SHAKE-256\", 32, 10, 128 },\n    { OSSL_LMS_TYPE_SHAKE_N32_H15, \"SHAKE-256\", 32, 15, 128 },\n    { OSSL_LMS_TYPE_SHAKE_N32_H20, \"SHAKE-256\", 32, 20, 128 },\n    { OSSL_LMS_TYPE_SHAKE_N32_H25, \"SHAKE-256\", 32, 25, 128 },\n    /* SHAKE-256/192 */\n    { OSSL_LMS_TYPE_SHAKE_N24_H5, \"SHAKE-256\", 24, 5, 96 },\n    { OSSL_LMS_TYPE_SHAKE_N24_H10, \"SHAKE-256\", 24, 10, 96 },\n    { OSSL_LMS_TYPE_SHAKE_N24_H15, \"SHAKE-256\", 24, 15, 96 },\n    { OSSL_LMS_TYPE_SHAKE_N24_H20, \"SHAKE-256\", 24, 20, 96 },\n    { OSSL_LMS_TYPE_SHAKE_N24_H25, \"SHAKE-256\", 24, 25, 96 },"
  }
]